#include"h.323.h"
static int dissect_h225_T_ip6Address(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index);
static int dissect_h225_T_ipxAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index);
static int dissect_h225_T_ipSourceRoute(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index);
static int dissect_h225_T_ipAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index);
int dissect_h225_TransportAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index);
dissector_handle_t
dissector_get_string_handle(dissector_table_t sub_dissectors,
			    const gchar *string);
gef_ctx_t* gef_ctx_alloc(gef_ctx_t *parent, const gchar *type);
static int
dissect_h225_IA5String(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index );
static int
dissect_h225_EnumeratedParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index );
gef_ctx_t* gef_ctx_alloc(gef_ctx_t *parent, const gchar *type);
gboolean asn1_ctx_check_signature(asn1_ctx_t *actx);
int
dissect_h225_GenericIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index );
static int
dissect_h225_INTEGER_0_255(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index );
static int
dissect_h225_TunnelledProtocolAlternateIdentifier(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index);
static int
dissect_h225_IA5String_SIZE_1_64(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index);
static const guint8*
tvb_get_ptr(tvbuff_t *tvb, const gint offset, const gint length);
static gchar *
ep_strdup_printf(const gchar *fmt, ...);
static const gchar*
val_to_str(const guint32 val, const value_string *vs, const char *fmt);
static void*
tvb_memcpy(tvbuff_t *tvb, guint8* target, const gint offset, size_t length);
static const guint8*
ensure_contiguous_no_exception(tvbuff_t *tvb, const gint offset, const gint length, int *exception);
guint32
dissect_per_sequence_of(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gint ett_index, const per_sequence_t *seq);
static guint32
dissect_per_sequence_of_helper(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, per_type_fn func, int hf_index, guint32 length);
guint32
dissect_per_constrained_sequence_of(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gint ett_index, const per_sequence_t *seq, int min_len, int max_len, gboolean has_extension );
static int
dissect_h225_INTEGER_0_4294967295(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index );
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
#define PNAME  "MULTIMEDIA-SYSTEM-CONTROL"
#define PSNAME_225 "H.225"
#define PFNAME_225 "h225"
#define PSNAME "H.245"
#define PFNAME "h245"
void asn1_ctx_init(asn1_ctx_t *actx, asn1_enc_e encoding, gboolean aligned, packet_info *pinfo);
static guint64
_tvb_get_bits64(tvbuff_t *tvb, guint bit_offset, const gint total_no_of_bits);
//static dissector_handle_t rtp_handle=NULL;
static dissector_handle_t rtcp_handle=NULL;
//static dissector_handle_t t38_handle=NULL;
static dissector_table_t nsp_object_dissector_table;
static dissector_table_t nsp_h221_dissector_table;
static dissector_table_t gef_name_dissector_table;
static dissector_table_t gef_content_dissector_table;
static dissector_handle_t nsp_handle;
//static dissector_handle_t data_handle;
static dissector_handle_t MultimediaSystemControlMessage_handle;
static dissector_handle_t h263_handle = NULL;
static dissector_handle_t amr_handle = NULL;

static void init_h245_packet_info(h245_packet_info *pi);
static int hf_h245_pdu_type = -1;
static int hf_h245Manufacturer = -1;
static int hf_h245_subMessageIdentifier_standard = -1;
static int h245_tap = -1;
static int h245dg_tap = -1;
h245_packet_info *h245_pi=NULL;

static gboolean h245_reassembly = TRUE;
static gboolean h245_shorttypes = FALSE;


/*--- Included file: packet-h245-val.h ---*/
//#line 1 "../../asn1/h245/packet-h245-val.h"

typedef enum _AudioCapability_enum {
  AudioCapability_nonStandard =   0,
  AudioCapability_g711Alaw64k =   1,
  AudioCapability_g711Alaw56k =   2,
  AudioCapability_g711Ulaw64k =   3,
  AudioCapability_g711Ulaw56k =   4,
  AudioCapability_g722_64k =   5,
  AudioCapability_g722_56k =   6,
  AudioCapability_g722_48k =   7,
  AudioCapability_g7231 =   8,
  AudioCapability_g728 =   9,
  AudioCapability_g729 =  10,
  AudioCapability_g729AnnexA =  11,
  AudioCapability_is11172AudioCapability =  12,
  AudioCapability_is13818AudioCapability =  13,
  AudioCapability_g729wAnnexB =  14,
  AudioCapability_g729AnnexAwAnnexB =  15,
  AudioCapability_g7231AnnexCCapability =  16,
  AudioCapability_gsmFullRate =  17,
  AudioCapability_gsmHalfRate =  18,
  AudioCapability_gsmEnhancedFullRate =  19,
  AudioCapability_genericAudioCapability =  20,
  AudioCapability_g729Extensions =  21,
  AudioCapability_vbd =  22,
  AudioCapability_audioTelephonyEvent =  23,
  AudioCapability_audioTone =  24
} AudioCapability_enum;

typedef enum _RequestMessage_enum {
  RequestMessage_nonStandard =   0,
  RequestMessage_masterSlaveDetermination =   1,
  RequestMessage_terminalCapabilitySet =   2,
  RequestMessage_openLogicalChannel =   3,
  RequestMessage_closeLogicalChannel =   4,
  RequestMessage_requestChannelClose =   5,
  RequestMessage_multiplexEntrySend =   6,
  RequestMessage_requestMultiplexEntry =   7,
  RequestMessage_requestMode =   8,
  RequestMessage_roundTripDelayRequest =   9,
  RequestMessage_maintenanceLoopRequest =  10,
  RequestMessage_communicationModeRequest =  11,
  RequestMessage_conferenceRequest =  12,
  RequestMessage_multilinkRequest =  13,
  RequestMessage_logicalChannelRateRequest =  14,
  RequestMessage_genericRequest =  15
} RequestMessage_enum;

typedef enum _ResponseMessage_enum {
  ResponseMessage_nonStandard =   0,
  ResponseMessage_masterSlaveDeterminationAck =   1,
  ResponseMessage_masterSlaveDeterminationReject =   2,
  ResponseMessage_terminalCapabilitySetAck =   3,
  ResponseMessage_terminalCapabilitySetReject =   4,
  ResponseMessage_openLogicalChannelAck =   5,
  ResponseMessage_openLogicalChannelReject =   6,
  ResponseMessage_closeLogicalChannelAck =   7,
  ResponseMessage_requestChannelCloseAck =   8,
  ResponseMessage_requestChannelCloseReject =   9,
  ResponseMessage_multiplexEntrySendAck =  10,
  ResponseMessage_multiplexEntrySendReject =  11,
  ResponseMessage_requestMultiplexEntryAck =  12,
  ResponseMessage_requestMultiplexEntryReject =  13,
  ResponseMessage_requestModeAck =  14,
  ResponseMessage_requestModeReject =  15,
  ResponseMessage_roundTripDelayResponse =  16,
  ResponseMessage_maintenanceLoopAck =  17,
  ResponseMessage_maintenanceLoopReject =  18,
  ResponseMessage_communicationModeResponse =  19,
  ResponseMessage_conferenceResponse =  20,
  ResponseMessage_multilinkResponse =  21,
  ResponseMessage_logicalChannelRateAcknowledge =  22,
  ResponseMessage_logicalChannelRateReject =  23,
  ResponseMessage_genericResponse =  24
} ResponseMessage_enum;

typedef enum _CommandMessage_enum {
  CommandMessage_nonStandard =   0,
  CommandMessage_maintenanceLoopOffCommand =   1,
  CommandMessage_sendTerminalCapabilitySet =   2,
  CommandMessage_encryptionCommand =   3,
  CommandMessage_flowControlCommand =   4,
  CommandMessage_endSessionCommand =   5,
  CommandMessage_miscellaneousCommand =   6,
  CommandMessage_communicationModeCommand =   7,
  CommandMessage_conferenceCommand =   8,
  CommandMessage_h223MultiplexReconfiguration =   9,
  CommandMessage_newATMVCCommand =  10,
  CommandMessage_mobileMultilinkReconfigurationCommand =  11,
  CommandMessage_genericCommand =  12
} CommandMessage_enum;

typedef enum _IndicationMessage_enum {
  IndicationMessage_nonStandard =   0,
  IndicationMessage_functionNotUnderstood =   1,
  IndicationMessage_masterSlaveDeterminationRelease =   2,
  IndicationMessage_terminalCapabilitySetRelease =   3,
  IndicationMessage_openLogicalChannelConfirm =   4,
  IndicationMessage_requestChannelCloseRelease =   5,
  IndicationMessage_multiplexEntrySendRelease =   6,
  IndicationMessage_requestMultiplexEntryRelease =   7,
  IndicationMessage_requestModeRelease =   8,
  IndicationMessage_miscellaneousIndication =   9,
  IndicationMessage_jitterIndication =  10,
  IndicationMessage_h223SkewIndication =  11,
  IndicationMessage_newATMVCIndication =  12,
  IndicationMessage_userInput =  13,
  IndicationMessage_h2250MaximumSkewIndication =  14,
  IndicationMessage_mcLocationIndication =  15,
  IndicationMessage_conferenceIndication =  16,
  IndicationMessage_vendorIdentification =  17,
  IndicationMessage_functionNotSupported =  18,
  IndicationMessage_multilinkIndication =  19,
  IndicationMessage_logicalChannelRateRelease =  20,
  IndicationMessage_flowControlIndication =  21,
  IndicationMessage_mobileMultilinkReconfigurationIndication =  22,
  IndicationMessage_genericIndication =  23
} IndicationMessage_enum;

/*--- End of included file: packet-h245-val.h ---*/
//#line 88 "../../asn1/h245/packet-h245-template.c"

static const value_string h245_RequestMessage_short_vals[] = {
	{ RequestMessage_nonStandard              ,	"NSM" },
	{ RequestMessage_masterSlaveDetermination ,	"MSD" },
	{ RequestMessage_terminalCapabilitySet    ,	"TCS" },
	{ RequestMessage_openLogicalChannel       ,	"OLC" },
	{ RequestMessage_closeLogicalChannel      ,	"CLC" },
	{ RequestMessage_requestChannelClose      ,	"RCC" },
	{ RequestMessage_multiplexEntrySend       ,	"MES" },
	{ RequestMessage_requestMultiplexEntry    ,	"RME" },
	{ RequestMessage_requestMode              ,	"RM"  },
	{ RequestMessage_roundTripDelayRequest    ,	"RTDR" },
	{ RequestMessage_maintenanceLoopRequest   ,	"MLR" },
	{ RequestMessage_communicationModeRequest ,	"CMR" },
	{ RequestMessage_conferenceRequest        ,	"CR"  },
	{ RequestMessage_multilinkRequest         ,	"MR"  },
	{ RequestMessage_logicalChannelRateRequest,	"LCRR" },
	{ RequestMessage_genericRequest           ,	"GR"  },
	{  0, NULL }
};
static const value_string h245_ResponseMessage_short_vals[] = {
	{ ResponseMessage_nonStandard                   ,	"NSM" },
	{ ResponseMessage_masterSlaveDeterminationAck   ,	"MSDAck" },
	{ ResponseMessage_masterSlaveDeterminationReject,	"MSDReject" },
	{ ResponseMessage_terminalCapabilitySetAck      ,	"TCSAck" },
	{ ResponseMessage_terminalCapabilitySetReject   ,	"TCSReject" },
	{ ResponseMessage_openLogicalChannelAck         ,	"OLCAck" },
	{ ResponseMessage_openLogicalChannelReject      ,	"OLCReject" },
	{ ResponseMessage_closeLogicalChannelAck        ,	"CLCAck" },
	{ ResponseMessage_requestChannelCloseAck        ,	"RCCAck" },
	{ ResponseMessage_requestChannelCloseReject     ,	"RCCReject" },
	{ ResponseMessage_multiplexEntrySendAck         ,	"MESAck" },
	{ ResponseMessage_multiplexEntrySendReject      ,	"MESReject" },
	{ ResponseMessage_requestMultiplexEntryAck      ,	"RMEAck" },
	{ ResponseMessage_requestMultiplexEntryReject   ,	"RMEReject" },
	{ ResponseMessage_requestModeAck                ,	"RMAck" },
	{ ResponseMessage_requestModeReject             ,	"RMReject" },
	{ ResponseMessage_roundTripDelayResponse        ,	"RTDResponse" },
	{ ResponseMessage_maintenanceLoopAck            ,	"MLAck" },
	{ ResponseMessage_maintenanceLoopReject         ,	"MLReject" },
	{ ResponseMessage_communicationModeResponse     ,	"CMResponse" },
	{ ResponseMessage_conferenceResponse            ,	"CResponse" },
	{ ResponseMessage_multilinkResponse             ,	"MResponse" },
	{ ResponseMessage_logicalChannelRateAcknowledge ,	"LCRAck" },
	{ ResponseMessage_logicalChannelRateReject      ,	"LCRReject" },
	{ ResponseMessage_genericResponse               ,	"GR" },
	{  0, NULL }
};
static const value_string h245_IndicationMessage_short_vals[] = {
	{ IndicationMessage_nonStandard                             ,	"NSM" },
	{ IndicationMessage_functionNotUnderstood                   ,	"FNU" },
	{ IndicationMessage_masterSlaveDeterminationRelease         ,	"MSDRelease" },
	{ IndicationMessage_terminalCapabilitySetRelease            ,	"TCSRelease" },
	{ IndicationMessage_openLogicalChannelConfirm               ,	"OLCConfirm" },
	{ IndicationMessage_requestChannelCloseRelease              ,	"RCCRelease" },
	{ IndicationMessage_multiplexEntrySendRelease               ,	"MESRelease" },
	{ IndicationMessage_requestMultiplexEntryRelease            ,	"RMERelease" },
	{ IndicationMessage_requestModeRelease                      ,	"RMRelease" },
	{ IndicationMessage_miscellaneousIndication                 ,	"MI" },
	{ IndicationMessage_jitterIndication                        ,	"JI" },
	{ IndicationMessage_h223SkewIndication                      ,	"H223SI" },
	{ IndicationMessage_newATMVCIndication                      ,	"NATMVCI" },
	{ IndicationMessage_userInput                               ,	"UII" },
	{ IndicationMessage_h2250MaximumSkewIndication              ,	"H2250MSI" },
	{ IndicationMessage_mcLocationIndication                    ,	"MCLI" },
	{ IndicationMessage_conferenceIndication                    ,	"CI" },
	{ IndicationMessage_vendorIdentification                    ,	"VI" },
	{ IndicationMessage_functionNotSupported                    ,	"FNS" },
	{ IndicationMessage_multilinkIndication                     ,	"MultilinkIndication" },
	{ IndicationMessage_logicalChannelRateRelease               ,	"LCRRelease" },
	{ IndicationMessage_flowControlIndication                   ,	"FCIndication" },
	{ IndicationMessage_mobileMultilinkReconfigurationIndication,	"MMRI" },
	{ IndicationMessage_genericIndication                       ,	"GI" },
	{  0, NULL }
};
static const value_string h245_CommandMessage_short_vals[] = {
	{ CommandMessage_nonStandard                          ,	"NSM" },
	{ CommandMessage_maintenanceLoopOffCommand            ,	"MLOC" },
	{ CommandMessage_sendTerminalCapabilitySet            ,	"STCS" },
	{ CommandMessage_encryptionCommand                    ,	"EC" },
	{ CommandMessage_flowControlCommand                   ,	"FCC" },
	{ CommandMessage_endSessionCommand                    ,	"ESC" },
	{ CommandMessage_miscellaneousCommand                 ,	"MC" },
	{ CommandMessage_communicationModeCommand             ,	"CMC" },
	{ CommandMessage_conferenceCommand                    ,	"CC" },
	{ CommandMessage_h223MultiplexReconfiguration         ,	"H223MR" },
	{ CommandMessage_newATMVCCommand                      ,	"NATMVCC" },
	{ CommandMessage_mobileMultilinkReconfigurationCommand,	"MMRC" },
	{ CommandMessage_genericCommand                       ,	"GC" },
	{  0, NULL }
};

static const value_string h245_AudioCapability_short_vals[] = {
  { AudioCapability_nonStandard           , "nonStd" },
  { AudioCapability_g711Alaw64k           , "g711A" },
  { AudioCapability_g711Alaw56k           , "g711A56k" },
  { AudioCapability_g711Ulaw64k           , "g711U" },
  { AudioCapability_g711Ulaw56k           , "g711U56k" },
  { AudioCapability_g722_64k              , "g722-64k" },
  { AudioCapability_g722_56k              , "g722-56k" },
  { AudioCapability_g722_48k              , "g722-48k" },
  { AudioCapability_g7231                 , "g7231" },
  { AudioCapability_g728                  , "g728" },
  { AudioCapability_g729                  , "g729" },
  { AudioCapability_g729AnnexA            , "g729A" },
  { AudioCapability_is11172AudioCapability, "is11172" },
  { AudioCapability_is13818AudioCapability, "is13818" },
  { AudioCapability_g729wAnnexB           , "g729B" },
  { AudioCapability_g729AnnexAwAnnexB     , "g729AB" },
  { AudioCapability_g7231AnnexCCapability , "g7231C" },
  { AudioCapability_gsmFullRate           , "gsmFR" },
  { AudioCapability_gsmHalfRate           , "gsmHR" },
  { AudioCapability_gsmEnhancedFullRate   , "gsmEFR" },
  { AudioCapability_genericAudioCapability, "generic" },
  { AudioCapability_g729Extensions        , "g729Ext" },
  { AudioCapability_vbd                   , "vbd" },
  { AudioCapability_audioTelephonyEvent   , "audioTelEvent" },
  { AudioCapability_audioTone             , "audioTone" },
  {  0, NULL }
};

static const value_string h245_RequestMessage_vals[] = {
  { RequestMessage_nonStandard, "nonStandard" },
  { RequestMessage_masterSlaveDetermination, "masterSlaveDetermination" },
  { RequestMessage_terminalCapabilitySet, "terminalCapabilitySet" },
  { RequestMessage_openLogicalChannel, "openLogicalChannel" },
  { RequestMessage_closeLogicalChannel, "closeLogicalChannel" },
  { RequestMessage_requestChannelClose, "requestChannelClose" },
  { RequestMessage_multiplexEntrySend, "multiplexEntrySend" },
  { RequestMessage_requestMultiplexEntry, "requestMultiplexEntry" },
  { RequestMessage_requestMode, "requestMode" },
  { RequestMessage_roundTripDelayRequest, "roundTripDelayRequest" },
  { RequestMessage_maintenanceLoopRequest, "maintenanceLoopRequest" },
  { RequestMessage_communicationModeRequest, "communicationModeRequest" },
  { RequestMessage_conferenceRequest, "conferenceRequest" },
  { RequestMessage_multilinkRequest, "multilinkRequest" },
  { RequestMessage_logicalChannelRateRequest, "logicalChannelRateRequest" },
  { RequestMessage_genericRequest, "genericRequest" },
  { 0, NULL }
};
/* To put the codec type only in COL_INFO when
   an OLC is read */
const char* codec_type = NULL;
static guint32 rfc_number;

typedef struct _unicast_addr_t {
  address addr;
  guint8 addr_buf[16];
  guint32 port;
} unicast_addr_t;

typedef struct _channel_info_t {
  gchar data_type_str[32];
  unicast_addr_t *upcoming_addr;
  unicast_addr_t media_addr;
  unicast_addr_t media_control_addr;
  unsigned int rfc2198;
  gboolean srtp_flag;
  gboolean is_video;
} channel_info_t;

typedef struct _olc_info_t {
  guint16 fwd_lc_num;
  channel_info_t fwd_lc;
  channel_info_t rev_lc;
} olc_info_t;

static GHashTable* h245_pending_olc_reqs = NULL;
static gboolean fast_start = FALSE;
static olc_info_t *upcoming_olc = NULL;
static channel_info_t *upcoming_channel = NULL;

/* NonStandardParameter */
static const char *nsiOID;
static guint32 h221NonStandard;
static guint32 t35CountryCode;
static guint32 t35Extension;
static guint32 manufacturerCode;

static const value_string h245_RFC_number_vals[] = {
	{  2190,	"RFC 2190 - H.263 Video Streams" },
	{  2198,	"RFC 2198 - RTP Payload for Redundant Audio Data" },
	{  2429,	"RFC 2429 - 1998 Version of ITU-T Rec. H.263 Video (H.263+)" },
	{  3016,	"RFC 3016 - RTP Payload Format for MPEG-4 Audio/Visual Streams" },
	{  3267,	"RFC 3267 - Adaptive Multi-Rate (AMR) and Adaptive Multi-Rate Wideband (AMR-WB)" },
	{  3984,	"RFC 3984 - RTP Payload Format for H.264 Video" },
	{  0, NULL }
};

/* Table 7/H.239 subMessageIdentifier values */
static const value_string h245_h239subMessageIdentifier_vals[] = {
  {   1, "flowControlReleaseRequest" },
  {   2, "flowControlReleaseResponse" },
  {   3, "presentationTokenRequest" },
  {   4, "presentationTokenResponse" },
  {   5, "presentationTokenRelease" },
  {   6, "presentationTokenIndicateOwner" },
  { 0, NULL }
};


/* h223 multiplex codes */
static h223_set_mc_handle_t h223_set_mc_handle = NULL;
h223_mux_element *h223_me=NULL;
guint8 h223_mc=0;
void h245_set_h223_set_mc_handle( h223_set_mc_handle_t handle )
{
	h223_set_mc_handle = handle;
}

/* h223 logical channels */
typedef struct {
	h223_lc_params *fw_channel_params;
	h223_lc_params *rev_channel_params;
} h223_pending_olc;

static GHashTable*          h223_pending_olc_reqs[] = { NULL, NULL };
static dissector_handle_t   h245_lc_dissector;
static guint16              h245_lc_temp;
static guint16              h223_fw_lc_num;
static guint16              h223_rev_lc_num;
static h223_lc_params      *h223_lc_params_temp;
static h223_lc_params      *h223_fw_lc_params;
static h223_lc_params      *h223_rev_lc_params;
static h223_add_lc_handle_t h223_add_lc_handle = NULL;
//static void h223_lc_init_dir( int dir )
//{
//	if ( h223_pending_olc_reqs[dir] )
//		//g_hash_table_destroy( h223_pending_olc_reqs[dir] );
//	//h223_pending_olc_reqs[dir] = g_hash_table_new( g_direct_hash, g_direct_equal );
//}

//static void h223_lc_init( void )
//{
//	h223_lc_init_dir( P2P_DIR_SENT );
//	h223_lc_init_dir( P2P_DIR_RECV );
//	h223_lc_params_temp = NULL;
//	h245_lc_dissector = NULL;
//	h223_fw_lc_num = 0;
//}

//static void h245_init(void)
//{
//	if ( h245_pending_olc_reqs)
//		//g_hash_table_destroy(h245_pending_olc_reqs);
//	//h245_pending_olc_reqs = g_hash_table_new(g_str_hash, g_str_equal);
//
//	//h223_lc_init();
//}

void h245_set_h223_add_lc_handle( h223_add_lc_handle_t handle )
{
	h223_add_lc_handle = handle;
}

//static const gchar *gen_olc_key(guint16 lc_num, address *dst_addr, address *src_addr)
//{
//  return ep_strdup_printf("%s/%s/%u", ep_address_to_str(dst_addr), ep_address_to_str(src_addr), lc_num);
//}

static void update_unicast_addr(unicast_addr_t *req_addr, unicast_addr_t *ack_addr)
{
  if (ack_addr->addr.type!=AT_NONE && ack_addr->port!=0) {
    memcpy(req_addr->addr_buf, ack_addr->addr_buf, sizeof(req_addr->addr_buf));
    SET_ADDRESS(&req_addr->addr, ack_addr->addr.type, ack_addr->addr.len, req_addr->addr_buf);
    req_addr->port = ack_addr->port;
  }
}

//static void h245_setup_channels(packet_info *pinfo, channel_info_t *upcoming_channel_lcl)
//{
//	gint *key;
//	GHashTable *rtp_dyn_payload = NULL;
//	struct srtp_info *dummy_srtp_info = NULL;
//
//	if (!upcoming_channel_lcl) return;
//
//	/* T.38 */
//	if (!strcmp(upcoming_channel_lcl->data_type_str, "t38fax")) {
//		if (upcoming_channel_lcl->media_addr.addr.type!=AT_NONE && upcoming_channel_lcl->media_addr.port!=0 && t38_handle) {
//			t38_add_address(pinfo, &upcoming_channel_lcl->media_addr.addr,
//							upcoming_channel_lcl->media_addr.port, 0,
//							"H245", pinfo->fd->num);
//		}
//		return;
//	}
//
//	/* (S)RTP, (S)RTCP */
//	if (upcoming_channel_lcl->rfc2198 > 0) {
//		encoding_name_and_rate_t *encoding_name_and_rate = se_alloc( sizeof(encoding_name_and_rate_t));
//		rtp_dyn_payload = g_hash_table_new(g_int_hash, g_int_equal);
//		encoding_name_and_rate->encoding_name = se_strdup("red");
//		encoding_name_and_rate->sample_rate = 8000;
//		key = se_alloc(sizeof(gint));
//		*key = upcoming_channel_lcl->rfc2198;
//		g_hash_table_insert(rtp_dyn_payload, key, encoding_name_and_rate);
//	}
//
//	if (upcoming_channel_lcl->srtp_flag) {
//		dummy_srtp_info = se_alloc0(sizeof(struct srtp_info));
//	}
//
//	/* DEBUG 	g_warning("h245_setup_channels media_addr.addr.type %u port %u",upcoming_channel_lcl->media_addr.addr.type, upcoming_channel_lcl->media_addr.port );
//	*/
//	if (upcoming_channel_lcl->media_addr.addr.type!=AT_NONE && upcoming_channel_lcl->media_addr.port!=0 && rtp_handle) {
//		srtp_add_address(pinfo, &upcoming_channel_lcl->media_addr.addr,
//						upcoming_channel_lcl->media_addr.port, 0,
//						"H245", pinfo->fd->num, upcoming_channel_lcl->is_video , rtp_dyn_payload, dummy_srtp_info);
//	}
//	if (upcoming_channel_lcl->media_control_addr.addr.type!=AT_NONE && upcoming_channel_lcl->media_control_addr.port!=0 && rtcp_handle) {
//		srtcp_add_address(pinfo, &upcoming_channel_lcl->media_control_addr.addr,
//						upcoming_channel_lcl->media_control_addr.port, 0,
//						"H245", pinfo->fd->num, dummy_srtp_info);
//	}
//}

/* Initialize the protocol and registered fields */
static int proto_h245 = -1;

/*--- Included file: packet-h245-hf.c ---*/
//#line 1 "../../asn1/h245/packet-h245-hf.c"
static int hf_h245_OpenLogicalChannel_PDU = -1;   /* OpenLogicalChannel */
static int hf_h245_request = -1;                  /* RequestMessage */
static int hf_h245_response = -1;                 /* ResponseMessage */
static int hf_h245_command = -1;                  /* CommandMessage */
static int hf_h245_indication = -1;               /* IndicationMessage */
static int hf_h245_nonStandardMsg = -1;           /* NonStandardMessage */
static int hf_h245_masterSlaveDetermination = -1;  /* MasterSlaveDetermination */
static int hf_h245_terminalCapabilitySet = -1;    /* TerminalCapabilitySet */
static int hf_h245_openLogicalChannel = -1;       /* OpenLogicalChannel */
static int hf_h245_closeLogicalChannel = -1;      /* CloseLogicalChannel */
static int hf_h245_requestChannelClose = -1;      /* RequestChannelClose */
static int hf_h245_multiplexEntrySend = -1;       /* MultiplexEntrySend */
static int hf_h245_requestMultiplexEntry = -1;    /* RequestMultiplexEntry */
static int hf_h245_requestMode = -1;              /* RequestMode */
static int hf_h245_roundTripDelayRequest = -1;    /* RoundTripDelayRequest */
static int hf_h245_maintenanceLoopRequest = -1;   /* MaintenanceLoopRequest */
static int hf_h245_communicationModeRequest = -1;  /* CommunicationModeRequest */
static int hf_h245_conferenceRequest = -1;        /* ConferenceRequest */
static int hf_h245_multilinkRequest = -1;         /* MultilinkRequest */
static int hf_h245_logicalChannelRateRequest = -1;  /* LogicalChannelRateRequest */
static int hf_h245_genericRequest = -1;           /* GenericMessage */
static int hf_h245_masterSlaveDeterminationAck = -1;  /* MasterSlaveDeterminationAck */
static int hf_h245_masterSlaveDeterminationReject = -1;  /* MasterSlaveDeterminationReject */
static int hf_h245_terminalCapabilitySetAck = -1;  /* TerminalCapabilitySetAck */
static int hf_h245_terminalCapabilitySetReject = -1;  /* TerminalCapabilitySetReject */
static int hf_h245_openLogicalChannelAck = -1;    /* OpenLogicalChannelAck */
static int hf_h245_openLogicalChannelReject = -1;  /* OpenLogicalChannelReject */
static int hf_h245_closeLogicalChannelAck = -1;   /* CloseLogicalChannelAck */
static int hf_h245_requestChannelCloseAck = -1;   /* RequestChannelCloseAck */
static int hf_h245_requestChannelCloseReject = -1;  /* RequestChannelCloseReject */
static int hf_h245_multiplexEntrySendAck = -1;    /* MultiplexEntrySendAck */
static int hf_h245_multiplexEntrySendReject = -1;  /* MultiplexEntrySendReject */
static int hf_h245_requestMultiplexEntryAck = -1;  /* RequestMultiplexEntryAck */
static int hf_h245_requestMultiplexEntryReject = -1;  /* RequestMultiplexEntryReject */
static int hf_h245_requestModeAck = -1;           /* RequestModeAck */
static int hf_h245_requestModeReject = -1;        /* RequestModeReject */
static int hf_h245_roundTripDelayResponse = -1;   /* RoundTripDelayResponse */
static int hf_h245_maintenanceLoopAck = -1;       /* MaintenanceLoopAck */
static int hf_h245_maintenanceLoopReject = -1;    /* MaintenanceLoopReject */
static int hf_h245_communicationModeResponse = -1;  /* CommunicationModeResponse */
static int hf_h245_conferenceResponse = -1;       /* ConferenceResponse */
static int hf_h245_multilinkResponse = -1;        /* MultilinkResponse */
static int hf_h245_logicalChannelRateAcknowledge = -1;  /* LogicalChannelRateAcknowledge */
static int hf_h245_logicalChannelRateReject = -1;  /* LogicalChannelRateReject */
static int hf_h245_genericResponse = -1;          /* GenericMessage */
static int hf_h245_maintenanceLoopOffCommand = -1;  /* MaintenanceLoopOffCommand */
static int hf_h245_sendTerminalCapabilitySet = -1;  /* SendTerminalCapabilitySet */
static int hf_h245_encryptionCommand = -1;        /* EncryptionCommand */
static int hf_h245_flowControlCommand = -1;       /* FlowControlCommand */
static int hf_h245_endSessionCommand = -1;        /* EndSessionCommand */
static int hf_h245_miscellaneousCommand = -1;     /* MiscellaneousCommand */
static int hf_h245_communicationModeCommand = -1;  /* CommunicationModeCommand */
static int hf_h245_conferenceCommand = -1;        /* ConferenceCommand */
static int hf_h245_h223MultiplexReconfiguration = -1;  /* H223MultiplexReconfiguration */
static int hf_h245_newATMVCCommand = -1;          /* NewATMVCCommand */
static int hf_h245_mobileMultilinkReconfigurationCommand = -1;  /* MobileMultilinkReconfigurationCommand */
static int hf_h245_genericCommand = -1;           /* GenericMessage */
static int hf_h245_functionNotUnderstood = -1;    /* FunctionNotUnderstood */
static int hf_h245_masterSlaveDeterminationRelease = -1;  /* MasterSlaveDeterminationRelease */
static int hf_h245_terminalCapabilitySetRelease = -1;  /* TerminalCapabilitySetRelease */
static int hf_h245_openLogicalChannelConfirm = -1;  /* OpenLogicalChannelConfirm */
static int hf_h245_requestChannelCloseRelease = -1;  /* RequestChannelCloseRelease */
static int hf_h245_multiplexEntrySendRelease = -1;  /* MultiplexEntrySendRelease */
static int hf_h245_requestMultiplexEntryRelease = -1;  /* RequestMultiplexEntryRelease */
static int hf_h245_requestModeRelease = -1;       /* RequestModeRelease */
static int hf_h245_miscellaneousIndication = -1;  /* MiscellaneousIndication */
static int hf_h245_jitterIndication = -1;         /* JitterIndication */
static int hf_h245_h223SkewIndication = -1;       /* H223SkewIndication */
static int hf_h245_newATMVCIndication = -1;       /* NewATMVCIndication */
static int hf_h245_userInput = -1;                /* UserInputIndication */
static int hf_h245_h2250MaximumSkewIndication = -1;  /* H2250MaximumSkewIndication */
static int hf_h245_mcLocationIndication = -1;     /* MCLocationIndication */
static int hf_h245_conferenceIndication = -1;     /* ConferenceIndication */
static int hf_h245_vendorIdentification = -1;     /* VendorIdentification */
static int hf_h245_functionNotSupported = -1;     /* FunctionNotSupported */
static int hf_h245_multilinkIndication = -1;      /* MultilinkIndication */
static int hf_h245_logicalChannelRateRelease = -1;  /* LogicalChannelRateRelease */
static int hf_h245_flowControlIndication = -1;    /* FlowControlIndication */
static int hf_h245_mobileMultilinkReconfigurationIndication = -1;  /* MobileMultilinkReconfigurationIndication */
static int hf_h245_genericIndication = -1;        /* GenericMessage */
static int hf_h245_messageIdentifier = -1;        /* CapabilityIdentifier */
static int hf_h245_subMessageIdentifier = -1;     /* T_subMessageIdentifier */
static int hf_h245_messageContent = -1;           /* T_messageContent */
static int hf_h245_messageContent_item = -1;      /* T_messageContent_item */
static int hf_h245_nonStandardData = -1;          /* NonStandardParameter */
static int hf_h245_nonStandardIdentifier = -1;    /* NonStandardIdentifier */
static int hf_h245_nsd_data = -1;                 /* T_nsd_data */
static int hf_h245_object = -1;                   /* T_object */
static int hf_h245_h221NonStandardID = -1;        /* H221NonStandardID */
static int hf_h245_t35CountryCode = -1;           /* T_t35CountryCode */
static int hf_h245_t35Extension = -1;             /* T_t35Extension */
static int hf_h245_manufacturerCode = -1;         /* T_manufacturerCode */
static int hf_h245_terminalType = -1;             /* INTEGER_0_255 */
static int hf_h245_statusDeterminationNumber = -1;  /* INTEGER_0_16777215 */
static int hf_h245_decision = -1;                 /* T_decision */
static int hf_h245_master = -1;                   /* NULL */
static int hf_h245_slave = -1;                    /* NULL */
static int hf_h245_msd_rej_cause = -1;            /* MasterSlaveDeterminationRejectCause */
static int hf_h245_identicalNumbers = -1;         /* NULL */
static int hf_h245_sequenceNumber = -1;           /* SequenceNumber */
static int hf_h245_protocolIdentifier = -1;       /* OBJECT_IDENTIFIER */
static int hf_h245_multiplexCapability = -1;      /* MultiplexCapability */
static int hf_h245_capabilityTable = -1;          /* SET_SIZE_1_256_OF_CapabilityTableEntry */
static int hf_h245_capabilityTable_item = -1;     /* CapabilityTableEntry */
static int hf_h245_capabilityDescriptors = -1;    /* SET_SIZE_1_256_OF_CapabilityDescriptor */
static int hf_h245_capabilityDescriptors_item = -1;  /* CapabilityDescriptor */
static int hf_h245_genericInformation = -1;       /* SEQUENCE_OF_GenericInformation */
static int hf_h245_genericInformation_item = -1;  /* GenericInformation */
static int hf_h245_capabilityTableEntryNumber = -1;  /* CapabilityTableEntryNumber */
static int hf_h245_capability = -1;               /* Capability */
static int hf_h245_capabilityDescriptorNumber = -1;  /* CapabilityDescriptorNumber */
static int hf_h245_simultaneousCapabilities = -1;  /* SET_SIZE_1_256_OF_AlternativeCapabilitySet */
static int hf_h245_simultaneousCapabilities_item = -1;  /* AlternativeCapabilitySet */
static int hf_h245_AlternativeCapabilitySet_item = -1;  /* CapabilityTableEntryNumber */
static int hf_h245_tcs_rej_cause = -1;            /* TerminalCapabilitySetRejectCause */
static int hf_h245_unspecified = -1;              /* NULL */
static int hf_h245_undefinedTableEntryUsed = -1;  /* NULL */
static int hf_h245_descriptorCapacityExceeded = -1;  /* NULL */
static int hf_h245_tableEntryCapacityExceeded = -1;  /* T_tableEntryCapacityExceeded */
static int hf_h245_highestEntryNumberProcessed = -1;  /* CapabilityTableEntryNumber */
static int hf_h245_noneProcessed = -1;            /* NULL */
static int hf_h245_nonStandard = -1;              /* NonStandardParameter */
static int hf_h245_receiveVideoCapability = -1;   /* VideoCapability */
static int hf_h245_transmitVideoCapability = -1;  /* VideoCapability */
static int hf_h245_receiveAndTransmitVideoCapability = -1;  /* VideoCapability */
static int hf_h245_receiveAudioCapability = -1;   /* AudioCapability */
static int hf_h245_transmitAudioCapability = -1;  /* AudioCapability */
static int hf_h245_receiveAndTransmitAudioCapability = -1;  /* AudioCapability */
static int hf_h245_receiveDataApplicationCapability = -1;  /* DataApplicationCapability */
static int hf_h245_transmitDataApplicationCapability = -1;  /* DataApplicationCapability */
static int hf_h245_receiveAndTransmitDataApplicationCapability = -1;  /* DataApplicationCapability */
static int hf_h245_h233EncryptionTransmitCapability = -1;  /* BOOLEAN */
static int hf_h245_h233EncryptionReceiveCapability = -1;  /* T_h233EncryptionReceiveCapability */
static int hf_h245_h233IVResponseTime = -1;       /* INTEGER_0_255 */
static int hf_h245_conferenceCapability = -1;     /* ConferenceCapability */
static int hf_h245_h235SecurityCapability = -1;   /* H235SecurityCapability */
static int hf_h245_maxPendingReplacementFor = -1;  /* INTEGER_0_255 */
static int hf_h245_receiveUserInputCapability = -1;  /* UserInputCapability */
static int hf_h245_transmitUserInputCapability = -1;  /* UserInputCapability */
static int hf_h245_receiveAndTransmitUserInputCapability = -1;  /* UserInputCapability */
static int hf_h245_genericControlCapability = -1;  /* GenericCapability */
static int hf_h245_receiveMultiplexedStreamCapability = -1;  /* MultiplexedStreamCapability */
static int hf_h245_transmitMultiplexedStreamCapability = -1;  /* MultiplexedStreamCapability */
static int hf_h245_receiveAndTransmitMultiplexedStreamCapability = -1;  /* MultiplexedStreamCapability */
static int hf_h245_receiveRTPAudioTelephonyEventCapability = -1;  /* AudioTelephonyEventCapability */
static int hf_h245_receiveRTPAudioToneCapability = -1;  /* AudioToneCapability */
static int hf_h245_depFecCapability = -1;         /* DepFECCapability */
static int hf_h245_multiplePayloadStreamCapability = -1;  /* MultiplePayloadStreamCapability */
static int hf_h245_fecCapability = -1;            /* FECCapability */
static int hf_h245_redundancyEncodingCap = -1;    /* RedundancyEncodingCapability */
static int hf_h245_oneOfCapabilities = -1;        /* AlternativeCapabilitySet */
static int hf_h245_encryptionAuthenticationAndIntegrity = -1;  /* EncryptionAuthenticationAndIntegrity */
static int hf_h245_mediaCapability = -1;          /* CapabilityTableEntryNumber */
static int hf_h245_h222Capability = -1;           /* H222Capability */
static int hf_h245_h223Capability = -1;           /* H223Capability */
static int hf_h245_v76Capability = -1;            /* V76Capability */
static int hf_h245_h2250Capability = -1;          /* H2250Capability */
static int hf_h245_genericMultiplexCapability = -1;  /* GenericCapability */
static int hf_h245_numberOfVCs = -1;              /* INTEGER_1_256 */
static int hf_h245_vcCapability = -1;             /* SET_OF_VCCapability */
static int hf_h245_vcCapability_item = -1;        /* VCCapability */
static int hf_h245_aal1 = -1;                     /* T_aal1 */
static int hf_h245_nullClockRecovery = -1;        /* BOOLEAN */
static int hf_h245_srtsClockRecovery_bool = -1;   /* BOOLEAN */
static int hf_h245_adaptiveClockRecovery = -1;    /* BOOLEAN */
static int hf_h245_nullErrorCorrection = -1;      /* BOOLEAN */
static int hf_h245_longInterleaver = -1;          /* BOOLEAN */
static int hf_h245_shortInterleaver = -1;         /* BOOLEAN */
static int hf_h245_errorCorrectionOnly = -1;      /* BOOLEAN */
static int hf_h245_structuredDataTransfer = -1;   /* BOOLEAN */
static int hf_h245_partiallyFilledCells = -1;     /* BOOLEAN */
static int hf_h245_aal5 = -1;                     /* T_aal5 */
static int hf_h245_forwardMaximumSDUSize = -1;    /* INTEGER_0_65535 */
static int hf_h245_backwardMaximumSDUSize = -1;   /* INTEGER_0_65535 */
static int hf_h245_transportStream_bool = -1;     /* BOOLEAN */
static int hf_h245_programStream = -1;            /* BOOLEAN */
static int hf_h245_availableBitRates = -1;        /* T_availableBitRates */
static int hf_h245_avb_type = -1;                 /* Avb_type */
static int hf_h245_singleBitRate = -1;            /* INTEGER_1_65535 */
static int hf_h245_rangeOfBitRates = -1;          /* T_rangeOfBitRates */
static int hf_h245_lowerBitRate = -1;             /* INTEGER_1_65535 */
static int hf_h245_higherBitRate = -1;            /* INTEGER_1_65535 */
static int hf_h245_aal1ViaGateway = -1;           /* T_aal1ViaGateway */
static int hf_h245_gatewayAddress = -1;           /* SET_SIZE_1_256_OF_Q2931Address */
static int hf_h245_gatewayAddress_item = -1;      /* Q2931Address */
static int hf_h245_srtsClockRecoveryflag = -1;    /* BOOLEAN */
static int hf_h245_transportWithI_frames = -1;    /* BOOLEAN */
static int hf_h245_videoWithAL1 = -1;             /* BOOLEAN */
static int hf_h245_videoWithAL2 = -1;             /* BOOLEAN */
static int hf_h245_videoWithAL3 = -1;             /* BOOLEAN */
static int hf_h245_audioWithAL1 = -1;             /* BOOLEAN */
static int hf_h245_audioWithAL2 = -1;             /* BOOLEAN */
static int hf_h245_audioWithAL3 = -1;             /* BOOLEAN */
static int hf_h245_dataWithAL1 = -1;              /* BOOLEAN */
static int hf_h245_dataWithAL2 = -1;              /* BOOLEAN */
static int hf_h245_dataWithAL3 = -1;              /* BOOLEAN */
static int hf_h245_maximumAl2SDUSize = -1;        /* INTEGER_0_65535 */
static int hf_h245_maximumAl3SDUSize = -1;        /* INTEGER_0_65535 */
static int hf_h245_maximumDelayJitter = -1;       /* INTEGER_0_1023 */
static int hf_h245_h223MultiplexTableCapability = -1;  /* T_h223MultiplexTableCapability */
static int hf_h245_basic = -1;                    /* NULL */
static int hf_h245_enhanced = -1;                 /* T_enhanced */
static int hf_h245_maximumNestingDepth = -1;      /* INTEGER_1_15 */
static int hf_h245_maximumElementListSize = -1;   /* INTEGER_2_255 */
static int hf_h245_maximumSubElementListSize = -1;  /* INTEGER_2_255 */
static int hf_h245_maxMUXPDUSizeCapability = -1;  /* BOOLEAN */
static int hf_h245_nsrpSupport = -1;              /* BOOLEAN */
static int hf_h245_mobileOperationTransmitCapability = -1;  /* T_mobileOperationTransmitCapability */
static int hf_h245_modeChangeCapability = -1;     /* BOOLEAN */
static int hf_h245_h223AnnexA = -1;               /* BOOLEAN */
static int hf_h245_h223AnnexADoubleFlagFlag = -1;  /* BOOLEAN */
static int hf_h245_h223AnnexB = -1;               /* BOOLEAN */
static int hf_h245_h223AnnexBwithHeader = -1;     /* BOOLEAN */
static int hf_h245_h223AnnexCCapability = -1;     /* H223AnnexCCapability */
static int hf_h245_bitRate_1_19200 = -1;          /* INTEGER_1_19200 */
static int hf_h245_mobileMultilinkFrameCapability = -1;  /* T_mobileMultilinkFrameCapability */
static int hf_h245_maximumSampleSize = -1;        /* INTEGER_1_255 */
static int hf_h245_maximumPayloadLength = -1;     /* INTEGER_1_65025 */
static int hf_h245_videoWithAL1M = -1;            /* BOOLEAN */
static int hf_h245_videoWithAL2M = -1;            /* BOOLEAN */
static int hf_h245_videoWithAL3M = -1;            /* BOOLEAN */
static int hf_h245_audioWithAL1M = -1;            /* BOOLEAN */
static int hf_h245_audioWithAL2M = -1;            /* BOOLEAN */
static int hf_h245_audioWithAL3M = -1;            /* BOOLEAN */
static int hf_h245_dataWithAL1M = -1;             /* BOOLEAN */
static int hf_h245_dataWithAL2M = -1;             /* BOOLEAN */
static int hf_h245_dataWithAL3M = -1;             /* BOOLEAN */
static int hf_h245_alpduInterleaving = -1;        /* BOOLEAN */
static int hf_h245_maximumAL1MPDUSize = -1;       /* INTEGER_0_65535 */
static int hf_h245_maximumAL2MSDUSize = -1;       /* INTEGER_0_65535 */
static int hf_h245_maximumAL3MSDUSize = -1;       /* INTEGER_0_65535 */
static int hf_h245_rsCodeCapability = -1;         /* BOOLEAN */
static int hf_h245_suspendResumeCapabilitywAddress = -1;  /* BOOLEAN */
static int hf_h245_suspendResumeCapabilitywoAddress = -1;  /* BOOLEAN */
static int hf_h245_rejCapability = -1;            /* BOOLEAN */
static int hf_h245_sREJCapability = -1;           /* BOOLEAN */
static int hf_h245_mREJCapability = -1;           /* BOOLEAN */
static int hf_h245_crc8bitCapability = -1;        /* BOOLEAN */
static int hf_h245_crc16bitCapability = -1;       /* BOOLEAN */
static int hf_h245_crc32bitCapability = -1;       /* BOOLEAN */
static int hf_h245_uihCapability = -1;            /* BOOLEAN */
static int hf_h245_numOfDLCS = -1;                /* INTEGER_2_8191 */
static int hf_h245_twoOctetAddressFieldCapability = -1;  /* BOOLEAN */
static int hf_h245_loopBackTestCapability = -1;   /* BOOLEAN */
static int hf_h245_n401Capability = -1;           /* INTEGER_1_4095 */
static int hf_h245_maxWindowSizeCapability = -1;  /* INTEGER_1_127 */
static int hf_h245_v75Capability = -1;            /* V75Capability */
static int hf_h245_audioHeader = -1;              /* BOOLEAN */
static int hf_h245_maximumAudioDelayJitter = -1;  /* INTEGER_0_1023 */
static int hf_h245_receiveMultipointCapability = -1;  /* MultipointCapability */
static int hf_h245_transmitMultipointCapability = -1;  /* MultipointCapability */
static int hf_h245_receiveAndTransmitMultipointCapability = -1;  /* MultipointCapability */
static int hf_h245_mcCapability = -1;             /* T_mcCapability */
static int hf_h245_centralizedConferenceMC = -1;  /* BOOLEAN */
static int hf_h245_decentralizedConferenceMC = -1;  /* BOOLEAN */
static int hf_h245_rtcpVideoControlCapability = -1;  /* BOOLEAN */
static int hf_h245_mediaPacketizationCapability = -1;  /* MediaPacketizationCapability */
static int hf_h245_transportCapability = -1;      /* TransportCapability */
static int hf_h245_redundancyEncodingCapability = -1;  /* SEQUENCE_SIZE_1_256_OF_RedundancyEncodingCapability */
static int hf_h245_redundancyEncodingCapability_item = -1;  /* RedundancyEncodingCapability */
static int hf_h245_logicalChannelSwitchingCapability = -1;  /* BOOLEAN */
static int hf_h245_t120DynamicPortCapability = -1;  /* BOOLEAN */
static int hf_h245_h261aVideoPacketization = -1;  /* BOOLEAN */
static int hf_h245_rtpPayloadTypes = -1;          /* SEQUENCE_SIZE_1_256_OF_RTPPayloadType */
static int hf_h245_rtpPayloadTypes_item = -1;     /* RTPPayloadType */
static int hf_h245_qosMode = -1;                  /* QOSMode */
static int hf_h245_tokenRate = -1;                /* INTEGER_1_4294967295 */
static int hf_h245_bucketSize = -1;               /* INTEGER_1_4294967295 */
static int hf_h245_peakRate = -1;                 /* INTEGER_1_4294967295 */
static int hf_h245_minPoliced = -1;               /* INTEGER_1_4294967295 */
static int hf_h245_maxPktSize = -1;               /* INTEGER_1_4294967295 */
static int hf_h245_guaranteedQOS = -1;            /* NULL */
static int hf_h245_controlledLoad = -1;           /* NULL */
static int hf_h245_maxNTUSize = -1;               /* INTEGER_0_65535 */
static int hf_h245_atmUBR = -1;                   /* BOOLEAN */
static int hf_h245_atmrtVBR = -1;                 /* BOOLEAN */
static int hf_h245_atmnrtVBR = -1;                /* BOOLEAN */
static int hf_h245_atmABR = -1;                   /* BOOLEAN */
static int hf_h245_atmCBR = -1;                   /* BOOLEAN */
static int hf_h245_nonStandardParameter = -1;     /* NonStandardParameter */
static int hf_h245_value = -1;                    /* INTEGER_0_255 */
static int hf_h245_servicePrioritySignalled = -1;  /* BOOLEAN */
static int hf_h245_servicePriorityValue = -1;     /* ServicePriorityValue */
static int hf_h245_serviceClass = -1;             /* INTEGER_0_4095 */
static int hf_h245_serviceSubclass = -1;          /* INTEGER_0_255 */
static int hf_h245_desired = -1;                  /* NULL */
static int hf_h245_required = -1;                 /* NULL */
static int hf_h245_class0 = -1;                   /* NULL */
static int hf_h245_class1 = -1;                   /* NULL */
static int hf_h245_class2 = -1;                   /* NULL */
static int hf_h245_class3 = -1;                   /* NULL */
static int hf_h245_class4 = -1;                   /* NULL */
static int hf_h245_class5 = -1;                   /* NULL */
static int hf_h245_qosType = -1;                  /* QOSType */
static int hf_h245_qosClass = -1;                 /* QOSClass */
static int hf_h245_averageRate = -1;              /* INTEGER_1_4294967295 */
static int hf_h245_burst = -1;                    /* INTEGER_1_4294967295 */
static int hf_h245_rsvpParameters = -1;           /* RSVPParameters */
static int hf_h245_atmParameters = -1;            /* ATMParameters */
static int hf_h245_localQoS = -1;                 /* BOOLEAN */
static int hf_h245_genericTransportParameters = -1;  /* GenericTransportParameters */
static int hf_h245_servicePriority = -1;          /* ServicePriority */
static int hf_h245_authorizationParameter = -1;   /* AuthorizationParameters */
static int hf_h245_qosDescriptor = -1;            /* QOSDescriptor */
static int hf_h245_dscpValue = -1;                /* INTEGER_0_63 */
static int hf_h245_ip_UDP = -1;                   /* NULL */
static int hf_h245_ip_TCP = -1;                   /* NULL */
static int hf_h245_atm_AAL5_UNIDIR = -1;          /* NULL */
static int hf_h245_atm_AAL5_BIDIR = -1;           /* NULL */
static int hf_h245_atm_AAL5_compressed = -1;      /* T_atm_AAL5_compressed */
static int hf_h245_variable_delta = -1;           /* BOOLEAN */
static int hf_h245_mediaTransport = -1;           /* MediaTransportType */
static int hf_h245_qOSCapabilities = -1;          /* SEQUENCE_SIZE_1_256_OF_QOSCapability */
static int hf_h245_qOSCapabilities_item = -1;     /* QOSCapability */
static int hf_h245_mediaChannelCapabilities = -1;  /* SEQUENCE_SIZE_1_256_OF_MediaChannelCapability */
static int hf_h245_mediaChannelCapabilities_item = -1;  /* MediaChannelCapability */
static int hf_h245_redundancyEncodingMethod = -1;  /* RedundancyEncodingMethod */
static int hf_h245_primaryEncoding = -1;          /* CapabilityTableEntryNumber */
static int hf_h245_secondaryEncodingCapability = -1;  /* SEQUENCE_SIZE_1_256_OF_CapabilityTableEntryNumber */
static int hf_h245_secondaryEncodingCapability_item = -1;  /* CapabilityTableEntryNumber */
static int hf_h245_rtpAudioRedundancyEncoding = -1;  /* NULL */
static int hf_h245_rtpH263VideoRedundancyEncoding = -1;  /* RTPH263VideoRedundancyEncoding */
static int hf_h245_numberOfThreads = -1;          /* INTEGER_1_16 */
static int hf_h245_framesBetweenSyncPoints = -1;  /* INTEGER_1_256 */
static int hf_h245_frameToThreadMapping = -1;     /* T_frameToThreadMapping */
static int hf_h245_roundrobin = -1;               /* NULL */
static int hf_h245_custom = -1;                   /* SEQUENCE_SIZE_1_256_OF_RTPH263VideoRedundancyFrameMapping */
static int hf_h245_custom_item = -1;              /* RTPH263VideoRedundancyFrameMapping */
static int hf_h245_containedThreads = -1;         /* T_containedThreads */
static int hf_h245_containedThreads_item = -1;    /* INTEGER_0_15 */
static int hf_h245_threadNumber = -1;             /* INTEGER_0_15 */
static int hf_h245_frameSequence = -1;            /* T_frameSequence */
static int hf_h245_frameSequence_item = -1;       /* INTEGER_0_255 */
static int hf_h245_multicastCapability = -1;      /* BOOLEAN */
static int hf_h245_multiUniCastConference = -1;   /* BOOLEAN */
static int hf_h245_mediaDistributionCapability = -1;  /* SEQUENCE_OF_MediaDistributionCapability */
static int hf_h245_mediaDistributionCapability_item = -1;  /* MediaDistributionCapability */
static int hf_h245_centralizedControl = -1;       /* BOOLEAN */
static int hf_h245_distributedControl = -1;       /* BOOLEAN */
static int hf_h245_centralizedAudio = -1;         /* BOOLEAN */
static int hf_h245_distributedAudio = -1;         /* BOOLEAN */
static int hf_h245_centralizedVideo = -1;         /* BOOLEAN */
static int hf_h245_distributedVideo = -1;         /* BOOLEAN */
static int hf_h245_centralizedData = -1;          /* SEQUENCE_OF_DataApplicationCapability */
static int hf_h245_centralizedData_item = -1;     /* DataApplicationCapability */
static int hf_h245_distributedData = -1;          /* SEQUENCE_OF_DataApplicationCapability */
static int hf_h245_distributedData_item = -1;     /* DataApplicationCapability */
static int hf_h245_h261VideoCapability = -1;      /* H261VideoCapability */
static int hf_h245_h262VideoCapability = -1;      /* H262VideoCapability */
static int hf_h245_h263VideoCapability = -1;      /* H263VideoCapability */
static int hf_h245_is11172VideoCapability = -1;   /* IS11172VideoCapability */
static int hf_h245_genericVideoCapability = -1;   /* GenericCapability */
static int hf_h245_extendedVideoCapability = -1;  /* ExtendedVideoCapability */
static int hf_h245_videoCapability = -1;          /* SEQUENCE_OF_VideoCapability */
static int hf_h245_videoCapability_item = -1;     /* VideoCapability */
static int hf_h245_videoCapabilityExtension = -1;  /* SEQUENCE_OF_GenericCapability */
static int hf_h245_videoCapabilityExtension_item = -1;  /* GenericCapability */
static int hf_h245_qcifMPI_1_4 = -1;              /* INTEGER_1_4 */
static int hf_h245_cifMPI_1_4 = -1;               /* INTEGER_1_4 */
static int hf_h245_temporalSpatialTradeOffCapability = -1;  /* BOOLEAN */
static int hf_h245_maxBitRate_1_19200 = -1;       /* INTEGER_1_19200 */
static int hf_h245_stillImageTransmission = -1;   /* BOOLEAN */
static int hf_h245_videoBadMBsCap = -1;           /* BOOLEAN */
static int hf_h245_profileAndLevel_SPatML = -1;   /* BOOLEAN */
static int hf_h245_profileAndLevel_MPatLL = -1;   /* BOOLEAN */
static int hf_h245_profileAndLevel_MPatML = -1;   /* BOOLEAN */
static int hf_h245_profileAndLevel_MPatH_14 = -1;  /* BOOLEAN */
static int hf_h245_profileAndLevel_MPatHL = -1;   /* BOOLEAN */
static int hf_h245_profileAndLevel_SNRatLL = -1;  /* BOOLEAN */
static int hf_h245_profileAndLevel_SNRatML = -1;  /* BOOLEAN */
static int hf_h245_profileAndLevel_SpatialatH_14 = -1;  /* BOOLEAN */
static int hf_h245_profileAndLevel_HPatML = -1;   /* BOOLEAN */
static int hf_h245_profileAndLevel_HPatH_14 = -1;  /* BOOLEAN */
static int hf_h245_profileAndLevel_HPatHL = -1;   /* BOOLEAN */
static int hf_h245_videoBitRate = -1;             /* INTEGER_0_1073741823 */
static int hf_h245_vbvBufferSize = -1;            /* INTEGER_0_262143 */
static int hf_h245_samplesPerLine = -1;           /* INTEGER_0_16383 */
static int hf_h245_linesPerFrame = -1;            /* INTEGER_0_16383 */
static int hf_h245_framesPerSecond = -1;          /* INTEGER_0_15 */
static int hf_h245_luminanceSampleRate = -1;      /* INTEGER_0_4294967295 */
static int hf_h245_sqcifMPI_1_32 = -1;            /* INTEGER_1_32 */
static int hf_h245_qcifMPI = -1;                  /* INTEGER_1_32 */
static int hf_h245_cifMPI = -1;                   /* INTEGER_1_32 */
static int hf_h245_cif4MPI_1_32 = -1;             /* INTEGER_1_32 */
static int hf_h245_cif16MPI_1_32 = -1;            /* INTEGER_1_32 */
static int hf_h245_maxBitRate = -1;               /* INTEGER_1_192400 */
static int hf_h245_unrestrictedVector = -1;       /* BOOLEAN */
static int hf_h245_arithmeticCoding = -1;         /* BOOLEAN */
static int hf_h245_advancedPrediction = -1;       /* BOOLEAN */
static int hf_h245_pbFrames = -1;                 /* BOOLEAN */
static int hf_h245_hrd_B = -1;                    /* INTEGER_0_524287 */
static int hf_h245_bppMaxKb = -1;                 /* INTEGER_0_65535 */
static int hf_h245_slowSqcifMPI = -1;             /* INTEGER_1_3600 */
static int hf_h245_slowQcifMPI = -1;              /* INTEGER_1_3600 */
static int hf_h245_slowCifMPI = -1;               /* INTEGER_1_3600 */
static int hf_h245_slowCif4MPI = -1;              /* INTEGER_1_3600 */
static int hf_h245_slowCif16MPI = -1;             /* INTEGER_1_3600 */
static int hf_h245_errorCompensation = -1;        /* BOOLEAN */
static int hf_h245_enhancementLayerInfo = -1;     /* EnhancementLayerInfo */
static int hf_h245_h263Options = -1;              /* H263Options */
static int hf_h245_baseBitRateConstrained = -1;   /* BOOLEAN */
static int hf_h245_snrEnhancement = -1;           /* SET_SIZE_1_14_OF_EnhancementOptions */
static int hf_h245_snrEnhancement_item = -1;      /* EnhancementOptions */
static int hf_h245_spatialEnhancement = -1;       /* SET_SIZE_1_14_OF_EnhancementOptions */
static int hf_h245_spatialEnhancement_item = -1;  /* EnhancementOptions */
static int hf_h245_bPictureEnhancement = -1;      /* SET_SIZE_1_14_OF_BEnhancementParameters */
static int hf_h245_bPictureEnhancement_item = -1;  /* BEnhancementParameters */
static int hf_h245_enhancementOptions = -1;       /* EnhancementOptions */
static int hf_h245_numberOfBPictures = -1;        /* INTEGER_1_64 */
static int hf_h245_advancedIntraCodingMode = -1;  /* BOOLEAN */
static int hf_h245_deblockingFilterMode = -1;     /* BOOLEAN */
static int hf_h245_improvedPBFramesMode = -1;     /* BOOLEAN */
static int hf_h245_unlimitedMotionVectors = -1;   /* BOOLEAN */
static int hf_h245_fullPictureFreeze = -1;        /* BOOLEAN */
static int hf_h245_partialPictureFreezeAndRelease = -1;  /* BOOLEAN */
static int hf_h245_resizingPartPicFreezeAndRelease = -1;  /* BOOLEAN */
static int hf_h245_fullPictureSnapshot = -1;      /* BOOLEAN */
static int hf_h245_partialPictureSnapshot = -1;   /* BOOLEAN */
static int hf_h245_videoSegmentTagging = -1;      /* BOOLEAN */
static int hf_h245_progressiveRefinement = -1;    /* BOOLEAN */
static int hf_h245_dynamicPictureResizingByFour = -1;  /* BOOLEAN */
static int hf_h245_dynamicPictureResizingSixteenthPel = -1;  /* BOOLEAN */
static int hf_h245_dynamicWarpingHalfPel = -1;    /* BOOLEAN */
static int hf_h245_dynamicWarpingSixteenthPel = -1;  /* BOOLEAN */
static int hf_h245_independentSegmentDecoding = -1;  /* BOOLEAN */
static int hf_h245_slicesInOrder_NonRect = -1;    /* BOOLEAN */
static int hf_h245_slicesInOrder_Rect = -1;       /* BOOLEAN */
static int hf_h245_slicesNoOrder_NonRect = -1;    /* BOOLEAN */
static int hf_h245_slicesNoOrder_Rect = -1;       /* BOOLEAN */
static int hf_h245_alternateInterVLCMode = -1;    /* BOOLEAN */
static int hf_h245_modifiedQuantizationMode = -1;  /* BOOLEAN */
static int hf_h245_reducedResolutionUpdate = -1;  /* BOOLEAN */
static int hf_h245_transparencyParameters = -1;   /* TransparencyParameters */
static int hf_h245_separateVideoBackChannel = -1;  /* BOOLEAN */
static int hf_h245_refPictureSelection = -1;      /* RefPictureSelection */
static int hf_h245_customPictureClockFrequency = -1;  /* SET_SIZE_1_16_OF_CustomPictureClockFrequency */
static int hf_h245_customPictureClockFrequency_item = -1;  /* CustomPictureClockFrequency */
static int hf_h245_customPictureFormat = -1;      /* SET_SIZE_1_16_OF_CustomPictureFormat */
static int hf_h245_customPictureFormat_item = -1;  /* CustomPictureFormat */
static int hf_h245_modeCombos = -1;               /* SET_SIZE_1_16_OF_H263VideoModeCombos */
static int hf_h245_modeCombos_item = -1;          /* H263VideoModeCombos */
static int hf_h245_h263Version3Options = -1;      /* H263Version3Options */
static int hf_h245_presentationOrder = -1;        /* INTEGER_1_256 */
static int hf_h245_offset_x = -1;                 /* INTEGER_M262144_262143 */
static int hf_h245_offset_y = -1;                 /* INTEGER_M262144_262143 */
static int hf_h245_scale_x = -1;                  /* INTEGER_1_255 */
static int hf_h245_scale_y = -1;                  /* INTEGER_1_255 */
static int hf_h245_additionalPictureMemory = -1;  /* T_additionalPictureMemory */
static int hf_h245_sqcifAdditionalPictureMemory = -1;  /* INTEGER_1_256 */
static int hf_h245_qcifAdditionalPictureMemory = -1;  /* INTEGER_1_256 */
static int hf_h245_cifAdditionalPictureMemory = -1;  /* INTEGER_1_256 */
static int hf_h245_cif4AdditionalPictureMemory = -1;  /* INTEGER_1_256 */
static int hf_h245_cif16AdditionalPictureMemory = -1;  /* INTEGER_1_256 */
static int hf_h245_bigCpfAdditionalPictureMemory = -1;  /* INTEGER_1_256 */
static int hf_h245_videoMux = -1;                 /* BOOLEAN */
static int hf_h245_videoBackChannelSend = -1;     /* T_videoBackChannelSend */
static int hf_h245_none = -1;                     /* NULL */
static int hf_h245_ackMessageOnly = -1;           /* NULL */
static int hf_h245_nackMessageOnly = -1;          /* NULL */
static int hf_h245_ackOrNackMessageOnly = -1;     /* NULL */
static int hf_h245_ackAndNackMessage = -1;        /* NULL */
static int hf_h245_enhancedReferencePicSelect = -1;  /* T_enhancedReferencePicSelect */
static int hf_h245_subPictureRemovalParameters = -1;  /* T_subPictureRemovalParameters */
static int hf_h245_mpuHorizMBs = -1;              /* INTEGER_1_128 */
static int hf_h245_mpuVertMBs = -1;               /* INTEGER_1_72 */
static int hf_h245_mpuTotalNumber = -1;           /* INTEGER_1_65536 */
static int hf_h245_clockConversionCode = -1;      /* INTEGER_1000_1001 */
static int hf_h245_clockDivisor = -1;             /* INTEGER_1_127 */
static int hf_h245_sqcifMPI = -1;                 /* INTEGER_1_2048 */
static int hf_h245_qcifMPI_1_2048 = -1;           /* INTEGER_1_2048 */
static int hf_h245_cifMPI2_1_2048 = -1;           /* INTEGER_1_2048 */
static int hf_h245_cif4MPI = -1;                  /* INTEGER_1_2048 */
static int hf_h245_cif16MPI = -1;                 /* INTEGER_1_2048 */
static int hf_h245_maxCustomPictureWidth = -1;    /* INTEGER_1_2048 */
static int hf_h245_maxCustomPictureHeight = -1;   /* INTEGER_1_2048 */
static int hf_h245_minCustomPictureWidth = -1;    /* INTEGER_1_2048 */
static int hf_h245_minCustomPictureHeight = -1;   /* INTEGER_1_2048 */
static int hf_h245_mPI = -1;                      /* T_mPI */
static int hf_h245_standardMPI = -1;              /* INTEGER_1_31 */
static int hf_h245_customPCF = -1;                /* T_customPCF */
static int hf_h245_customPCF_item = -1;           /* T_customPCF_item */
static int hf_h245_customMPI = -1;                /* INTEGER_1_2048 */
static int hf_h245_pixelAspectInformation = -1;   /* T_pixelAspectInformation */
static int hf_h245_anyPixelAspectRatio = -1;      /* BOOLEAN */
static int hf_h245_pixelAspectCode = -1;          /* T_pixelAspectCode */
static int hf_h245_pixelAspectCode_item = -1;     /* INTEGER_1_14 */
static int hf_h245_extendedPAR = -1;              /* T_extendedPAR */
static int hf_h245_extendedPAR_item = -1;         /* T_extendedPAR_item */
static int hf_h245_width = -1;                    /* INTEGER_1_255 */
static int hf_h245_height = -1;                   /* INTEGER_1_255 */
static int hf_h245_h263VideoUncoupledModes = -1;  /* H263ModeComboFlags */
static int hf_h245_h263VideoCoupledModes = -1;    /* SET_SIZE_1_16_OF_H263ModeComboFlags */
static int hf_h245_h263VideoCoupledModes_item = -1;  /* H263ModeComboFlags */
static int hf_h245_referencePicSelect = -1;       /* BOOLEAN */
static int hf_h245_enhancedReferencePicSelectBool = -1;  /* BOOLEAN */
static int hf_h245_dataPartitionedSlices = -1;    /* BOOLEAN */
static int hf_h245_fixedPointIDCT0 = -1;          /* BOOLEAN */
static int hf_h245_interlacedFields = -1;         /* BOOLEAN */
static int hf_h245_currentPictureHeaderRepetition = -1;  /* BOOLEAN */
static int hf_h245_previousPictureHeaderRepetition = -1;  /* BOOLEAN */
static int hf_h245_nextPictureHeaderRepetition = -1;  /* BOOLEAN */
static int hf_h245_pictureNumberBoolean = -1;     /* BOOLEAN */
static int hf_h245_spareReferencePictures = -1;   /* BOOLEAN */
static int hf_h245_constrainedBitstream = -1;     /* BOOLEAN */
static int hf_h245_pictureRate = -1;              /* INTEGER_0_15 */
static int hf_h245_g711Alaw64k = -1;              /* INTEGER_1_256 */
static int hf_h245_g711Alaw56k = -1;              /* INTEGER_1_256 */
static int hf_h245_g711Ulaw64k = -1;              /* INTEGER_1_256 */
static int hf_h245_g711Ulaw56k = -1;              /* INTEGER_1_256 */
static int hf_h245_g722_64k = -1;                 /* INTEGER_1_256 */
static int hf_h245_g722_56k = -1;                 /* INTEGER_1_256 */
static int hf_h245_g722_48k = -1;                 /* INTEGER_1_256 */
static int hf_h245_g7231 = -1;                    /* T_g7231 */
static int hf_h245_maxAl_sduAudioFrames = -1;     /* INTEGER_1_256 */
static int hf_h245_silenceSuppression = -1;       /* BOOLEAN */
static int hf_h245_g728 = -1;                     /* INTEGER_1_256 */
static int hf_h245_g729 = -1;                     /* INTEGER_1_256 */
static int hf_h245_g729AnnexA = -1;               /* INTEGER_1_256 */
static int hf_h245_is11172AudioCapability = -1;   /* IS11172AudioCapability */
static int hf_h245_is13818AudioCapability = -1;   /* IS13818AudioCapability */
static int hf_h245_g729wAnnexB = -1;              /* INTEGER_1_256 */
static int hf_h245_g729AnnexAwAnnexB = -1;        /* INTEGER_1_256 */
static int hf_h245_g7231AnnexCCapability = -1;    /* G7231AnnexCCapability */
static int hf_h245_gsmFullRate = -1;              /* GSMAudioCapability */
static int hf_h245_gsmHalfRate = -1;              /* GSMAudioCapability */
static int hf_h245_gsmEnhancedFullRate = -1;      /* GSMAudioCapability */
static int hf_h245_genericAudioCapability = -1;   /* GenericCapability */
static int hf_h245_g729Extensions = -1;           /* G729Extensions */
static int hf_h245_vbd = -1;                      /* VBDCapability */
static int hf_h245_audioTelephonyEvent = -1;      /* NoPTAudioTelephonyEventCapability */
static int hf_h245_audioTone = -1;                /* NoPTAudioToneCapability */
static int hf_h245_audioUnit = -1;                /* INTEGER_1_256 */
static int hf_h245_annexA = -1;                   /* BOOLEAN */
static int hf_h245_annexB = -1;                   /* BOOLEAN */
static int hf_h245_annexD = -1;                   /* BOOLEAN */
static int hf_h245_annexE = -1;                   /* BOOLEAN */
static int hf_h245_annexF = -1;                   /* BOOLEAN */
static int hf_h245_annexG = -1;                   /* BOOLEAN */
static int hf_h245_annexH = -1;                   /* BOOLEAN */
static int hf_h245_highRateMode0 = -1;            /* INTEGER_27_78 */
static int hf_h245_highRateMode1 = -1;            /* INTEGER_27_78 */
static int hf_h245_lowRateMode0 = -1;             /* INTEGER_23_66 */
static int hf_h245_lowRateMode1 = -1;             /* INTEGER_23_66 */
static int hf_h245_sidMode0 = -1;                 /* INTEGER_6_17 */
static int hf_h245_sidMode1 = -1;                 /* INTEGER_6_17 */
static int hf_h245_g723AnnexCAudioMode = -1;      /* G723AnnexCAudioMode */
static int hf_h245_audioLayer1 = -1;              /* BOOLEAN */
static int hf_h245_audioLayer2 = -1;              /* BOOLEAN */
static int hf_h245_audioLayer3 = -1;              /* BOOLEAN */
static int hf_h245_audioSampling32k = -1;         /* BOOLEAN */
static int hf_h245_audioSampling44k1 = -1;        /* BOOLEAN */
static int hf_h245_audioSampling48k = -1;         /* BOOLEAN */
static int hf_h245_singleChannel = -1;            /* BOOLEAN */
static int hf_h245_twoChannels = -1;              /* BOOLEAN */
static int hf_h245_bitRate_1_448 = -1;            /* INTEGER_1_448 */
static int hf_h245_audioSampling16k = -1;         /* BOOLEAN */
static int hf_h245_audioSampling22k05 = -1;       /* BOOLEAN */
static int hf_h245_audioSampling24k = -1;         /* BOOLEAN */
static int hf_h245_threeChannels2_1 = -1;         /* BOOLEAN */
static int hf_h245_threeChannels3_0 = -1;         /* BOOLEAN */
static int hf_h245_fourChannels2_0_2_0 = -1;      /* BOOLEAN */
static int hf_h245_fourChannels2_2 = -1;          /* BOOLEAN */
static int hf_h245_fourChannels3_1 = -1;          /* BOOLEAN */
static int hf_h245_fiveChannels3_0_2_0 = -1;      /* BOOLEAN */
static int hf_h245_fiveChannels3_2 = -1;          /* BOOLEAN */
static int hf_h245_lowFrequencyEnhancement = -1;  /* BOOLEAN */
static int hf_h245_multilingual = -1;             /* BOOLEAN */
static int hf_h245_bitRate2_1_1130 = -1;          /* INTEGER_1_1130 */
static int hf_h245_audioUnitSize = -1;            /* INTEGER_1_256 */
static int hf_h245_comfortNoise = -1;             /* BOOLEAN */
static int hf_h245_scrambled = -1;                /* BOOLEAN */
static int hf_h245_vbd_cap_type = -1;             /* AudioCapability */
static int hf_h245_t120 = -1;                     /* DataProtocolCapability */
static int hf_h245_dsm_cc = -1;                   /* DataProtocolCapability */
static int hf_h245_userData = -1;                 /* DataProtocolCapability */
static int hf_h245_t84 = -1;                      /* T_t84 */
static int hf_h245_t84Protocol = -1;              /* DataProtocolCapability */
static int hf_h245_t84Profile = -1;               /* T84Profile */
static int hf_h245_t434 = -1;                     /* DataProtocolCapability */
static int hf_h245_h224 = -1;                     /* DataProtocolCapability */
static int hf_h245_nlpidProtocol = -1;            /* DataProtocolCapability */
static int hf_h245_nlpidData = -1;                /* OCTET_STRING */
static int hf_h245_nlpid = -1;                    /* Nlpid */
static int hf_h245_dsvdControl = -1;              /* NULL */
static int hf_h245_h222DataPartitioning = -1;     /* DataProtocolCapability */
static int hf_h245_t30fax = -1;                   /* DataProtocolCapability */
static int hf_h245_t140 = -1;                     /* DataProtocolCapability */
static int hf_h245_t38fax = -1;                   /* T_t38fax */
static int hf_h245_t38FaxProtocol = -1;           /* DataProtocolCapability */
static int hf_h245_t38FaxProfile = -1;            /* T38FaxProfile */
static int hf_h245_genericDataCapability = -1;    /* GenericCapability */
static int hf_h245_application = -1;              /* Application */
static int hf_h245_maxBitRate2_0_4294967295 = -1;  /* INTEGER_0_4294967295 */
static int hf_h245_v14buffered = -1;              /* NULL */
static int hf_h245_v42lapm = -1;                  /* NULL */
static int hf_h245_hdlcFrameTunnelling = -1;      /* NULL */
static int hf_h245_h310SeparateVCStack = -1;      /* NULL */
static int hf_h245_h310SingleVCStack = -1;        /* NULL */
static int hf_h245_transparent = -1;              /* NULL */
static int hf_h245_segmentationAndReassembly = -1;  /* NULL */
static int hf_h245_hdlcFrameTunnelingwSAR = -1;   /* NULL */
static int hf_h245_v120 = -1;                     /* NULL */
static int hf_h245_separateLANStack = -1;         /* NULL */
static int hf_h245_v76wCompression = -1;          /* T_v76wCompression */
static int hf_h245_transmitCompression = -1;      /* CompressionType */
static int hf_h245_receiveCompression = -1;       /* CompressionType */
static int hf_h245_transmitAndReceiveCompression = -1;  /* CompressionType */
static int hf_h245_tcp = -1;                      /* NULL */
static int hf_h245_udp = -1;                      /* NULL */
static int hf_h245_v42bis = -1;                   /* V42bis */
static int hf_h245_numberOfCodewords = -1;        /* INTEGER_1_65536 */
static int hf_h245_maximumStringLength = -1;      /* INTEGER_1_256 */
static int hf_h245_t84Unrestricted = -1;          /* NULL */
static int hf_h245_t84Restricted = -1;            /* T_t84Restricted */
static int hf_h245_qcif_bool = -1;                /* BOOLEAN */
static int hf_h245_cif_bool = -1;                 /* BOOLEAN */
static int hf_h245_ccir601Seq = -1;               /* BOOLEAN */
static int hf_h245_ccir601Prog = -1;              /* BOOLEAN */
static int hf_h245_hdtvSeq = -1;                  /* BOOLEAN */
static int hf_h245_hdtvProg = -1;                 /* BOOLEAN */
static int hf_h245_g3FacsMH200x100 = -1;          /* BOOLEAN */
static int hf_h245_g3FacsMH200x200 = -1;          /* BOOLEAN */
static int hf_h245_g4FacsMMR200x100 = -1;         /* BOOLEAN */
static int hf_h245_g4FacsMMR200x200 = -1;         /* BOOLEAN */
static int hf_h245_jbig200x200Seq = -1;           /* BOOLEAN */
static int hf_h245_jbig200x200Prog = -1;          /* BOOLEAN */
static int hf_h245_jbig300x300Seq = -1;           /* BOOLEAN */
static int hf_h245_jbig300x300Prog = -1;          /* BOOLEAN */
static int hf_h245_digPhotoLow = -1;              /* BOOLEAN */
static int hf_h245_digPhotoMedSeq = -1;           /* BOOLEAN */
static int hf_h245_digPhotoMedProg = -1;          /* BOOLEAN */
static int hf_h245_digPhotoHighSeq = -1;          /* BOOLEAN */
static int hf_h245_digPhotoHighProg = -1;         /* BOOLEAN */
static int hf_h245_fillBitRemoval = -1;           /* BOOLEAN */
static int hf_h245_transcodingJBIG = -1;          /* BOOLEAN */
static int hf_h245_transcodingMMR = -1;           /* BOOLEAN */
static int hf_h245_version = -1;                  /* INTEGER_0_255 */
static int hf_h245_t38FaxRateManagement = -1;     /* T38FaxRateManagement */
static int hf_h245_t38FaxUdpOptions = -1;         /* T38FaxUdpOptions */
static int hf_h245_t38FaxTcpOptions = -1;         /* T38FaxTcpOptions */
static int hf_h245_localTCF = -1;                 /* NULL */
static int hf_h245_transferredTCF = -1;           /* NULL */
static int hf_h245_t38FaxMaxBuffer = -1;          /* INTEGER */
static int hf_h245_t38FaxMaxDatagram = -1;        /* INTEGER */
static int hf_h245_t38FaxUdpEC = -1;              /* T_t38FaxUdpEC */
static int hf_h245_t38UDPFEC = -1;                /* NULL */
static int hf_h245_t38UDPRedundancy = -1;         /* NULL */
static int hf_h245_t38TCPBidirectionalMode = -1;  /* BOOLEAN */
static int hf_h245_encryptionCapability = -1;     /* EncryptionCapability */
static int hf_h245_authenticationCapability = -1;  /* AuthenticationCapability */
static int hf_h245_integrityCapability = -1;      /* IntegrityCapability */
static int hf_h245_genericH235SecurityCapability = -1;  /* GenericCapability */
static int hf_h245_EncryptionCapability_item = -1;  /* MediaEncryptionAlgorithm */
static int hf_h245_algorithm = -1;                /* OBJECT_IDENTIFIER */
static int hf_h245_antiSpamAlgorithm = -1;        /* OBJECT_IDENTIFIER */
static int hf_h245_ui_nonStandard = -1;           /* SEQUENCE_SIZE_1_16_OF_NonStandardParameter */
static int hf_h245_ui_nonStandard_item = -1;      /* NonStandardParameter */
static int hf_h245_basicString = -1;              /* NULL */
static int hf_h245_iA5String = -1;                /* NULL */
static int hf_h245_generalString = -1;            /* NULL */
static int hf_h245_dtmf = -1;                     /* NULL */
static int hf_h245_hookflash = -1;                /* NULL */
static int hf_h245_extendedAlphanumericFlag = -1;  /* NULL */
static int hf_h245_encryptedBasicString = -1;     /* NULL */
static int hf_h245_encryptedIA5String = -1;       /* NULL */
static int hf_h245_encryptedGeneralString = -1;   /* NULL */
static int hf_h245_secureDTMF = -1;               /* NULL */
static int hf_h245_genericUserInputCapability = -1;  /* GenericCapability */
static int hf_h245_nonStandardParams = -1;        /* SEQUENCE_OF_NonStandardParameter */
static int hf_h245_nonStandardParams_item = -1;   /* NonStandardParameter */
static int hf_h245_chairControlCapability = -1;   /* BOOLEAN */
static int hf_h245_videoIndicateMixingCapability = -1;  /* BOOLEAN */
static int hf_h245_multipointVisualizationCapability = -1;  /* BOOLEAN */
static int hf_h245_capabilityIdentifier = -1;     /* CapabilityIdentifier */
static int hf_h245_collapsing = -1;               /* T_collapsing */
static int hf_h245_collapsing_item = -1;          /* T_collapsing_item */
static int hf_h245_nonCollapsing = -1;            /* T_nonCollapsing */
static int hf_h245_nonCollapsing_item = -1;       /* T_nonCollapsing_item */
static int hf_h245_nonCollapsingRaw = -1;         /* T_nonCollapsingRaw */
static int hf_h245_transport = -1;                /* DataProtocolCapability */
static int hf_h245_standardOid = -1;              /* T_standardOid */
static int hf_h245_h221NonStandard = -1;          /* NonStandardParameter */
static int hf_h245_uuid = -1;                     /* OCTET_STRING_SIZE_16 */
static int hf_h245_domainBased = -1;              /* IA5String_SIZE_1_64 */
static int hf_h245_parameterIdentifier = -1;      /* ParameterIdentifier */
static int hf_h245_parameterValue = -1;           /* ParameterValue */
static int hf_h245_supersedes = -1;               /* SEQUENCE_OF_ParameterIdentifier */
static int hf_h245_supersedes_item = -1;          /* ParameterIdentifier */
static int hf_h245_standard = -1;                 /* T_standard */
static int hf_h245_logical = -1;                  /* NULL */
static int hf_h245_booleanArray = -1;             /* T_booleanArray */
static int hf_h245_unsignedMin = -1;              /* T_unsignedMin */
static int hf_h245_unsignedMax = -1;              /* T_unsignedMax */
static int hf_h245_unsigned32Min = -1;            /* T_unsigned32Min */
static int hf_h245_unsigned32Max = -1;            /* T_unsigned32Max */
static int hf_h245_octetString = -1;              /* T_octetString */
static int hf_h245_genericParameters = -1;        /* SEQUENCE_OF_GenericParameter */
static int hf_h245_genericParameters_item = -1;   /* GenericParameter */
static int hf_h245_multiplexFormat = -1;          /* MultiplexFormat */
static int hf_h245_controlOnMuxStream = -1;       /* BOOLEAN */
static int hf_h245_capabilityOnMuxStream = -1;    /* SET_SIZE_1_256_OF_AlternativeCapabilitySet */
static int hf_h245_capabilityOnMuxStream_item = -1;  /* AlternativeCapabilitySet */
static int hf_h245_dynamicRTPPayloadType = -1;    /* INTEGER_96_127 */
static int hf_h245_audioTelephoneEvent = -1;      /* GeneralString */
static int hf_h245_capabilities = -1;             /* SET_SIZE_1_256_OF_AlternativeCapabilitySet */
static int hf_h245_capabilities_item = -1;        /* AlternativeCapabilitySet */
static int hf_h245_fecc_rfc2733 = -1;             /* FECC_rfc2733 */
static int hf_h245_redundancyEncodingBool = -1;   /* BOOLEAN */
static int hf_h245_separateStreamBool = -1;       /* T_separateStreamBool */
static int hf_h245_separatePort = -1;             /* BOOLEAN */
static int hf_h245_samePortBool = -1;             /* BOOLEAN */
static int hf_h245_protectedCapability = -1;      /* CapabilityTableEntryNumber */
static int hf_h245_fecScheme = -1;                /* OBJECT_IDENTIFIER */
static int hf_h245_rfc2733rfc2198 = -1;           /* MaxRedundancy */
static int hf_h245_rfc2733sameport = -1;          /* MaxRedundancy */
static int hf_h245_rfc2733diffport = -1;          /* MaxRedundancy */
static int hf_h245_rfc2733Format = -1;            /* Rfc2733Format */
static int hf_h245_olc_fw_lcn = -1;               /* OLC_fw_lcn */
static int hf_h245_forwardLogicalChannelParameters = -1;  /* T_forwardLogicalChannelParameters */
static int hf_h245_portNumber = -1;               /* INTEGER_0_65535 */
static int hf_h245_dataType = -1;                 /* DataType */
static int hf_h245_olc_forw_multiplexParameters = -1;  /* OLC_forw_multiplexParameters */
static int hf_h245_h222LogicalChannelParameters = -1;  /* H222LogicalChannelParameters */
static int hf_h245_olc_fw_h223_params = -1;       /* OLC_fw_h223_params */
static int hf_h245_v76LogicalChannelParameters = -1;  /* V76LogicalChannelParameters */
static int hf_h245_h2250LogicalChannelParameters = -1;  /* H2250LogicalChannelParameters */
static int hf_h245_forwardLogicalChannelDependency = -1;  /* LogicalChannelNumber */
static int hf_h245_replacementFor = -1;           /* LogicalChannelNumber */
static int hf_h245_reverseLogicalChannelParameters = -1;  /* OLC_reverseLogicalChannelParameters */
static int hf_h245_olc_rev_multiplexParameter = -1;  /* OLC_rev_multiplexParameters */
static int hf_h245_olc_rev_h223_params = -1;      /* OLC_rev_h223_params */
static int hf_h245_reverseLogicalChannelDependency = -1;  /* LogicalChannelNumber */
static int hf_h245_separateStack = -1;            /* NetworkAccessParameters */
static int hf_h245_encryptionSync = -1;           /* EncryptionSync */
static int hf_h245_distribution = -1;             /* T_distribution */
static int hf_h245_unicast = -1;                  /* NULL */
static int hf_h245_multicast = -1;                /* NULL */
static int hf_h245_networkAddress = -1;           /* T_networkAddress */
static int hf_h245_q2931Address = -1;             /* Q2931Address */
static int hf_h245_e164Address = -1;              /* T_e164Address */
static int hf_h245_localAreaAddress = -1;         /* TransportAddress */
static int hf_h245_associateConference = -1;      /* BOOLEAN */
static int hf_h245_externalReference = -1;        /* OCTET_STRING_SIZE_1_255 */
static int hf_h245_t120SetupProcedure = -1;       /* T_t120SetupProcedure */
static int hf_h245_originateCall = -1;            /* NULL */
static int hf_h245_waitForCall = -1;              /* NULL */
static int hf_h245_issueQuery = -1;               /* NULL */
static int hf_h245_address = -1;                  /* T_address */
static int hf_h245_internationalNumber = -1;      /* NumericString_SIZE_1_16 */
static int hf_h245_nsapAddress = -1;              /* OCTET_STRING_SIZE_1_20 */
static int hf_h245_subaddress = -1;               /* OCTET_STRING_SIZE_1_20 */
static int hf_h245_audioHeaderPresent = -1;       /* BOOLEAN */
static int hf_h245_nullData = -1;                 /* NULL */
static int hf_h245_videoData = -1;                /* VideoCapability */
static int hf_h245_audioData = -1;                /* AudioCapability */
static int hf_h245_data = -1;                     /* DataApplicationCapability */
static int hf_h245_encryptionData = -1;           /* EncryptionMode */
static int hf_h245_h235Control = -1;              /* NonStandardParameter */
static int hf_h245_h235Media = -1;                /* H235Media */
static int hf_h245_multiplexedStream = -1;        /* MultiplexedStreamParameter */
static int hf_h245_redundancyEncoding = -1;       /* RedundancyEncoding */
static int hf_h245_multiplePayloadStream = -1;    /* MultiplePayloadStream */
static int hf_h245_depFec = -1;                   /* DepFECData */
static int hf_h245_fec = -1;                      /* FECData */
static int hf_h245_mediaType = -1;                /* T_mediaType */
static int hf_h245_resourceID = -1;               /* INTEGER_0_65535 */
static int hf_h245_subChannelID = -1;             /* INTEGER_0_8191 */
static int hf_h245_pcr_pid = -1;                  /* INTEGER_0_8191 */
static int hf_h245_programDescriptors = -1;       /* OCTET_STRING */
static int hf_h245_streamDescriptors = -1;        /* OCTET_STRING */
static int hf_h245_adaptationLayerType = -1;      /* T_adaptationLayerType */
static int hf_h245_h223_al_type_al1Framed = -1;   /* T_h223_al_type_al1Framed */
static int hf_h245_h223_al_type_al1NotFramed = -1;  /* T_h223_al_type_al1NotFramed */
static int hf_h245_h223_al_type_al2WithoutSequenceNumbers = -1;  /* T_h223_al_type_al2WithoutSequenceNumbers */
static int hf_h245_h223_al_type_al2WithSequenceNumbers = -1;  /* T_h223_al_type_al2WithSequenceNumbers */
static int hf_h245_controlFieldOctets = -1;       /* T_controlFieldOctets */
static int hf_h245_al3_sendBufferSize = -1;       /* T_al3_sendBufferSize */
static int hf_h245_h223_al_type_al3 = -1;         /* T_h223_al_type_al3 */
static int hf_h245_h223_al_type_al1M = -1;        /* T_h223_al_type_al1M */
static int hf_h245_h223_al_type_al2M = -1;        /* T_h223_al_type_al2M */
static int hf_h245_h223_al_type_al3M = -1;        /* T_h223_al_type_al3M */
static int hf_h245_h223_lc_segmentableFlag = -1;  /* T_h223_lc_segmentableFlag */
static int hf_h245_transferMode = -1;             /* T_transferMode */
static int hf_h245_framed = -1;                   /* NULL */
static int hf_h245_unframed = -1;                 /* NULL */
static int hf_h245_aL1HeaderFEC = -1;             /* AL1HeaderFEC */
static int hf_h245_sebch16_7 = -1;                /* NULL */
static int hf_h245_golay24_12 = -1;               /* NULL */
static int hf_h245_crcLength2 = -1;               /* AL1CrcLength */
static int hf_h245_crc4bit = -1;                  /* NULL */
static int hf_h245_crc12bit = -1;                 /* NULL */
static int hf_h245_crc20bit = -1;                 /* NULL */
static int hf_h245_crc28bit = -1;                 /* NULL */
static int hf_h245_crc8bit = -1;                  /* NULL */
static int hf_h245_crc16bit = -1;                 /* NULL */
static int hf_h245_crc32bit = -1;                 /* NULL */
static int hf_h245_crcNotUsed = -1;               /* NULL */
static int hf_h245_rcpcCodeRate = -1;             /* INTEGER_8_32 */
static int hf_h245_noArq = -1;                    /* NULL */
static int hf_h245_typeIArq = -1;                 /* H223AnnexCArqParameters */
static int hf_h245_typeIIArq = -1;                /* H223AnnexCArqParameters */
static int hf_h245_arqType = -1;                  /* ArqType */
static int hf_h245_alsduSplitting = -1;           /* BOOLEAN */
static int hf_h245_rsCodeCorrection = -1;         /* INTEGER_0_127 */
static int hf_h245_aL2HeaderFEC = -1;             /* AL2HeaderFEC */
static int hf_h245_sebch16_5 = -1;                /* NULL */
static int hf_h245_headerFormat = -1;             /* T_headerFormat */
static int hf_h245_crlength2 = -1;                /* AL3CrcLength */
static int hf_h245_numberOfRetransmissions = -1;  /* T_numberOfRetransmissions */
static int hf_h245_finite = -1;                   /* INTEGER_0_16 */
static int hf_h245_infinite = -1;                 /* NULL */
static int hf_h245_sendBufferSize = -1;           /* INTEGER_0_16777215 */
static int hf_h245_hdlcParameters = -1;           /* V76HDLCParameters */
static int hf_h245_suspendResume = -1;            /* T_suspendResume */
static int hf_h245_noSuspendResume = -1;          /* NULL */
static int hf_h245_suspendResumewAddress = -1;    /* NULL */
static int hf_h245_suspendResumewoAddress = -1;   /* NULL */
static int hf_h245_uIH = -1;                      /* BOOLEAN */
static int hf_h245_v76_mode = -1;                 /* V76LCP_mode */
static int hf_h245_eRM = -1;                      /* T_eRM */
static int hf_h245_windowSize = -1;               /* INTEGER_1_127 */
static int hf_h245_recovery = -1;                 /* T_recovery */
static int hf_h245_rej = -1;                      /* NULL */
static int hf_h245_sREJ = -1;                     /* NULL */
static int hf_h245_mSREJ = -1;                    /* NULL */
static int hf_h245_uNERM = -1;                    /* NULL */
static int hf_h245_v75Parameters = -1;            /* V75Parameters */
static int hf_h245_crcLength = -1;                /* CRCLength */
static int hf_h245_n401 = -1;                     /* INTEGER_1_4095 */
static int hf_h245_loopbackTestProcedure = -1;    /* BOOLEAN */
static int hf_h245_sessionID_0_255 = -1;          /* INTEGER_0_255 */
static int hf_h245_associatedSessionID = -1;      /* INTEGER_1_255 */
static int hf_h245_mediaChannel = -1;             /* T_mediaChannel */
static int hf_h245_mediaGuaranteedDelivery = -1;  /* BOOLEAN */
static int hf_h245_mediaControlChannel = -1;      /* T_mediaControlChannel */
static int hf_h245_mediaControlGuaranteedDelivery = -1;  /* BOOLEAN */
static int hf_h245_destination = -1;              /* TerminalLabel */
static int hf_h245_mediaPacketization = -1;       /* T_mediaPacketization */
static int hf_h245_h261aVideoPacketizationFlag = -1;  /* NULL */
static int hf_h245_rtpPayloadType = -1;           /* RTPPayloadType */
static int hf_h245_source = -1;                   /* TerminalLabel */
static int hf_h245_payloadDescriptor = -1;        /* T_payloadDescriptor */
static int hf_h245_rfc_number = -1;               /* T_rfc_number */
static int hf_h245_oid = -1;                      /* OBJECT_IDENTIFIER */
static int hf_h245_rtpPayloadType_01 = -1;        /* T_rtpPayloadType */
static int hf_h245_secondaryEncoding = -1;        /* DataType */
static int hf_h245_rtpRedundancyEncoding = -1;    /* T_rtpRedundancyEncoding */
static int hf_h245_primary = -1;                  /* RedundancyEncodingElement */
static int hf_h245_secondary = -1;                /* SEQUENCE_OF_RedundancyEncodingElement */
static int hf_h245_secondary_item = -1;           /* RedundancyEncodingElement */
static int hf_h245_payloadType = -1;              /* INTEGER_0_127 */
static int hf_h245_elements = -1;                 /* SEQUENCE_OF_MultiplePayloadStreamElement */
static int hf_h245_elements_item = -1;            /* MultiplePayloadStreamElement */
static int hf_h245_dep_rfc2733 = -1;              /* RFC2733Data */
static int hf_h245_fec_data_mode = -1;            /* FECdata_mode */
static int hf_h245_redundancyEncodingFlag = -1;   /* NULL */
static int hf_h245_differentPort = -1;            /* T_differentPort */
static int hf_h245_protectedSessionID = -1;       /* INTEGER_1_255 */
static int hf_h245_protectedPayloadType = -1;     /* INTEGER_0_127 */
static int hf_h245_samePort = -1;                 /* T_samePort */
static int hf_h245_separateStream = -1;           /* DepSeparateStream */
static int hf_h245_rfc2733 = -1;                  /* T_rfc2733 */
static int hf_h245_pktMode = -1;                  /* T_pktMode */
static int hf_h245_rfc2198coding = -1;            /* NULL */
static int hf_h245_mode_rfc2733sameport = -1;     /* T_mode_rfc2733sameport */
static int hf_h245_mode_rfc2733diffport = -1;     /* T_mode_rfc2733diffport */
static int hf_h245_protectedChannel = -1;         /* LogicalChannelNumber */
static int hf_h245_unicastAddress = -1;           /* UnicastAddress */
static int hf_h245_multicastAddress = -1;         /* MulticastAddress */
static int hf_h245_iPAddress = -1;                /* T_iPAddress */
static int hf_h245_ip4_network = -1;              /* Ipv4_network */
static int hf_h245_tsapIdentifier = -1;           /* TsapIdentifier */
static int hf_h245_iPXAddress = -1;               /* T_iPXAddress */
static int hf_h245_node = -1;                     /* OCTET_STRING_SIZE_6 */
static int hf_h245_netnum = -1;                   /* OCTET_STRING_SIZE_4 */
static int hf_h245_ipx_tsapIdentifier = -1;       /* OCTET_STRING_SIZE_2 */
static int hf_h245_iP6Address = -1;               /* T_iP6Address */
static int hf_h245_ip6_network = -1;              /* OCTET_STRING_SIZE_16 */
static int hf_h245_ipv6_tsapIdentifier = -1;      /* INTEGER_0_65535 */
static int hf_h245_netBios = -1;                  /* OCTET_STRING_SIZE_16 */
static int hf_h245_iPSourceRouteAddress = -1;     /* T_iPSourceRouteAddress */
static int hf_h245_routing = -1;                  /* T_routing */
static int hf_h245_strict = -1;                   /* NULL */
static int hf_h245_loose = -1;                    /* NULL */
static int hf_h245_network = -1;                  /* OCTET_STRING_SIZE_4 */
static int hf_h245_iPSrcRoute_tsapIdentifier = -1;  /* INTEGER_0_65535 */
static int hf_h245_route = -1;                    /* T_route */
static int hf_h245_route_item = -1;               /* OCTET_STRING_SIZE_4 */
static int hf_h245_nsap = -1;                     /* OCTET_STRING_SIZE_1_20 */
static int hf_h245_nonStandardAddress = -1;       /* NonStandardParameter */
static int hf_h245_mIPAddress = -1;               /* MIPAddress */
static int hf_h245_mip4_network = -1;             /* OCTET_STRING_SIZE_4 */
static int hf_h245_multicast_tsapIdentifier = -1;  /* INTEGER_0_65535 */
static int hf_h245_mIP6Address = -1;              /* MIP6Address */
static int hf_h245_mip6_network = -1;             /* OCTET_STRING_SIZE_16 */
static int hf_h245_multicast_IPv6_tsapIdentifier = -1;  /* INTEGER_0_65535 */
static int hf_h245_synchFlag = -1;                /* INTEGER_0_255 */
static int hf_h245_h235Key = -1;                  /* OCTET_STRING_SIZE_1_65535 */
static int hf_h245_escrowentry = -1;              /* SEQUENCE_SIZE_1_256_OF_EscrowData */
static int hf_h245_escrowentry_item = -1;         /* EscrowData */
static int hf_h245_genericParameter = -1;         /* GenericParameter */
static int hf_h245_escrowID = -1;                 /* OBJECT_IDENTIFIER */
static int hf_h245_escrowValue = -1;              /* BIT_STRING_SIZE_1_65535 */
static int hf_h245_olc_ack_fw_lcn = -1;           /* OLC_ack_fw_lcn */
static int hf_h245_olc_ack_reverseLogicalChannelParameters = -1;  /* OLC_ack_reverseLogicalChannelParameters */
static int hf_h245_reverseLogicalChannelNumber = -1;  /* T_reverseLogicalChannelNumber */
static int hf_h245_olc_ack_multiplexParameters = -1;  /* T_olc_ack_multiplexParameters */
static int hf_h245_forwardMultiplexAckParameters = -1;  /* T_forwardMultiplexAckParameters */
static int hf_h245_h2250LogicalChannelAckParameters = -1;  /* H2250LogicalChannelAckParameters */
static int hf_h245_forwardLogicalChannelNumber = -1;  /* LogicalChannelNumber */
static int hf_h245_olc_rej_cause = -1;            /* OpenLogicalChannelRejectCause */
static int hf_h245_unsuitableReverseParameters = -1;  /* NULL */
static int hf_h245_dataTypeNotSupported = -1;     /* NULL */
static int hf_h245_dataTypeNotAvailable = -1;     /* NULL */
static int hf_h245_unknownDataType = -1;          /* NULL */
static int hf_h245_dataTypeALCombinationNotSupported = -1;  /* NULL */
static int hf_h245_multicastChannelNotAllowed = -1;  /* NULL */
static int hf_h245_insufficientBandwidth = -1;    /* NULL */
static int hf_h245_separateStackEstablishmentFailed = -1;  /* NULL */
static int hf_h245_invalidSessionID = -1;         /* NULL */
static int hf_h245_masterSlaveConflict = -1;      /* NULL */
static int hf_h245_waitForCommunicationMode = -1;  /* NULL */
static int hf_h245_invalidDependentChannel = -1;  /* NULL */
static int hf_h245_replacementForRejected = -1;   /* NULL */
static int hf_h245_securityDenied = -1;           /* NULL */
static int hf_h245_qoSControlNotSupported = -1;   /* NULL */
static int hf_h245_sessionID = -1;                /* INTEGER_1_255 */
static int hf_h245_ack_mediaChannel = -1;         /* Ack_mediaChannel */
static int hf_h245_ack_mediaControlChannel = -1;  /* Ack_mediaControlChannel */
static int hf_h245_flowControlToZero = -1;        /* BOOLEAN */
static int hf_h245_cLC_source = -1;               /* T_cLC_source */
static int hf_h245_user = -1;                     /* NULL */
static int hf_h245_lcse = -1;                     /* NULL */
static int hf_h245_clc_reason = -1;               /* Clc_reason */
static int hf_h245_unknown = -1;                  /* NULL */
static int hf_h245_reopen = -1;                   /* NULL */
static int hf_h245_reservationFailure = -1;       /* NULL */
static int hf_h245_networkErrorCode = -1;         /* INTEGER_0_255 */
static int hf_h245_qosCapability = -1;            /* QOSCapability */
static int hf_h245_reason = -1;                   /* T_reason */
static int hf_h245_normal = -1;                   /* NULL */
static int hf_h245_req_chan_clos_rej_cause = -1;  /* RequestChannelCloseRejectCause */
static int hf_h245_multiplexEntryDescriptors = -1;  /* SET_SIZE_1_15_OF_MultiplexEntryDescriptor */
static int hf_h245_multiplexEntryDescriptors_item = -1;  /* MultiplexEntryDescriptor */
static int hf_h245_multiplexTableEntryNumber = -1;  /* MultiplexTableEntryNumber */
static int hf_h245_elementList = -1;              /* T_elementList */
static int hf_h245_elementList_item = -1;         /* MultiplexElement */
static int hf_h245_me_type = -1;                  /* Me_type */
static int hf_h245_logicalChannelNum = -1;        /* T_logicalChannelNum */
static int hf_h245_subElementList = -1;           /* T_subElementList */
static int hf_h245_subElementList_item = -1;      /* MultiplexElement */
static int hf_h245_me_repeatCount = -1;           /* ME_repeatCount */
static int hf_h245_me_repeatCount_finite = -1;    /* ME_finiteRepeatCount */
static int hf_h245_untilClosingFlag = -1;         /* T_untilClosingFlag */
static int hf_h245_multiplexTableEntryNumbers = -1;  /* SET_SIZE_1_15_OF_MultiplexTableEntryNumber */
static int hf_h245_multiplexTableEntryNumbers_item = -1;  /* MultiplexTableEntryNumber */
static int hf_h245_sendRejectionDescriptions = -1;  /* SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions */
static int hf_h245_sendRejectionDescriptions_item = -1;  /* MultiplexEntryRejectionDescriptions */
static int hf_h245_mux_rej_cause = -1;            /* MultiplexEntryRejectionDescriptionsCause */
static int hf_h245_unspecifiedCause = -1;         /* NULL */
static int hf_h245_descriptorTooComplex = -1;     /* NULL */
static int hf_h245_entryNumbers = -1;             /* SET_SIZE_1_15_OF_MultiplexTableEntryNumber */
static int hf_h245_entryNumbers_item = -1;        /* MultiplexTableEntryNumber */
static int hf_h245_rejectionDescriptions = -1;    /* SET_SIZE_1_15_OF_RequestMultiplexEntryRejectionDescriptions */
static int hf_h245_rejectionDescriptions_item = -1;  /* RequestMultiplexEntryRejectionDescriptions */
static int hf_h245_req_mux_rej_cause = -1;        /* RequestMultiplexEntryRejectionDescriptionsCause */
static int hf_h245_requestedModes = -1;           /* SEQUENCE_SIZE_1_256_OF_ModeDescription */
static int hf_h245_requestedModes_item = -1;      /* ModeDescription */
static int hf_h245_req_mode_ack_response = -1;    /* Req_mode_ack_response */
static int hf_h245_willTransmitMostPreferredMode = -1;  /* NULL */
static int hf_h245_willTransmitLessPreferredMode = -1;  /* NULL */
static int hf_h245_req_rej_cause = -1;            /* RequestModeRejectCause */
static int hf_h245_modeUnavailable = -1;          /* NULL */
static int hf_h245_multipointConstraint = -1;     /* NULL */
static int hf_h245_requestDenied = -1;            /* NULL */
static int hf_h245_ModeDescription_item = -1;     /* ModeElement */
static int hf_h245_videoMode = -1;                /* VideoMode */
static int hf_h245_audioMode = -1;                /* AudioMode */
static int hf_h245_dataMode = -1;                 /* DataMode */
static int hf_h245_encryptionMode = -1;           /* EncryptionMode */
static int hf_h245_h235Mode = -1;                 /* H235Mode */
static int hf_h245_multiplexedStreamMode = -1;    /* MultiplexedStreamParameter */
static int hf_h245_redundancyEncodingDTMode = -1;  /* RedundancyEncodingDTMode */
static int hf_h245_multiplePayloadStreamMode = -1;  /* MultiplePayloadStreamMode */
static int hf_h245_depFecMode = -1;               /* DepFECMode */
static int hf_h245_fecMode = -1;                  /* FECMode */
static int hf_h245_type = -1;                     /* ModeElementType */
static int hf_h245_h223ModeParameters = -1;       /* H223ModeParameters */
static int hf_h245_v76ModeParameters = -1;        /* V76ModeParameters */
static int hf_h245_h2250ModeParameters = -1;      /* H2250ModeParameters */
static int hf_h245_genericModeParameters = -1;    /* GenericCapability */
static int hf_h245_multiplexedStreamModeParameters = -1;  /* MultiplexedStreamModeParameters */
static int hf_h245_logicalChannelNumber = -1;     /* LogicalChannelNumber */
static int hf_h245_mediaMode = -1;                /* T_mediaMode */
static int hf_h245_prmary_dtmode = -1;            /* RedundancyEncodingDTModeElement */
static int hf_h245_secondaryDTM = -1;             /* SEQUENCE_OF_RedundancyEncodingDTModeElement */
static int hf_h245_secondaryDTM_item = -1;        /* RedundancyEncodingDTModeElement */
static int hf_h245_re_type = -1;                  /* Re_type */
static int hf_h245_mpsmElements = -1;             /* SEQUENCE_OF_MultiplePayloadStreamElementMode */
static int hf_h245_mpsmElements_item = -1;        /* MultiplePayloadStreamElementMode */
static int hf_h245_rfc2733Mode = -1;              /* T_rfc2733Mode */
static int hf_h245_fec_mode = -1;                 /* FEC_mode */
static int hf_h245_protectedElement = -1;         /* ModeElementType */
static int hf_h245_adaptationLayer = -1;          /* AdaptationLayerType */
static int hf_h245_al1Framed = -1;                /* NULL */
static int hf_h245_al1NotFramed = -1;             /* NULL */
static int hf_h245_al2WithoutSequenceNumbers = -1;  /* NULL */
static int hf_h245_al2WithSequenceNumbers = -1;   /* NULL */
static int hf_h245_al3 = -1;                      /* Al3 */
static int hf_h245_al1M = -1;                     /* H223AL1MParameters */
static int hf_h245_al2M = -1;                     /* H223AL2MParameters */
static int hf_h245_al3M = -1;                     /* H223AL3MParameters */
static int hf_h245_segmentableFlag = -1;          /* BOOLEAN */
static int hf_h245_redundancyEncodingMode = -1;   /* RedundancyEncodingMode */
static int hf_h245_secondaryEncodingMode = -1;    /* T_secondaryEncodingMode */
static int hf_h245_h261VideoMode = -1;            /* H261VideoMode */
static int hf_h245_h262VideoMode = -1;            /* H262VideoMode */
static int hf_h245_h263VideoMode = -1;            /* H263VideoMode */
static int hf_h245_is11172VideoMode = -1;         /* IS11172VideoMode */
static int hf_h245_genericVideoMode = -1;         /* GenericCapability */
static int hf_h245_h261_resolution = -1;          /* H261Resolution */
static int hf_h245_qcif = -1;                     /* NULL */
static int hf_h245_cif = -1;                      /* NULL */
static int hf_h245_profileAndLevel = -1;          /* T_profileAndLevel */
static int hf_h245_profileAndLevel_SPatMLMode = -1;  /* NULL */
static int hf_h245_profileAndLevel_MPatLLMode = -1;  /* NULL */
static int hf_h245_profileAndLevel_MPatMLMode = -1;  /* NULL */
static int hf_h245_profileAndLevel_MPatH_14Mode = -1;  /* NULL */
static int hf_h245_profileAndLevel_MPatHLMode = -1;  /* NULL */
static int hf_h245_profileAndLevel_SNRatLLMode = -1;  /* NULL */
static int hf_h245_profileAndLevel_SNRatMLMode = -1;  /* NULL */
static int hf_h245_profileAndLevel_SpatialatH_14Mode = -1;  /* NULL */
static int hf_h245_profileAndLevel_HPatMLMode = -1;  /* NULL */
static int hf_h245_profileAndLevel_HPatH_14Mode = -1;  /* NULL */
static int hf_h245_profileAndLevel_HPatHLMode = -1;  /* NULL */
static int hf_h245_h263_resolution = -1;          /* H263Resolution */
static int hf_h245_sqcif = -1;                    /* NULL */
static int hf_h245_cif4 = -1;                     /* NULL */
static int hf_h245_cif16 = -1;                    /* NULL */
static int hf_h245_custom_res = -1;               /* NULL */
static int hf_h245_g711Alaw64k_mode = -1;         /* NULL */
static int hf_h245_g711Alaw56k_mode = -1;         /* NULL */
static int hf_h245_g711Ulaw64k_mode = -1;         /* NULL */
static int hf_h245_g711Ulaw56k_mode = -1;         /* NULL */
static int hf_h245_g722_64k_mode = -1;            /* NULL */
static int hf_h245_g722_56k_mode = -1;            /* NULL */
static int hf_h245_g722_48k_mode = -1;            /* NULL */
static int hf_h245_g728_mode = -1;                /* NULL */
static int hf_h245_g729_mode = -1;                /* NULL */
static int hf_h245_g729AnnexA_mode = -1;          /* NULL */
static int hf_h245_g7231_mode = -1;               /* Mode_g7231 */
static int hf_h245_noSilenceSuppressionLowRate = -1;  /* NULL */
static int hf_h245_noSilenceSuppressionHighRate = -1;  /* NULL */
static int hf_h245_silenceSuppressionLowRate = -1;  /* NULL */
static int hf_h245_silenceSuppressionHighRate = -1;  /* NULL */
static int hf_h245_is11172AudioMode = -1;         /* IS11172AudioMode */
static int hf_h245_is13818AudioMode = -1;         /* IS13818AudioMode */
static int hf_h245_g7231AnnexCMode = -1;          /* G7231AnnexCMode */
static int hf_h245_genericAudioMode = -1;         /* GenericCapability */
static int hf_h245_vbd_mode = -1;                 /* VBDMode */
static int hf_h245_audioLayer = -1;               /* T_audioLayer */
static int hf_h245_audioLayer1Mode = -1;          /* NULL */
static int hf_h245_audioLayer2Mode = -1;          /* NULL */
static int hf_h245_audioLayer3Mode = -1;          /* NULL */
static int hf_h245_audioSampling = -1;            /* T_audioSampling */
static int hf_h245_audioSampling32kMode = -1;     /* NULL */
static int hf_h245_audioSampling44k1Mode = -1;    /* NULL */
static int hf_h245_audioSampling48kMode = -1;     /* NULL */
static int hf_h245_is11172multichannelType = -1;  /* IS11172_multichannelType */
static int hf_h245_singleChannelMode = -1;        /* NULL */
static int hf_h245_twoChannelStereo = -1;         /* NULL */
static int hf_h245_twoChannelDual = -1;           /* NULL */
static int hf_h245_audioLayerMode = -1;           /* IS13818AudioLayer */
static int hf_h245_audioSamplingMode = -1;        /* IS13818AudioSampling */
static int hf_h245_audioSampling16kMode = -1;     /* NULL */
static int hf_h245_audioSampling22k05Mode = -1;   /* NULL */
static int hf_h245_audioSampling24kMode = -1;     /* NULL */
static int hf_h245_is13818MultichannelType = -1;  /* IS13818MultichannelType */
static int hf_h245_threeChannels2_1Mode = -1;     /* NULL */
static int hf_h245_threeChannels3_0Mode = -1;     /* NULL */
static int hf_h245_fourChannels2_0_2_0Mode = -1;  /* NULL */
static int hf_h245_fourChannels2_2Mode = -1;      /* NULL */
static int hf_h245_fourChannels3_1Mode = -1;      /* NULL */
static int hf_h245_fiveChannels3_0_2_0Mode = -1;  /* NULL */
static int hf_h245_fiveChannels3_2Mode = -1;      /* NULL */
static int hf_h245_vbd_type = -1;                 /* AudioMode */
static int hf_h245_datamodeapplication = -1;      /* DataModeApplication */
static int hf_h245_t84DataProtocolCapability = -1;  /* DataProtocolCapability */
static int hf_h245_t38faxDataProtocolCapability = -1;  /* T38faxApp */
static int hf_h245_genericDataMode = -1;          /* GenericCapability */
static int hf_h245_bitRate_0_4294967295 = -1;     /* INTEGER_0_4294967295 */
static int hf_h245_h233Encryption = -1;           /* NULL */
static int hf_h245_mlr_type = -1;                 /* Mlr_type */
static int hf_h245_systemLoop = -1;               /* NULL */
static int hf_h245_mediaLoop = -1;                /* LogicalChannelNumber */
static int hf_h245_logicalChannelLoop = -1;       /* LogicalChannelNumber */
static int hf_h245_mla_type = -1;                 /* Mla_type */
static int hf_h245_mlrej_type = -1;               /* Mlrej_type */
static int hf_h245_maintloop_rej_cause = -1;      /* MaintenanceLoopRejectCause */
static int hf_h245_canNotPerformLoop = -1;        /* NULL */
static int hf_h245_communicationModeTable = -1;   /* SET_SIZE_1_256_OF_CommunicationModeTableEntry */
static int hf_h245_communicationModeTable_item = -1;  /* CommunicationModeTableEntry */
static int hf_h245_terminalLabel = -1;            /* TerminalLabel */
static int hf_h245_sessionDescription = -1;       /* BMPString_SIZE_1_128 */
static int hf_h245_entryDataType = -1;            /* T_entryDataType */
static int hf_h245_cm_mediaChannel = -1;          /* Cm_mediaChannel */
static int hf_h245_cm_mediaControlChannel = -1;   /* TransportAddress */
static int hf_h245_sessionDependency = -1;        /* INTEGER_1_255 */
static int hf_h245_terminalListRequest = -1;      /* NULL */
static int hf_h245_makeMeChair = -1;              /* NULL */
static int hf_h245_cancelMakeMeChair = -1;        /* NULL */
static int hf_h245_dropTerminal = -1;             /* TerminalLabel */
static int hf_h245_requestTerminalID = -1;        /* TerminalLabel */
static int hf_h245_enterH243Password = -1;        /* NULL */
static int hf_h245_enterH243TerminalID = -1;      /* NULL */
static int hf_h245_enterH243ConferenceID = -1;    /* NULL */
static int hf_h245_enterExtensionAddress = -1;    /* NULL */
static int hf_h245_requestChairTokenOwner = -1;   /* NULL */
static int hf_h245_requestTerminalCertificate = -1;  /* T_requestTerminalCertificate */
static int hf_h245_certSelectionCriteria = -1;    /* CertSelectionCriteria */
static int hf_h245_sRandom = -1;                  /* INTEGER_1_4294967295 */
static int hf_h245_broadcastMyLogicalChannel = -1;  /* LogicalChannelNumber */
static int hf_h245_makeTerminalBroadcaster = -1;  /* TerminalLabel */
static int hf_h245_sendThisSource = -1;           /* TerminalLabel */
static int hf_h245_requestAllTerminalIDs = -1;    /* NULL */
static int hf_h245_remoteMCRequest = -1;          /* RemoteMCRequest */
static int hf_h245_CertSelectionCriteria_item = -1;  /* Criteria */
static int hf_h245_field = -1;                    /* OBJECT_IDENTIFIER */
static int hf_h245_criteriaValue = -1;            /* OCTET_STRING_SIZE_1_65535 */
static int hf_h245_mcuNumber = -1;                /* McuNumber */
static int hf_h245_terminalNumber = -1;           /* TerminalNumber */
static int hf_h245_mCTerminalIDResponse = -1;     /* T_mCTerminalIDResponse */
static int hf_h245_terminalID = -1;               /* TerminalID */
static int hf_h245_terminalIDResponse = -1;       /* T_terminalIDResponse */
static int hf_h245_conferenceIDResponse = -1;     /* T_conferenceIDResponse */
static int hf_h245_conferenceID = -1;             /* ConferenceID */
static int hf_h245_passwordResponse = -1;         /* T_passwordResponse */
static int hf_h245_password = -1;                 /* Password */
static int hf_h245_terminalListResponse = -1;     /* SET_SIZE_1_256_OF_TerminalLabel */
static int hf_h245_terminalListResponse_item = -1;  /* TerminalLabel */
static int hf_h245_videoCommandReject = -1;       /* NULL */
static int hf_h245_terminalDropReject = -1;       /* NULL */
static int hf_h245_makeMeChairResponse = -1;      /* T_makeMeChairResponse */
static int hf_h245_grantedChairToken = -1;        /* NULL */
static int hf_h245_deniedChairToken = -1;         /* NULL */
static int hf_h245_extensionAddressResponse = -1;  /* T_extensionAddressResponse */
static int hf_h245_extensionAddress = -1;         /* TerminalID */
static int hf_h245_chairTokenOwnerResponse = -1;  /* T_chairTokenOwnerResponse */
static int hf_h245_terminalCertificateResponse = -1;  /* T_terminalCertificateResponse */
static int hf_h245_certificateResponse = -1;      /* OCTET_STRING_SIZE_1_65535 */
static int hf_h245_broadcastMyLogicalChannelResponse = -1;  /* T_broadcastMyLogicalChannelResponse */
static int hf_h245_grantedBroadcastMyLogicalChannel = -1;  /* NULL */
static int hf_h245_deniedBroadcastMyLogicalChannel = -1;  /* NULL */
static int hf_h245_makeTerminalBroadcasterResponse = -1;  /* T_makeTerminalBroadcasterResponse */
static int hf_h245_grantedMakeTerminalBroadcaster = -1;  /* NULL */
static int hf_h245_deniedMakeTerminalBroadcaster = -1;  /* NULL */
static int hf_h245_sendThisSourceResponse = -1;   /* T_sendThisSourceResponse */
static int hf_h245_grantedSendThisSource = -1;    /* NULL */
static int hf_h245_deniedSendThisSource = -1;     /* NULL */
static int hf_h245_requestAllTerminalIDsResponse = -1;  /* RequestAllTerminalIDsResponse */
static int hf_h245_remoteMCResponse = -1;         /* RemoteMCResponse */
static int hf_h245_terminalInformation = -1;      /* SEQUENCE_OF_TerminalInformation */
static int hf_h245_terminalInformation_item = -1;  /* TerminalInformation */
static int hf_h245_masterActivate = -1;           /* NULL */
static int hf_h245_slaveActivate = -1;            /* NULL */
static int hf_h245_deActivate = -1;               /* NULL */
static int hf_h245_accept = -1;                   /* NULL */
static int hf_h245_reject = -1;                   /* T_reject */
static int hf_h245_functionNotSupportedFlag = -1;  /* NULL */
static int hf_h245_callInformationReq = -1;       /* CallInformationReq */
static int hf_h245_maxNumberOfAdditionalConnections = -1;  /* INTEGER_1_65535 */
static int hf_h245_addConnectionReq = -1;         /* AddConnectionReq */
static int hf_h245_dialingInformation = -1;       /* DialingInformation */
static int hf_h245_removeConnectionReq = -1;      /* RemoveConnectionReq */
static int hf_h245_connectionIdentifier = -1;     /* ConnectionIdentifier */
static int hf_h245_maximumHeaderIntervalReq = -1;  /* MaximumHeaderIntervalReq */
static int hf_h245_requestType = -1;              /* T_requestType */
static int hf_h245_currentIntervalInformation = -1;  /* NULL */
static int hf_h245_requestedInterval = -1;        /* INTEGER_0_65535 */
static int hf_h245_callInformationResp = -1;      /* CallInformationResp */
static int hf_h245_callAssociationNumber = -1;    /* INTEGER_0_4294967295 */
static int hf_h245_addConnectionResp = -1;        /* AddConnectionResp */
static int hf_h245_responseCode = -1;             /* T_responseCode */
static int hf_h245_accepted = -1;                 /* NULL */
static int hf_h245_rejected = -1;                 /* T_rejected */
static int hf_h245_connectionsNotAvailable = -1;  /* NULL */
static int hf_h245_userRejected = -1;             /* NULL */
static int hf_h245_removeConnectionResp = -1;     /* RemoveConnectionResp */
static int hf_h245_maximumHeaderIntervalResp = -1;  /* MaximumHeaderIntervalResp */
static int hf_h245_currentInterval = -1;          /* INTEGER_0_65535 */
static int hf_h245_crcDesired = -1;               /* T_crcDesired */
static int hf_h245_excessiveError = -1;           /* T_excessiveError */
static int hf_h245_differential = -1;             /* SET_SIZE_1_65535_OF_DialingInformationNumber */
static int hf_h245_differential_item = -1;        /* DialingInformationNumber */
static int hf_h245_infoNotAvailable = -1;         /* INTEGER_1_65535 */
static int hf_h245_networkAddressNum = -1;        /* NumericString_SIZE_0_40 */
static int hf_h245_subAddress = -1;               /* IA5String_SIZE_1_40 */
static int hf_h245_networkType = -1;              /* SET_SIZE_1_255_OF_DialingInformationNetworkType */
static int hf_h245_networkType_item = -1;         /* DialingInformationNetworkType */
static int hf_h245_n_isdn = -1;                   /* NULL */
static int hf_h245_gstn = -1;                     /* NULL */
static int hf_h245_mobile = -1;                   /* NULL */
static int hf_h245_channelTag = -1;               /* INTEGER_0_4294967295 */
static int hf_h245_sequenceNum = -1;              /* INTEGER_0_4294967295 */
static int hf_h245_maximumBitRate = -1;           /* MaximumBitRate */
static int hf_h245_rejectReason = -1;             /* LogicalChannelRateRejectReason */
static int hf_h245_currentMaximumBitRate = -1;    /* MaximumBitRate */
static int hf_h245_undefinedReason = -1;          /* NULL */
static int hf_h245_insufficientResources = -1;    /* NULL */
static int hf_h245_specificRequest = -1;          /* T_specificRequest */
static int hf_h245_multiplexCapabilityBool = -1;  /* BOOLEAN */
static int hf_h245_capabilityTableEntryNumbers = -1;  /* SET_SIZE_1_65535_OF_CapabilityTableEntryNumber */
static int hf_h245_capabilityTableEntryNumbers_item = -1;  /* CapabilityTableEntryNumber */
static int hf_h245_capabilityDescriptorNumbers = -1;  /* SET_SIZE_1_256_OF_CapabilityDescriptorNumber */
static int hf_h245_capabilityDescriptorNumbers_item = -1;  /* CapabilityDescriptorNumber */
static int hf_h245_genericRequestFlag = -1;       /* NULL */
static int hf_h245_encryptionSE = -1;             /* OCTET_STRING */
static int hf_h245_encryptionIVRequest = -1;      /* NULL */
static int hf_h245_encryptionAlgorithmID = -1;    /* T_encryptionAlgorithmID */
static int hf_h245_h233AlgorithmIdentifier = -1;  /* SequenceNumber */
static int hf_h245_associatedAlgorithm = -1;      /* NonStandardParameter */
static int hf_h245_wholeMultiplex = -1;           /* NULL */
static int hf_h245_scope = -1;                    /* Scope */
static int hf_h245_res_maximumBitRate = -1;       /* INTEGER_0_16777215 */
static int hf_h245_noRestriction = -1;            /* NULL */
static int hf_h245_restriction = -1;              /* Restriction */
static int hf_h245_disconnect = -1;               /* NULL */
static int hf_h245_gstnOptions = -1;              /* T_gstnOptions */
static int hf_h245_telephonyMode = -1;            /* NULL */
static int hf_h245_v8bis = -1;                    /* NULL */
static int hf_h245_v34DSVD = -1;                  /* NULL */
static int hf_h245_v34DuplexFAX = -1;             /* NULL */
static int hf_h245_v34H324 = -1;                  /* NULL */
static int hf_h245_isdnOptions = -1;              /* T_isdnOptions */
static int hf_h245_v140 = -1;                     /* NULL */
static int hf_h245_terminalOnHold = -1;           /* NULL */
static int hf_h245_cancelBroadcastMyLogicalChannel = -1;  /* LogicalChannelNumber */
static int hf_h245_cancelMakeTerminalBroadcaster = -1;  /* NULL */
static int hf_h245_cancelSendThisSource = -1;     /* NULL */
static int hf_h245_dropConference = -1;           /* NULL */
static int hf_h245_substituteConferenceIDCommand = -1;  /* SubstituteConferenceIDCommand */
static int hf_h245_conferenceIdentifier = -1;     /* OCTET_STRING_SIZE_16 */
static int hf_h245_masterToSlave = -1;            /* NULL */
static int hf_h245_slaveToMaster = -1;            /* NULL */
static int hf_h245_mc_type = -1;                  /* Mc_type */
static int hf_h245_equaliseDelay = -1;            /* NULL */
static int hf_h245_zeroDelay = -1;                /* NULL */
static int hf_h245_multipointModeCommand = -1;    /* NULL */
static int hf_h245_cancelMultipointModeCommand = -1;  /* NULL */
static int hf_h245_videoFreezePicture = -1;       /* NULL */
static int hf_h245_videoFastUpdatePicture = -1;   /* NULL */
static int hf_h245_videoFastUpdateGOB = -1;       /* T_videoFastUpdateGOB */
static int hf_h245_firstGOB = -1;                 /* INTEGER_0_17 */
static int hf_h245_numberOfGOBs = -1;             /* INTEGER_1_18 */
static int hf_h245_videoTemporalSpatialTradeOff = -1;  /* INTEGER_0_31 */
static int hf_h245_videoSendSyncEveryGOB = -1;    /* NULL */
static int hf_h245_videoSendSyncEveryGOBCancel = -1;  /* NULL */
static int hf_h245_videoFastUpdateMB = -1;        /* T_videoFastUpdateMB */
static int hf_h245_firstGOB_0_255 = -1;           /* INTEGER_0_255 */
static int hf_h245_firstMB_1_8192 = -1;           /* INTEGER_1_8192 */
static int hf_h245_numberOfMBs = -1;              /* INTEGER_1_8192 */
static int hf_h245_maxH223MUXPDUsize = -1;        /* INTEGER_1_65535 */
static int hf_h245_encryptionUpdate = -1;         /* EncryptionSync */
static int hf_h245_encryptionUpdateRequest = -1;  /* EncryptionUpdateRequest */
static int hf_h245_switchReceiveMediaOff = -1;    /* NULL */
static int hf_h245_switchReceiveMediaOn = -1;     /* NULL */
static int hf_h245_progressiveRefinementStart = -1;  /* T_progressiveRefinementStart */
static int hf_h245_repeatCount = -1;              /* T_repeatCount */
static int hf_h245_doOneProgression = -1;         /* NULL */
static int hf_h245_doContinuousProgressions = -1;  /* NULL */
static int hf_h245_doOneIndependentProgression = -1;  /* NULL */
static int hf_h245_doContinuousIndependentProgressions = -1;  /* NULL */
static int hf_h245_progressiveRefinementAbortOne = -1;  /* NULL */
static int hf_h245_progressiveRefinementAbortContinuous = -1;  /* NULL */
static int hf_h245_videoBadMBs = -1;              /* T_videoBadMBs */
static int hf_h245_firstMB = -1;                  /* INTEGER_1_9216 */
static int hf_h245_numberOfMBs1_1_9216 = -1;      /* INTEGER_1_9216 */
static int hf_h245_temporalReference = -1;        /* INTEGER_0_1023 */
static int hf_h245_lostPicture = -1;              /* SEQUENCE_OF_PictureReference */
static int hf_h245_lostPicture_item = -1;         /* PictureReference */
static int hf_h245_lostPartialPicture = -1;       /* T_lostPartialPicture */
static int hf_h245_pictureReference = -1;         /* PictureReference */
static int hf_h245_recoveryReferencePicture = -1;  /* SEQUENCE_OF_PictureReference */
static int hf_h245_recoveryReferencePicture_item = -1;  /* PictureReference */
static int hf_h245_encryptionUpdateCommand = -1;  /* T_encryptionUpdateCommand */
static int hf_h245_encryptionUpdateAck = -1;      /* T_encryptionUpdateAck */
static int hf_h245_direction = -1;                /* EncryptionUpdateDirection */
static int hf_h245_secureChannel = -1;            /* BOOLEAN */
static int hf_h245_sharedSecret = -1;             /* BOOLEAN */
static int hf_h245_certProtectedKey = -1;         /* BOOLEAN */
static int hf_h245_keyProtectionMethod = -1;      /* KeyProtectionMethod */
static int hf_h245_pictureNumber = -1;            /* INTEGER_0_1023 */
static int hf_h245_longTermPictureIndex = -1;     /* INTEGER_0_255 */
static int hf_h245_h223ModeChange = -1;           /* T_h223ModeChange */
static int hf_h245_toLevel0 = -1;                 /* NULL */
static int hf_h245_toLevel1 = -1;                 /* NULL */
static int hf_h245_toLevel2 = -1;                 /* NULL */
static int hf_h245_toLevel2withOptionalHeader = -1;  /* NULL */
static int hf_h245_h223AnnexADoubleFlag = -1;     /* T_h223AnnexADoubleFlag */
static int hf_h245_start = -1;                    /* NULL */
static int hf_h245_stop = -1;                     /* NULL */
static int hf_h245_bitRate = -1;                  /* INTEGER_1_65535 */
static int hf_h245_bitRateLockedToPCRClock = -1;  /* BOOLEAN */
static int hf_h245_bitRateLockedToNetworkClock = -1;  /* BOOLEAN */
static int hf_h245_cmd_aal = -1;                  /* Cmd_aal */
static int hf_h245_cmd_aal1 = -1;                 /* Cmd_aal1 */
static int hf_h245_cmd_clockRecovery = -1;        /* Cmd_clockRecovery */
static int hf_h245_nullClockRecoveryflag = -1;    /* NULL */
static int hf_h245_srtsClockRecovery = -1;        /* NULL */
static int hf_h245_adaptiveClockRecoveryFlag = -1;  /* NULL */
static int hf_h245_cmd_errorCorrection = -1;      /* Cmd_errorCorrection */
static int hf_h245_nullErrorCorrectionFlag = -1;  /* NULL */
static int hf_h245_longInterleaverFlag = -1;      /* NULL */
static int hf_h245_shortInterleaverFlag = -1;     /* NULL */
static int hf_h245_errorCorrectionOnlyFlag = -1;  /* NULL */
static int hf_h245_cmd_aal5 = -1;                 /* Cmd_aal5 */
static int hf_h245_cmd_multiplex = -1;            /* Cmd_multiplex */
static int hf_h245_noMultiplex = -1;              /* NULL */
static int hf_h245_transportStream = -1;          /* NULL */
static int hf_h245_programStreamFlag = -1;        /* NULL */
static int hf_h245_cmd_reverseParameters = -1;    /* Cmd_reverseParameters */
static int hf_h245_cmdr_multiplex = -1;           /* CmdR_multiplex */
static int hf_h245_sampleSize = -1;               /* INTEGER_1_255 */
static int hf_h245_samplesPerFrame = -1;          /* INTEGER_1_255 */
static int hf_h245_status = -1;                   /* T_status */
static int hf_h245_synchronized = -1;             /* NULL */
static int hf_h245_reconfiguration = -1;          /* NULL */
static int hf_h245_fns_cause = -1;                /* FunctionNotSupportedCause */
static int hf_h245_syntaxError = -1;              /* NULL */
static int hf_h245_semanticError = -1;            /* NULL */
static int hf_h245_unknownFunction = -1;          /* NULL */
static int hf_h245_returnedFunction = -1;         /* T_returnedFunction */
static int hf_h245_sbeNumber = -1;                /* INTEGER_0_9 */
static int hf_h245_terminalNumberAssign = -1;     /* TerminalLabel */
static int hf_h245_terminalJoinedConference = -1;  /* TerminalLabel */
static int hf_h245_terminalLeftConference = -1;   /* TerminalLabel */
static int hf_h245_seenByAtLeastOneOther = -1;    /* NULL */
static int hf_h245_cancelSeenByAtLeastOneOther = -1;  /* NULL */
static int hf_h245_seenByAll = -1;                /* NULL */
static int hf_h245_cancelSeenByAll = -1;          /* NULL */
static int hf_h245_terminalYouAreSeeing = -1;     /* TerminalLabel */
static int hf_h245_requestForFloor = -1;          /* NULL */
static int hf_h245_withdrawChairToken = -1;       /* NULL */
static int hf_h245_floorRequested = -1;           /* TerminalLabel */
static int hf_h245_terminalYouAreSeeingInSubPictureNumber = -1;  /* TerminalYouAreSeeingInSubPictureNumber */
static int hf_h245_videoIndicateCompose = -1;     /* VideoIndicateCompose */
static int hf_h245_masterMCU = -1;                /* NULL */
static int hf_h245_cancelMasterMCU = -1;          /* NULL */
static int hf_h245_subPictureNumber = -1;         /* INTEGER_0_255 */
static int hf_h245_compositionNumber = -1;        /* INTEGER_0_255 */
static int hf_h245_mi_type = -1;                  /* Mi_type */
static int hf_h245_logicalChannelActive = -1;     /* NULL */
static int hf_h245_logicalChannelInactive = -1;   /* NULL */
static int hf_h245_multipointConference = -1;     /* NULL */
static int hf_h245_cancelMultipointConference = -1;  /* NULL */
static int hf_h245_multipointZeroComm = -1;       /* NULL */
static int hf_h245_cancelMultipointZeroComm = -1;  /* NULL */
static int hf_h245_multipointSecondaryStatus = -1;  /* NULL */
static int hf_h245_cancelMultipointSecondaryStatus = -1;  /* NULL */
static int hf_h245_videoIndicateReadyToActivate = -1;  /* NULL */
static int hf_h245_videoNotDecodedMBs = -1;       /* T_videoNotDecodedMBs */
static int hf_h245_temporalReference_0_255 = -1;  /* INTEGER_0_255 */
static int hf_h245_estimatedReceivedJitterMantissa = -1;  /* INTEGER_0_3 */
static int hf_h245_estimatedReceivedJitterExponent = -1;  /* INTEGER_0_7 */
static int hf_h245_skippedFrameCount = -1;        /* INTEGER_0_15 */
static int hf_h245_additionalDecoderBuffer = -1;  /* INTEGER_0_262143 */
static int hf_h245_logicalChannelNumber1 = -1;    /* LogicalChannelNumber */
static int hf_h245_logicalChannelNumber2 = -1;    /* LogicalChannelNumber */
static int hf_h245_skew = -1;                     /* INTEGER_0_4095 */
static int hf_h245_maximumSkew = -1;              /* INTEGER_0_4095 */
static int hf_h245_signalAddress = -1;            /* TransportAddress */
static int hf_h245_vendor = -1;                   /* NonStandardIdentifier */
static int hf_h245_productNumber = -1;            /* OCTET_STRING_SIZE_1_256 */
static int hf_h245_versionNumber = -1;            /* OCTET_STRING_SIZE_1_256 */
static int hf_h245_ind_aal = -1;                  /* Ind_aal */
static int hf_h245_ind_aal1 = -1;                 /* Ind_aal1 */
static int hf_h245_ind_clockRecovery = -1;        /* Ind_clockRecovery */
static int hf_h245_ind_errorCorrection = -1;      /* Ind_errorCorrection */
static int hf_h245_ind_aal5 = -1;                 /* Ind_aal5 */
static int hf_h245_ind_multiplex = -1;            /* Ind_multiplex */
static int hf_h245_ind_reverseParameters = -1;    /* Ind_reverseParameters */
static int hf_h245_indr_multiplex = -1;           /* IndR_multiplex */
static int hf_h245_iv8 = -1;                      /* IV8 */
static int hf_h245_iv16 = -1;                     /* IV16 */
static int hf_h245_iv = -1;                       /* OCTET_STRING */
static int hf_h245_alphanumeric = -1;             /* GeneralString */
static int hf_h245_userInputSupportIndication = -1;  /* T_userInputSupportIndication */
static int hf_h245_signal = -1;                   /* T_signal */
static int hf_h245_signalType = -1;               /* T_signalType */
static int hf_h245_duration = -1;                 /* INTEGER_1_65535 */
static int hf_h245_rtp = -1;                      /* T_rtp */
static int hf_h245_timestamp = -1;                /* INTEGER_0_4294967295 */
static int hf_h245_expirationTime = -1;           /* INTEGER_0_4294967295 */
static int hf_h245_rtpPayloadIndication = -1;     /* NULL */
static int hf_h245_paramS = -1;                   /* Params */
static int hf_h245_encryptedSignalType = -1;      /* OCTET_STRING_SIZE_1 */
static int hf_h245_algorithmOID = -1;             /* OBJECT_IDENTIFIER */
static int hf_h245_signalUpdate = -1;             /* T_signalUpdate */
static int hf_h245_si_rtp = -1;                   /* Si_rtp */
static int hf_h245_extendedAlphanumeric = -1;     /* T_extendedAlphanumeric */
static int hf_h245_encrypted = -1;                /* OCTET_STRING */
static int hf_h245_encryptedAlphanumeric = -1;    /* EncryptedAlphanumeric */

/*--- End of included file: packet-h245-hf.c ---*/
//#line 389 "../../asn1/h245/packet-h245-template.c"

/* Initialize the subtree pointers */
static int ett_h245 = -1;
static int ett_h245_returnedFunction = -1;

/*--- Included file: packet-h245-ett.c ---*/
//#line 1 "../../asn1/h245/packet-h245-ett.c"
static gint ett_h245_MultimediaSystemControlMessage = -1;
static gint ett_h245_RequestMessage = -1;
static gint ett_h245_ResponseMessage = -1;
static gint ett_h245_CommandMessage = -1;
static gint ett_h245_IndicationMessage = -1;
static gint ett_h245_GenericMessage = -1;
static gint ett_h245_T_messageContent = -1;
static gint ett_h245_NonStandardMessage = -1;
static gint ett_h245_NonStandardParameter = -1;
static gint ett_h245_NonStandardIdentifier = -1;
static gint ett_h245_H221NonStandardID = -1;
static gint ett_h245_MasterSlaveDetermination = -1;
static gint ett_h245_MasterSlaveDeterminationAck = -1;
static gint ett_h245_T_decision = -1;
static gint ett_h245_MasterSlaveDeterminationReject = -1;
static gint ett_h245_MasterSlaveDeterminationRejectCause = -1;
static gint ett_h245_MasterSlaveDeterminationRelease = -1;
static gint ett_h245_TerminalCapabilitySet = -1;
static gint ett_h245_SET_SIZE_1_256_OF_CapabilityTableEntry = -1;
static gint ett_h245_SET_SIZE_1_256_OF_CapabilityDescriptor = -1;
static gint ett_h245_SEQUENCE_OF_GenericInformation = -1;
static gint ett_h245_CapabilityTableEntry = -1;
static gint ett_h245_CapabilityDescriptor = -1;
static gint ett_h245_SET_SIZE_1_256_OF_AlternativeCapabilitySet = -1;
static gint ett_h245_AlternativeCapabilitySet = -1;
static gint ett_h245_TerminalCapabilitySetAck = -1;
static gint ett_h245_TerminalCapabilitySetReject = -1;
static gint ett_h245_TerminalCapabilitySetRejectCause = -1;
static gint ett_h245_T_tableEntryCapacityExceeded = -1;
static gint ett_h245_TerminalCapabilitySetRelease = -1;
static gint ett_h245_Capability = -1;
static gint ett_h245_T_h233EncryptionReceiveCapability = -1;
static gint ett_h245_H235SecurityCapability = -1;
static gint ett_h245_MultiplexCapability = -1;
static gint ett_h245_H222Capability = -1;
static gint ett_h245_SET_OF_VCCapability = -1;
static gint ett_h245_VCCapability = -1;
static gint ett_h245_T_aal1 = -1;
static gint ett_h245_T_aal5 = -1;
static gint ett_h245_T_availableBitRates = -1;
static gint ett_h245_Avb_type = -1;
static gint ett_h245_T_rangeOfBitRates = -1;
static gint ett_h245_T_aal1ViaGateway = -1;
static gint ett_h245_SET_SIZE_1_256_OF_Q2931Address = -1;
static gint ett_h245_H223Capability = -1;
static gint ett_h245_T_h223MultiplexTableCapability = -1;
static gint ett_h245_T_enhanced = -1;
static gint ett_h245_T_mobileOperationTransmitCapability = -1;
static gint ett_h245_T_mobileMultilinkFrameCapability = -1;
static gint ett_h245_H223AnnexCCapability = -1;
static gint ett_h245_V76Capability = -1;
static gint ett_h245_V75Capability = -1;
static gint ett_h245_H2250Capability = -1;
static gint ett_h245_T_mcCapability = -1;
static gint ett_h245_SEQUENCE_SIZE_1_256_OF_RedundancyEncodingCapability = -1;
static gint ett_h245_MediaPacketizationCapability = -1;
static gint ett_h245_SEQUENCE_SIZE_1_256_OF_RTPPayloadType = -1;
static gint ett_h245_RSVPParameters = -1;
static gint ett_h245_QOSMode = -1;
static gint ett_h245_ATMParameters = -1;
static gint ett_h245_ServicePriorityValue = -1;
static gint ett_h245_ServicePriority = -1;
static gint ett_h245_AuthorizationParameters = -1;
static gint ett_h245_QOSType = -1;
static gint ett_h245_QOSClass = -1;
static gint ett_h245_QOSDescriptor = -1;
static gint ett_h245_GenericTransportParameters = -1;
static gint ett_h245_QOSCapability = -1;
static gint ett_h245_MediaTransportType = -1;
static gint ett_h245_T_atm_AAL5_compressed = -1;
static gint ett_h245_MediaChannelCapability = -1;
static gint ett_h245_TransportCapability = -1;
static gint ett_h245_SEQUENCE_SIZE_1_256_OF_QOSCapability = -1;
static gint ett_h245_SEQUENCE_SIZE_1_256_OF_MediaChannelCapability = -1;
static gint ett_h245_RedundancyEncodingCapability = -1;
static gint ett_h245_SEQUENCE_SIZE_1_256_OF_CapabilityTableEntryNumber = -1;
static gint ett_h245_RedundancyEncodingMethod = -1;
static gint ett_h245_RTPH263VideoRedundancyEncoding = -1;
static gint ett_h245_T_frameToThreadMapping = -1;
static gint ett_h245_SEQUENCE_SIZE_1_256_OF_RTPH263VideoRedundancyFrameMapping = -1;
static gint ett_h245_T_containedThreads = -1;
static gint ett_h245_RTPH263VideoRedundancyFrameMapping = -1;
static gint ett_h245_T_frameSequence = -1;
static gint ett_h245_MultipointCapability = -1;
static gint ett_h245_SEQUENCE_OF_MediaDistributionCapability = -1;
static gint ett_h245_MediaDistributionCapability = -1;
static gint ett_h245_SEQUENCE_OF_DataApplicationCapability = -1;
static gint ett_h245_VideoCapability = -1;
static gint ett_h245_ExtendedVideoCapability = -1;
static gint ett_h245_SEQUENCE_OF_VideoCapability = -1;
static gint ett_h245_SEQUENCE_OF_GenericCapability = -1;
static gint ett_h245_H261VideoCapability = -1;
static gint ett_h245_H262VideoCapability = -1;
static gint ett_h245_H263VideoCapability = -1;
static gint ett_h245_EnhancementLayerInfo = -1;
static gint ett_h245_SET_SIZE_1_14_OF_EnhancementOptions = -1;
static gint ett_h245_SET_SIZE_1_14_OF_BEnhancementParameters = -1;
static gint ett_h245_BEnhancementParameters = -1;
static gint ett_h245_EnhancementOptions = -1;
static gint ett_h245_H263Options = -1;
static gint ett_h245_SET_SIZE_1_16_OF_CustomPictureClockFrequency = -1;
static gint ett_h245_SET_SIZE_1_16_OF_CustomPictureFormat = -1;
static gint ett_h245_SET_SIZE_1_16_OF_H263VideoModeCombos = -1;
static gint ett_h245_TransparencyParameters = -1;
static gint ett_h245_RefPictureSelection = -1;
static gint ett_h245_T_additionalPictureMemory = -1;
static gint ett_h245_T_videoBackChannelSend = -1;
static gint ett_h245_T_enhancedReferencePicSelect = -1;
static gint ett_h245_T_subPictureRemovalParameters = -1;
static gint ett_h245_CustomPictureClockFrequency = -1;
static gint ett_h245_CustomPictureFormat = -1;
static gint ett_h245_T_mPI = -1;
static gint ett_h245_T_customPCF = -1;
static gint ett_h245_T_customPCF_item = -1;
static gint ett_h245_T_pixelAspectInformation = -1;
static gint ett_h245_T_pixelAspectCode = -1;
static gint ett_h245_T_extendedPAR = -1;
static gint ett_h245_T_extendedPAR_item = -1;
static gint ett_h245_H263VideoModeCombos = -1;
static gint ett_h245_SET_SIZE_1_16_OF_H263ModeComboFlags = -1;
static gint ett_h245_H263ModeComboFlags = -1;
static gint ett_h245_H263Version3Options = -1;
static gint ett_h245_IS11172VideoCapability = -1;
static gint ett_h245_AudioCapability = -1;
static gint ett_h245_T_g7231 = -1;
static gint ett_h245_G729Extensions = -1;
static gint ett_h245_G7231AnnexCCapability = -1;
static gint ett_h245_G723AnnexCAudioMode = -1;
static gint ett_h245_IS11172AudioCapability = -1;
static gint ett_h245_IS13818AudioCapability = -1;
static gint ett_h245_GSMAudioCapability = -1;
static gint ett_h245_VBDCapability = -1;
static gint ett_h245_DataApplicationCapability = -1;
static gint ett_h245_Application = -1;
static gint ett_h245_T_t84 = -1;
static gint ett_h245_Nlpid = -1;
static gint ett_h245_T_t38fax = -1;
static gint ett_h245_DataProtocolCapability = -1;
static gint ett_h245_T_v76wCompression = -1;
static gint ett_h245_CompressionType = -1;
static gint ett_h245_V42bis = -1;
static gint ett_h245_T84Profile = -1;
static gint ett_h245_T_t84Restricted = -1;
static gint ett_h245_T38FaxProfile = -1;
static gint ett_h245_T38FaxRateManagement = -1;
static gint ett_h245_T38FaxUdpOptions = -1;
static gint ett_h245_T_t38FaxUdpEC = -1;
static gint ett_h245_T38FaxTcpOptions = -1;
static gint ett_h245_EncryptionAuthenticationAndIntegrity = -1;
static gint ett_h245_EncryptionCapability = -1;
static gint ett_h245_MediaEncryptionAlgorithm = -1;
static gint ett_h245_AuthenticationCapability = -1;
static gint ett_h245_IntegrityCapability = -1;
static gint ett_h245_UserInputCapability = -1;
static gint ett_h245_SEQUENCE_SIZE_1_16_OF_NonStandardParameter = -1;
static gint ett_h245_ConferenceCapability = -1;
static gint ett_h245_SEQUENCE_OF_NonStandardParameter = -1;
static gint ett_h245_GenericCapability = -1;
static gint ett_h245_T_collapsing = -1;
static gint ett_h245_T_nonCollapsing = -1;
static gint ett_h245_CapabilityIdentifier = -1;
static gint ett_h245_GenericParameter = -1;
static gint ett_h245_SEQUENCE_OF_ParameterIdentifier = -1;
static gint ett_h245_ParameterIdentifier = -1;
static gint ett_h245_ParameterValue = -1;
static gint ett_h245_SEQUENCE_OF_GenericParameter = -1;
static gint ett_h245_MultiplexedStreamCapability = -1;
static gint ett_h245_MultiplexFormat = -1;
static gint ett_h245_AudioTelephonyEventCapability = -1;
static gint ett_h245_AudioToneCapability = -1;
static gint ett_h245_NoPTAudioTelephonyEventCapability = -1;
static gint ett_h245_NoPTAudioToneCapability = -1;
static gint ett_h245_MultiplePayloadStreamCapability = -1;
static gint ett_h245_DepFECCapability = -1;
static gint ett_h245_FECC_rfc2733 = -1;
static gint ett_h245_T_separateStreamBool = -1;
static gint ett_h245_FECCapability = -1;
static gint ett_h245_Rfc2733Format = -1;
static gint ett_h245_OpenLogicalChannel = -1;
static gint ett_h245_T_forwardLogicalChannelParameters = -1;
static gint ett_h245_OLC_forw_multiplexParameters = -1;
static gint ett_h245_OLC_reverseLogicalChannelParameters = -1;
static gint ett_h245_OLC_rev_multiplexParameters = -1;
static gint ett_h245_NetworkAccessParameters = -1;
static gint ett_h245_T_distribution = -1;
static gint ett_h245_T_networkAddress = -1;
static gint ett_h245_T_t120SetupProcedure = -1;
static gint ett_h245_Q2931Address = -1;
static gint ett_h245_T_address = -1;
static gint ett_h245_V75Parameters = -1;
static gint ett_h245_DataType = -1;
static gint ett_h245_H235Media = -1;
static gint ett_h245_T_mediaType = -1;
static gint ett_h245_MultiplexedStreamParameter = -1;
static gint ett_h245_H222LogicalChannelParameters = -1;
static gint ett_h245_H223LogicalChannelParameters = -1;
static gint ett_h245_T_adaptationLayerType = -1;
static gint ett_h245_Al3 = -1;
static gint ett_h245_H223AL1MParameters = -1;
static gint ett_h245_T_transferMode = -1;
static gint ett_h245_AL1HeaderFEC = -1;
static gint ett_h245_AL1CrcLength = -1;
static gint ett_h245_ArqType = -1;
static gint ett_h245_H223AL2MParameters = -1;
static gint ett_h245_AL2HeaderFEC = -1;
static gint ett_h245_H223AL3MParameters = -1;
static gint ett_h245_T_headerFormat = -1;
static gint ett_h245_AL3CrcLength = -1;
static gint ett_h245_H223AnnexCArqParameters = -1;
static gint ett_h245_T_numberOfRetransmissions = -1;
static gint ett_h245_V76LogicalChannelParameters = -1;
static gint ett_h245_T_suspendResume = -1;
static gint ett_h245_V76LCP_mode = -1;
static gint ett_h245_T_eRM = -1;
static gint ett_h245_T_recovery = -1;
static gint ett_h245_V76HDLCParameters = -1;
static gint ett_h245_CRCLength = -1;
static gint ett_h245_H2250LogicalChannelParameters = -1;
static gint ett_h245_T_mediaPacketization = -1;
static gint ett_h245_RTPPayloadType = -1;
static gint ett_h245_T_payloadDescriptor = -1;
static gint ett_h245_RedundancyEncoding = -1;
static gint ett_h245_T_rtpRedundancyEncoding = -1;
static gint ett_h245_SEQUENCE_OF_RedundancyEncodingElement = -1;
static gint ett_h245_RedundancyEncodingElement = -1;
static gint ett_h245_MultiplePayloadStream = -1;
static gint ett_h245_SEQUENCE_OF_MultiplePayloadStreamElement = -1;
static gint ett_h245_MultiplePayloadStreamElement = -1;
static gint ett_h245_DepFECData = -1;
static gint ett_h245_RFC2733Data = -1;
static gint ett_h245_FECdata_mode = -1;
static gint ett_h245_DepSeparateStream = -1;
static gint ett_h245_T_differentPort = -1;
static gint ett_h245_T_samePort = -1;
static gint ett_h245_FECData = -1;
static gint ett_h245_T_rfc2733 = -1;
static gint ett_h245_T_pktMode = -1;
static gint ett_h245_T_mode_rfc2733sameport = -1;
static gint ett_h245_T_mode_rfc2733diffport = -1;
static gint ett_h245_TransportAddress = -1;
static gint ett_h245_UnicastAddress = -1;
static gint ett_h245_T_iPAddress = -1;
static gint ett_h245_T_iPXAddress = -1;
static gint ett_h245_T_iP6Address = -1;
static gint ett_h245_T_iPSourceRouteAddress = -1;
static gint ett_h245_T_routing = -1;
static gint ett_h245_T_route = -1;
static gint ett_h245_MulticastAddress = -1;
static gint ett_h245_MIPAddress = -1;
static gint ett_h245_MIP6Address = -1;
static gint ett_h245_EncryptionSync = -1;
static gint ett_h245_SEQUENCE_SIZE_1_256_OF_EscrowData = -1;
static gint ett_h245_EscrowData = -1;
static gint ett_h245_OpenLogicalChannelAck = -1;
static gint ett_h245_OLC_ack_reverseLogicalChannelParameters = -1;
static gint ett_h245_T_olc_ack_multiplexParameters = -1;
static gint ett_h245_T_forwardMultiplexAckParameters = -1;
static gint ett_h245_OpenLogicalChannelReject = -1;
static gint ett_h245_OpenLogicalChannelRejectCause = -1;
static gint ett_h245_OpenLogicalChannelConfirm = -1;
static gint ett_h245_H2250LogicalChannelAckParameters = -1;
static gint ett_h245_CloseLogicalChannel = -1;
static gint ett_h245_T_cLC_source = -1;
static gint ett_h245_Clc_reason = -1;
static gint ett_h245_CloseLogicalChannelAck = -1;
static gint ett_h245_RequestChannelClose = -1;
static gint ett_h245_T_reason = -1;
static gint ett_h245_RequestChannelCloseAck = -1;
static gint ett_h245_RequestChannelCloseReject = -1;
static gint ett_h245_RequestChannelCloseRejectCause = -1;
static gint ett_h245_RequestChannelCloseRelease = -1;
static gint ett_h245_MultiplexEntrySend = -1;
static gint ett_h245_SET_SIZE_1_15_OF_MultiplexEntryDescriptor = -1;
static gint ett_h245_MultiplexEntryDescriptor = -1;
static gint ett_h245_T_elementList = -1;
static gint ett_h245_MultiplexElement = -1;
static gint ett_h245_Me_type = -1;
static gint ett_h245_T_subElementList = -1;
static gint ett_h245_ME_repeatCount = -1;
static gint ett_h245_MultiplexEntrySendAck = -1;
static gint ett_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber = -1;
static gint ett_h245_MultiplexEntrySendReject = -1;
static gint ett_h245_SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions = -1;
static gint ett_h245_MultiplexEntryRejectionDescriptions = -1;
static gint ett_h245_MultiplexEntryRejectionDescriptionsCause = -1;
static gint ett_h245_MultiplexEntrySendRelease = -1;
static gint ett_h245_RequestMultiplexEntry = -1;
static gint ett_h245_RequestMultiplexEntryAck = -1;
static gint ett_h245_RequestMultiplexEntryReject = -1;
static gint ett_h245_SET_SIZE_1_15_OF_RequestMultiplexEntryRejectionDescriptions = -1;
static gint ett_h245_RequestMultiplexEntryRejectionDescriptions = -1;
static gint ett_h245_RequestMultiplexEntryRejectionDescriptionsCause = -1;
static gint ett_h245_RequestMultiplexEntryRelease = -1;
static gint ett_h245_RequestMode = -1;
static gint ett_h245_SEQUENCE_SIZE_1_256_OF_ModeDescription = -1;
static gint ett_h245_RequestModeAck = -1;
static gint ett_h245_Req_mode_ack_response = -1;
static gint ett_h245_RequestModeReject = -1;
static gint ett_h245_RequestModeRejectCause = -1;
static gint ett_h245_RequestModeRelease = -1;
static gint ett_h245_ModeDescription = -1;
static gint ett_h245_ModeElementType = -1;
static gint ett_h245_ModeElement = -1;
static gint ett_h245_H235Mode = -1;
static gint ett_h245_T_mediaMode = -1;
static gint ett_h245_MultiplexedStreamModeParameters = -1;
static gint ett_h245_RedundancyEncodingDTMode = -1;
static gint ett_h245_SEQUENCE_OF_RedundancyEncodingDTModeElement = -1;
static gint ett_h245_RedundancyEncodingDTModeElement = -1;
static gint ett_h245_Re_type = -1;
static gint ett_h245_MultiplePayloadStreamMode = -1;
static gint ett_h245_SEQUENCE_OF_MultiplePayloadStreamElementMode = -1;
static gint ett_h245_MultiplePayloadStreamElementMode = -1;
static gint ett_h245_DepFECMode = -1;
static gint ett_h245_T_rfc2733Mode = -1;
static gint ett_h245_FEC_mode = -1;
static gint ett_h245_FECMode = -1;
static gint ett_h245_H223ModeParameters = -1;
static gint ett_h245_AdaptationLayerType = -1;
static gint ett_h245_V76ModeParameters = -1;
static gint ett_h245_H2250ModeParameters = -1;
static gint ett_h245_RedundancyEncodingMode = -1;
static gint ett_h245_T_secondaryEncodingMode = -1;
static gint ett_h245_VideoMode = -1;
static gint ett_h245_H261VideoMode = -1;
static gint ett_h245_H261Resolution = -1;
static gint ett_h245_H262VideoMode = -1;
static gint ett_h245_T_profileAndLevel = -1;
static gint ett_h245_H263VideoMode = -1;
static gint ett_h245_H263Resolution = -1;
static gint ett_h245_IS11172VideoMode = -1;
static gint ett_h245_AudioMode = -1;
static gint ett_h245_Mode_g7231 = -1;
static gint ett_h245_IS11172AudioMode = -1;
static gint ett_h245_T_audioLayer = -1;
static gint ett_h245_T_audioSampling = -1;
static gint ett_h245_IS11172_multichannelType = -1;
static gint ett_h245_IS13818AudioMode = -1;
static gint ett_h245_IS13818AudioLayer = -1;
static gint ett_h245_IS13818AudioSampling = -1;
static gint ett_h245_IS13818MultichannelType = -1;
static gint ett_h245_G7231AnnexCMode = -1;
static gint ett_h245_VBDMode = -1;
static gint ett_h245_DataMode = -1;
static gint ett_h245_DataModeApplication = -1;
static gint ett_h245_T38faxApp = -1;
static gint ett_h245_EncryptionMode = -1;
static gint ett_h245_RoundTripDelayRequest = -1;
static gint ett_h245_RoundTripDelayResponse = -1;
static gint ett_h245_MaintenanceLoopRequest = -1;
static gint ett_h245_Mlr_type = -1;
static gint ett_h245_MaintenanceLoopAck = -1;
static gint ett_h245_Mla_type = -1;
static gint ett_h245_MaintenanceLoopReject = -1;
static gint ett_h245_Mlrej_type = -1;
static gint ett_h245_MaintenanceLoopRejectCause = -1;
static gint ett_h245_MaintenanceLoopOffCommand = -1;
static gint ett_h245_CommunicationModeCommand = -1;
static gint ett_h245_SET_SIZE_1_256_OF_CommunicationModeTableEntry = -1;
static gint ett_h245_CommunicationModeRequest = -1;
static gint ett_h245_CommunicationModeResponse = -1;
static gint ett_h245_CommunicationModeTableEntry = -1;
static gint ett_h245_T_entryDataType = -1;
static gint ett_h245_ConferenceRequest = -1;
static gint ett_h245_T_requestTerminalCertificate = -1;
static gint ett_h245_CertSelectionCriteria = -1;
static gint ett_h245_Criteria = -1;
static gint ett_h245_TerminalLabel = -1;
static gint ett_h245_ConferenceResponse = -1;
static gint ett_h245_T_mCTerminalIDResponse = -1;
static gint ett_h245_T_terminalIDResponse = -1;
static gint ett_h245_T_conferenceIDResponse = -1;
static gint ett_h245_T_passwordResponse = -1;
static gint ett_h245_SET_SIZE_1_256_OF_TerminalLabel = -1;
static gint ett_h245_T_makeMeChairResponse = -1;
static gint ett_h245_T_extensionAddressResponse = -1;
static gint ett_h245_T_chairTokenOwnerResponse = -1;
static gint ett_h245_T_terminalCertificateResponse = -1;
static gint ett_h245_T_broadcastMyLogicalChannelResponse = -1;
static gint ett_h245_T_makeTerminalBroadcasterResponse = -1;
static gint ett_h245_T_sendThisSourceResponse = -1;
static gint ett_h245_RequestAllTerminalIDsResponse = -1;
static gint ett_h245_SEQUENCE_OF_TerminalInformation = -1;
static gint ett_h245_TerminalInformation = -1;
static gint ett_h245_RemoteMCRequest = -1;
static gint ett_h245_RemoteMCResponse = -1;
static gint ett_h245_T_reject = -1;
static gint ett_h245_MultilinkRequest = -1;
static gint ett_h245_CallInformationReq = -1;
static gint ett_h245_AddConnectionReq = -1;
static gint ett_h245_RemoveConnectionReq = -1;
static gint ett_h245_MaximumHeaderIntervalReq = -1;
static gint ett_h245_T_requestType = -1;
static gint ett_h245_MultilinkResponse = -1;
static gint ett_h245_CallInformationResp = -1;
static gint ett_h245_AddConnectionResp = -1;
static gint ett_h245_T_responseCode = -1;
static gint ett_h245_T_rejected = -1;
static gint ett_h245_RemoveConnectionResp = -1;
static gint ett_h245_MaximumHeaderIntervalResp = -1;
static gint ett_h245_MultilinkIndication = -1;
static gint ett_h245_T_crcDesired = -1;
static gint ett_h245_T_excessiveError = -1;
static gint ett_h245_DialingInformation = -1;
static gint ett_h245_SET_SIZE_1_65535_OF_DialingInformationNumber = -1;
static gint ett_h245_DialingInformationNumber = -1;
static gint ett_h245_SET_SIZE_1_255_OF_DialingInformationNetworkType = -1;
static gint ett_h245_DialingInformationNetworkType = -1;
static gint ett_h245_ConnectionIdentifier = -1;
static gint ett_h245_LogicalChannelRateRequest = -1;
static gint ett_h245_LogicalChannelRateAcknowledge = -1;
static gint ett_h245_LogicalChannelRateReject = -1;
static gint ett_h245_LogicalChannelRateRejectReason = -1;
static gint ett_h245_LogicalChannelRateRelease = -1;
static gint ett_h245_SendTerminalCapabilitySet = -1;
static gint ett_h245_T_specificRequest = -1;
static gint ett_h245_SET_SIZE_1_65535_OF_CapabilityTableEntryNumber = -1;
static gint ett_h245_SET_SIZE_1_256_OF_CapabilityDescriptorNumber = -1;
static gint ett_h245_EncryptionCommand = -1;
static gint ett_h245_T_encryptionAlgorithmID = -1;
static gint ett_h245_FlowControlCommand = -1;
static gint ett_h245_Scope = -1;
static gint ett_h245_Restriction = -1;
static gint ett_h245_EndSessionCommand = -1;
static gint ett_h245_T_gstnOptions = -1;
static gint ett_h245_T_isdnOptions = -1;
static gint ett_h245_ConferenceCommand = -1;
static gint ett_h245_SubstituteConferenceIDCommand = -1;
static gint ett_h245_EncryptionUpdateDirection = -1;
static gint ett_h245_MiscellaneousCommand = -1;
static gint ett_h245_Mc_type = -1;
static gint ett_h245_T_videoFastUpdateGOB = -1;
static gint ett_h245_T_videoFastUpdateMB = -1;
static gint ett_h245_T_progressiveRefinementStart = -1;
static gint ett_h245_T_repeatCount = -1;
static gint ett_h245_T_videoBadMBs = -1;
static gint ett_h245_SEQUENCE_OF_PictureReference = -1;
static gint ett_h245_T_lostPartialPicture = -1;
static gint ett_h245_T_encryptionUpdateCommand = -1;
static gint ett_h245_T_encryptionUpdateAck = -1;
static gint ett_h245_KeyProtectionMethod = -1;
static gint ett_h245_EncryptionUpdateRequest = -1;
static gint ett_h245_PictureReference = -1;
static gint ett_h245_H223MultiplexReconfiguration = -1;
static gint ett_h245_T_h223ModeChange = -1;
static gint ett_h245_T_h223AnnexADoubleFlag = -1;
static gint ett_h245_NewATMVCCommand = -1;
static gint ett_h245_Cmd_aal = -1;
static gint ett_h245_Cmd_aal1 = -1;
static gint ett_h245_Cmd_clockRecovery = -1;
static gint ett_h245_Cmd_errorCorrection = -1;
static gint ett_h245_Cmd_aal5 = -1;
static gint ett_h245_Cmd_multiplex = -1;
static gint ett_h245_Cmd_reverseParameters = -1;
static gint ett_h245_CmdR_multiplex = -1;
static gint ett_h245_MobileMultilinkReconfigurationCommand = -1;
static gint ett_h245_T_status = -1;
static gint ett_h245_FunctionNotUnderstood = -1;
static gint ett_h245_FunctionNotSupported = -1;
static gint ett_h245_FunctionNotSupportedCause = -1;
static gint ett_h245_ConferenceIndication = -1;
static gint ett_h245_TerminalYouAreSeeingInSubPictureNumber = -1;
static gint ett_h245_VideoIndicateCompose = -1;
static gint ett_h245_MiscellaneousIndication = -1;
static gint ett_h245_Mi_type = -1;
static gint ett_h245_T_videoNotDecodedMBs = -1;
static gint ett_h245_JitterIndication = -1;
static gint ett_h245_H223SkewIndication = -1;
static gint ett_h245_H2250MaximumSkewIndication = -1;
static gint ett_h245_MCLocationIndication = -1;
static gint ett_h245_VendorIdentification = -1;
static gint ett_h245_NewATMVCIndication = -1;
static gint ett_h245_Ind_aal = -1;
static gint ett_h245_Ind_aal1 = -1;
static gint ett_h245_Ind_clockRecovery = -1;
static gint ett_h245_Ind_errorCorrection = -1;
static gint ett_h245_Ind_aal5 = -1;
static gint ett_h245_Ind_multiplex = -1;
static gint ett_h245_Ind_reverseParameters = -1;
static gint ett_h245_IndR_multiplex = -1;
static gint ett_h245_Params = -1;
static gint ett_h245_UserInputIndication = -1;
static gint ett_h245_T_userInputSupportIndication = -1;
static gint ett_h245_T_signal = -1;
static gint ett_h245_T_rtp = -1;
static gint ett_h245_T_signalUpdate = -1;
static gint ett_h245_Si_rtp = -1;
static gint ett_h245_T_extendedAlphanumeric = -1;
static gint ett_h245_EncryptedAlphanumeric = -1;
static gint ett_h245_FlowControlIndication = -1;
static gint ett_h245_MobileMultilinkReconfigurationIndication = -1;

/*--- End of included file: packet-h245-ett.c ---*/
//#line 394 "../../asn1/h245/packet-h245-template.c"

/* Forward declarations */
static int dissect_h245_MultimediaSystemControlMessage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index );
static void reset_h245_pi(void *dummy )
{
	h245_pi = NULL; /* Make sure we don't leave ep_alloc()ated memory lying around */
}


/*--- Included file: packet-h245-fn.c ---*/
//#line 1 "../../asn1/h245/packet-h245-fn.c"
/*--- Cyclic dependencies ---*/

/* GenericParameter -> ParameterValue -> ParameterValue/genericParameter -> GenericParameter */
static int dissect_h245_GenericParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index );

/* VideoCapability -> ExtendedVideoCapability -> ExtendedVideoCapability/videoCapability -> VideoCapability */
static int dissect_h245_VideoCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index );

/* AudioCapability -> VBDCapability -> AudioCapability */
static int dissect_h245_AudioCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index );

/* DataType -> H235Media -> H235Media/mediaType -> RedundancyEncoding -> DataType */
/* DataType -> H235Media -> H235Media/mediaType -> RedundancyEncoding -> RedundancyEncoding/rtpRedundancyEncoding -> RedundancyEncodingElement -> DataType */
/* DataType -> H235Media -> H235Media/mediaType -> MultiplePayloadStream -> MultiplePayloadStream/elements -> MultiplePayloadStreamElement -> DataType */
static int dissect_h245_DataType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index );

/* MultiplexElement -> MultiplexElement/type -> MultiplexElement/type/subElementList -> MultiplexElement */
static int dissect_h245_MultiplexElement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index );

/* AudioMode -> VBDMode -> AudioMode */
static int dissect_h245_AudioMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index );

/* ModeElementType -> RedundancyEncodingDTMode -> RedundancyEncodingDTModeElement -> RedundancyEncodingDTModeElement/type -> FECMode -> ModeElementType */
/* ModeElementType -> MultiplePayloadStreamMode -> MultiplePayloadStreamMode/elements -> MultiplePayloadStreamElementMode -> ModeElementType */
static int dissect_h245_ModeElementType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index );
static gint
g_slist_length (GSList *list)
{
  gint length;

  length = 0;
  while (list)
    {
      length++;
      list = list->next;
    }

  return length;
}
static gboolean
compute_offset_length(const guint tvb_length_val, const guint tvb_reported_length_val,
		      const gint offset, const gint length_val,
		      guint *offset_ptr, guint *length_ptr, int *exception)
{
	//DISSECTOR_ASSERT(offset_ptr);
	//DISSECTOR_ASSERT(length_ptr);

	/* Compute the offset */
	if (offset >= 0) {
		/* Positive offset - relative to the beginning of the packet. */
		if ((guint) offset > tvb_reported_length_val) {
			if (exception) {
				*exception = ReportedBoundsError;
			}
			return FALSE;
		}
		else if ((guint) offset > tvb_length_val) {
			if (exception) {
				*exception = BoundsError;
			}
			return FALSE;
		}
		else {
			*offset_ptr = offset;
		}
	}
	else {
		/* Negative offset - relative to the end of the packet. */
		if ((guint) -offset > tvb_reported_length_val) {
			if (exception) {
				*exception = ReportedBoundsError;
			}
			return FALSE;
		}
		else if ((guint) -offset > tvb_length_val) {
			if (exception) {
				*exception = BoundsError;
			}
			return FALSE;
		}
		else {
			*offset_ptr = tvb_length_val + offset;
		}
	}

	/* Compute the length */
	if (length_val < -1) {
		if (exception) {
			/* XXX - ReportedBoundsError? */
			*exception = BoundsError;
		}
		return FALSE;
	}
	else if (length_val == -1) {
		*length_ptr = tvb_length_val - *offset_ptr;
	}
	else {
		*length_ptr = length_val;
	}

	return TRUE;
}
static gboolean
check_offset_length_no_exception(const guint tvb_length_val, const guint tvb_reported_length_val,
				 const gint offset, gint const length_val,
				 guint *offset_ptr, guint *length_ptr, int *exception)
{
	guint	end_offset;

	if (!compute_offset_length(tvb_length_val, tvb_reported_length_val,
				   offset, length_val, offset_ptr, length_ptr, exception)) {
		return FALSE;
	}

	/*
	 * Compute the offset of the first byte past the length.
	 */
	end_offset = *offset_ptr + *length_ptr;

	/*
	 * Check for an overflow, and clamp "end_offset" at the maximum
	 * if we got an overflow - that should force us to indicate that
	 * we're past the end of the tvbuff.
	 */
	if (end_offset < *offset_ptr)
		end_offset = UINT_MAX;

	/*
	 * Check whether that offset goes more than one byte past the
	 * end of the buffer.
	 *
	 * If not, return TRUE; otherwise, return FALSE and, if "exception"
	 * is non-null, return the appropriate exception through it.
	 */
	if (end_offset <= tvb_length_val) {
		return TRUE;
	}
	else if (end_offset <= tvb_reported_length_val) {
		if (exception) {
			*exception = BoundsError;
		}
	}
	else {
		if (exception) {
			*exception = ReportedBoundsError;
		}
	}

	return FALSE;
}
static GSList*
g_slist_nth (GSList *list,
	     gint    n)
{
  while ((n-- > 0) && list)
    list = list->next;

  return list;
}
static void
check_offset_length(const guint tvb_length_val, const guint tvb_reported_length_val,
		    const gint offset, gint const length_val,
		    guint *offset_ptr, guint *length_ptr)
{
	int exception = 0;

	if (!check_offset_length_no_exception(tvb_length_val, tvb_reported_length_val,
					      offset, length_val, offset_ptr, length_ptr, &exception)) {
		//DISSECTOR_ASSERT(exception > 0);
		//THROW(exception);
	}
}
static void*
composite_memcpy(tvbuff_t *tvb, guint8* target, guint abs_offset, size_t abs_length)
{
	guint	    i, num_members;
	tvb_comp_t *composite;
	tvbuff_t   *member_tvb = NULL;
	guint	    member_offset, member_length;
	gboolean    retval;
	GSList	   *slist;

	//DISSECTOR_ASSERT(tvb->type == TVBUFF_COMPOSITE);

	/* Maybe the range specified by offset/length
	 * is contiguous inside one of the member tvbuffs */
	composite   = &tvb->tvbuffs.composite;
	num_members = g_slist_length(composite->tvbs);

	for (i = 0; i < num_members; i++) {
		if (abs_offset <= composite->end_offsets[i]) {
			slist = g_slist_nth(composite->tvbs, i);
			member_tvb = (tvbuff_t*)slist->data;
			break;
		}
	}
	//DISSECTOR_ASSERT(member_tvb);

	if (check_offset_length_no_exception(member_tvb->length, member_tvb->reported_length, abs_offset - composite->start_offsets[i],
				(gint) abs_length, &member_offset, &member_length, NULL)) {

		//DISSECTOR_ASSERT(!tvb->real_data);
		return tvb_memcpy(member_tvb, target, member_offset, member_length);
	}
	else {
		/* The requested data is non-contiguous inside
		 * the member tvb. We have to memcpy() the part that's in the member tvb,
		 * then iterate across the other member tvb's, copying their portions
		 * until we have copied all data.
		 */
		retval = compute_offset_length(member_tvb->length, member_tvb->reported_length, abs_offset - composite->start_offsets[i], -1,
				&member_offset, &member_length, NULL);
		//DISSECTOR_ASSERT(retval);

		/* composite_memcpy() can't handle a member_length of zero.  */
		//DISSECTOR_ASSERT(member_length);

		tvb_memcpy(member_tvb, target, member_offset, member_length);
		abs_offset	+= member_length;
		abs_length	-= member_length;

		/* Recurse */
		if (abs_length > 0) {
			composite_memcpy(tvb, target + member_length, abs_offset, abs_length);
		}

		return target;
	}

	//DISSECTOR_ASSERT_NOT_REACHED();
}
static void*
tvb_memcpy(tvbuff_t *tvb, guint8* target, const gint offset, size_t length)
{
	guint	abs_offset, abs_length;

	//DISSECTOR_ASSERT(tvb && tvb->initialized);

	/*
	 * XXX - we should eliminate the "length = -1 means 'to the end
	 * of the tvbuff'" convention, and use other means to achieve
	 * that; this would let us eliminate a bunch of checks for
	 * negative lengths in cases where the protocol has a 32-bit
	 * length field.
	 *
	 * Allowing -1 but throwing an assertion on other negative
	 * lengths is a bit more work with the length being a size_t;
	 * instead, we check for a length <= 2^31-1.
	 */
	//DISSECTOR_ASSERT(length <= 0x7FFFFFFF);
	check_offset_length(tvb->length, tvb->reported_length, offset, (gint) length, &abs_offset, &abs_length);

	if (tvb->real_data) {
		return memcpy(target, tvb->real_data + abs_offset, abs_length);
	}

	switch(tvb->type) {
		case TVBUFF_REAL_DATA:
			//DISSECTOR_ASSERT_NOT_REACHED();

		case TVBUFF_SUBSET:
			return tvb_memcpy(tvb->tvbuffs.subset.tvb, target,
					abs_offset - tvb->tvbuffs.subset.offset,
					abs_length);

		case TVBUFF_COMPOSITE:
			return composite_memcpy(tvb, target, offset, length);
	}

	//DISSECTOR_ASSERT_NOT_REACHED();
	return NULL;
}

static void*
tvb_memdup(tvbuff_t *tvb, const gint offset, size_t length)
{
	guint	abs_offset, abs_length;
	void	*duped;

	//DISSECTOR_ASSERT(tvb && tvb->initialized);

	check_offset_length(tvb->length, tvb->reported_length, offset, (gint) length, &abs_offset, &abs_length);

	//duped = g_malloc(abs_length);
	duped = malloc(abs_length);
	return tvb_memcpy(tvb,(guint8*) duped, abs_offset, abs_length);
}
static const guint8*
composite_ensure_contiguous_no_exception(tvbuff_t *tvb, const guint abs_offset, const guint abs_length)
{
	guint	    i, num_members;
	tvb_comp_t *composite;
	tvbuff_t   *member_tvb = NULL;
	guint	    member_offset, member_length;
	GSList	   *slist;

	//DISSECTOR_ASSERT(tvb->type == TVBUFF_COMPOSITE);

	/* Maybe the range specified by offset/length
	 * is contiguous inside one of the member tvbuffs */
	composite = &tvb->tvbuffs.composite;
	num_members = g_slist_length(composite->tvbs);

	for (i = 0; i < num_members; i++) {
		if (abs_offset <= composite->end_offsets[i]) {
			slist = g_slist_nth(composite->tvbs, i);
			member_tvb = (tvbuff_t*)slist->data;
			break;
		}
	}
	//DISSECTOR_ASSERT(member_tvb);

	if (check_offset_length_no_exception(member_tvb->length, member_tvb->reported_length,
					     abs_offset - composite->start_offsets[i],
					     abs_length, &member_offset, &member_length, NULL)) {

		/*
		 * The range is, in fact, contiguous within member_tvb.
		 */
		//DISSECTOR_ASSERT(!tvb->real_data);
		return ensure_contiguous_no_exception(member_tvb, member_offset, member_length, NULL);
	}
	else {
		tvb->real_data =(const guint8*) tvb_memdup(tvb, 0, -1);
		return tvb->real_data + abs_offset;
	}

	//DISSECTOR_ASSERT_NOT_REACHED();
}

static const guint8*
ensure_contiguous_no_exception(tvbuff_t *tvb, const gint offset, const gint length, int *exception)
{
	guint abs_offset, abs_length;

	if (!check_offset_length_no_exception(tvb->length, tvb->reported_length, offset, length,
		&abs_offset, &abs_length, exception)) {
		return NULL;
	}

	/*
	 * We know that all the data is present in the tvbuff, so
	 * no exceptions should be thrown.
	 */
	if (tvb->real_data) {
		return tvb->real_data + abs_offset;
	}
	else {
		switch(tvb->type) {
			case TVBUFF_REAL_DATA:
				//DISSECTOR_ASSERT_NOT_REACHED();
			case TVBUFF_SUBSET:
				return ensure_contiguous_no_exception(tvb->tvbuffs.subset.tvb,
						abs_offset - tvb->tvbuffs.subset.offset,
						abs_length, NULL);
			case TVBUFF_COMPOSITE:
				return composite_ensure_contiguous_no_exception(tvb, abs_offset, abs_length);
		}
	}

	//DISSECTOR_ASSERT_NOT_REACHED();
	return NULL;
}


static const guint8*
ensure_contiguous(tvbuff_t *tvb, const gint offset, const gint length)
{
	int           exception = 0;
	const guint8 *p;

	p = ensure_contiguous_no_exception(tvb, offset, length, &exception);
	if (p == NULL) {
		//DISSECTOR_ASSERT(exception > 0);
		//THROW(exception);
	}
	return p;
}

static const guint8*
fast_ensure_contiguous(tvbuff_t *tvb, const gint offset, const guint length)
{
	guint end_offset;
	guint u_offset;

	//DISSECTOR_ASSERT(tvb && tvb->initialized);
	/* We don't check for overflow in this fast path so we only handle simple types */
	//DISSECTOR_ASSERT(length <= 8);

	if (offset < 0 || !tvb->real_data) {
		return ensure_contiguous(tvb, offset, length);
	}

	u_offset = offset;
	end_offset = u_offset + length;

	if (end_offset <= tvb->length) {
		return tvb->real_data + u_offset;
	}

	if (end_offset > tvb->reported_length) {
		//THROW(ReportedBoundsError);
		fprintf(stderr,"Error occured in fast_ensure_contiguous");
	}
	//THROW(BoundsError);
	/* not reached */
	return NULL;
}

static guint8
tvb_get_guint8(tvbuff_t *tvb, const gint offset)
{
	const guint8 *ptr;
	ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint8));
	return *ptr;
}
gint
tvb_memeql(tvbuff_t *tvb, const gint offset, const guint8 *str, size_t size)
{
	const guint8 *ptr;

	ptr = ensure_contiguous_no_exception(tvb, offset, (gint) size, NULL);

	if (ptr) {
		int cmp = memcmp(ptr, str, size);

		/*
		 * Return 0 if equal, -1 otherwise.
		 */
		return (cmp == 0 ? 0 : -1);
	} else {
		/*
		 * Not enough characters in the tvbuff to match the
		 * string.
		 */
		return -1;
	}
}
static gint
tvb_length_remaining(const tvbuff_t *tvb, const gint offset)
{
	guint abs_offset, abs_length;

	//DISSECTOR_ASSERT(tvb && tvb->initialized);

	if (compute_offset_length(tvb->length, tvb->reported_length, offset, -1, &abs_offset, &abs_length, NULL)) {
		return abs_length;
	}
	else {
		return -1;
	}
}
static gint
tvb_reported_length_remaining(const tvbuff_t *tvb, const gint offset)
{
	guint abs_offset, abs_length;

	//DISSECTOR_ASSERT(tvb && tvb->initialized);

	if (compute_offset_length(tvb->length, tvb->reported_length, offset, -1, &abs_offset, &abs_length, NULL)) {
		if (tvb->reported_length >= abs_offset)
			return tvb->reported_length - abs_offset;
		else
			return -1;
	}
	else {
		return -1;
	}
}
static guint
tvb_length(const tvbuff_t* tvb)
{
	//DISSECTOR_ASSERT(tvb && tvb->initialized);

	return tvb->length;
}
/* this function reads a single bit */
guint32
dissect_per_boolean(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gboolean *bool_val)
{
	guint8 ch, mask;
	gboolean value;
	header_field_info *hfi;

////DEBUG_ENTRY("dissect_per_boolean");
	ch=tvb_get_guint8(tvb, offset>>3);
	mask=1<<(7-(offset&0x07));
	if(ch&mask){
		value=1;
	} else {
		value=0;
	}
if(hf_index!=-1){
		char *str;
		//hfi = proto_registrar_get_nth(hf_index);
		str=ep_strdup_printf("%c%c%c%c %c%c%c%c %s: %s",
			mask&0x80?'0'+value:'.',
			mask&0x40?'0'+value:'.',
			mask&0x20?'0'+value:'.',
			mask&0x10?'0'+value:'.',
			mask&0x08?'0'+value:'.',
			mask&0x04?'0'+value:'.',
			mask&0x02?'0'+value:'.',
			mask&0x01?'0'+value:'.',
			/*hfi->name,*/
			value?"True":"False"
		);
	//	actx->created_item = proto_tree_add_boolean_format(tree, hf_index, tvb, offset>>3, 1, value, 
		
		printf("%s", str);
	} else {
	//	actx->created_item = NULL;
	}

	if(bool_val){
		*bool_val=value;
	


	}
	h_245_message_value.true_false=value;
	h_225_message_value.true_false=value;
	return offset+1;
}
guint32
dissect_per_length_determinant(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, guint32 *length)
{
	guint8 byte;
	guint32 len;
	//proto_item *pi;
	int num_bits;
	int i, bit, str_length, str_index;
	gboolean tmp;

	if(!length){
		length=&len;
	}

	/* byte aligned */
	if (actx->aligned){
		BYTE_ALIGN_OFFSET(offset);
		byte=tvb_get_guint8(tvb, offset>>3);
		offset+=8;
	}else{
		char *str;
		guint32 val;

		val = 0;

		/* prepare the string (max number of bits + quartet separators + prepended space) */
		str_length = 256+64+1;
		str=(char*)malloc(str_length+1);
		str_index = 0;

		str_length = /*g_*//*sn*/sprintf(str, (const char*)str_length+1, " ");
		for(bit=0;bit<((int)(offset&0x07));bit++){
			if(bit&&(!(bit%4))){
				if (str_index < str_length) str[str_index++] = ' ';
			}
			if (str_index < str_length) str[str_index++] = '.';
		}
		/* read the bits for the int */
		num_bits = 8;
		for(i=0;i<num_bits;i++){
			if(bit&&(!(bit%4))){
				if (str_index < str_length) str[str_index++] = ' ';
			}
			if(bit&&(!(bit%8))){
				if (str_index < str_length) str[str_index++] = ' ';
			}
			bit++;
			offset=dissect_per_boolean(tvb, offset, actx,/**/ -1, &tmp);
			val<<=1;
			if(tmp){
				val|=1;
				if (str_index < str_length) str[str_index++] = '1';
				if (i==0) { /* bit 8 is 1, so not a single byte length */
					num_bits = 16;
				}
				else if (i==1 && val==3) { /* bits 8 and 7 both 1, so unconstrained */
					*length = 0;
					//PER_NOT_DECODED_YET("10.9 Unconstrained");
					return offset;
				}
			} else {
				if (str_index < str_length) str[str_index++] = '0';
			}
		}
		str[str_index] = '\0'; /* Terminate string */
		printf(" %s\n", str);
		if((val&0x80)==0 && num_bits==8){
			*length = val;
			if(hf_index!=-1){
				//pi = proto_tree_add_uint(tree, hf_index, tvb, (offset>>3)-1, 1, *length);
				if (display_internal_per_fields)
					//proto_item_append_text(pi,
					printf(" %s\n", str);
				//else
					//PROTO_ITEM_SET_HIDDEN(pi);
			}

			return offset;
		}
		else if (num_bits==16) {
			*length = val&0x3fff;
			if(hf_index!=-1){
				//pi = proto_tree_add_uint(tree, hf_index, tvb, (offset>>3)-1, 1, *length);
				if (display_internal_per_fields)
					//proto_item_append_text(pi,
					printf(" %s\n", str);
				//else
					//PROTO_ITEM_SET_HIDDEN(pi);
			}

			return offset;
		}
		*length = 0;
		//PER_NOT_DECODED_YET("10.9 Unaligned");
		return offset;

	}

	/* 10.9.3.6 */
	if((byte&0x80)==0){
		*length=byte;
		if(hf_index!=-1){
			//pi = proto_tree_add_uint(tree, hf_index, tvb, (offset>>3)-1, 1, *length);
			//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(pi);
		}
		return offset;
	}

	/* 10.9.3.7 */
	if((byte&0xc0)==0x80){
		*length=(byte&0x3f);
		*length=((*length)<<8)+tvb_get_guint8(tvb, offset>>3);
		offset+=8;
		if(hf_index!=-1){
			//pi = proto_tree_add_uint(tree, hf_index, tvb, (offset>>3)-2, 2, *length);
			//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(pi);
		}
		return offset;
	}
	*length = 0;
	//PER_NOT_DECODED_YET("10.9.3.8.1");
	return offset;
}
static void
tvb_init(tvbuff_t *tvb, const tvbuff_type type)
{
	tvb_backing_t	*backing;
	tvb_comp_t	*composite;

	tvb->previous	     = NULL;
	tvb->next	     = NULL;
	tvb->type	     = type;
	tvb->initialized     = FALSE;
	tvb->length	     = 0;
	tvb->reported_length = 0;
	//tvb->free_cb	     = NULL;
	tvb->real_data	     = NULL;
	tvb->raw_offset	     = -1;
	tvb->ds_tvb	     = NULL;

	switch(type) {
		case TVBUFF_REAL_DATA:
			/* Nothing */
			break;

		case TVBUFF_SUBSET:
			backing 	= &tvb->tvbuffs.subset;
			backing->tvb	= NULL;
			backing->offset	= 0;
			backing->length	= 0;
			break;

		case TVBUFF_COMPOSITE:
			composite 		 = &tvb->tvbuffs.composite;
			composite->tvbs		 = NULL;
			composite->start_offsets = NULL;
			composite->end_offsets	 = NULL;
			break;

		default:
			//DISSECTOR_ASSERT_NOT_REACHED();
			break;
	}
}
static tvbuff_t*
tvb_new(const tvbuff_type type)
{
	tvbuff_t *tvb=(tvbuff_t *)malloc(sizeof(tvbuff_t));

	//tvb = g_slice_new(tvbuff_t);

	tvb_init(tvb, type);

	return tvb;
}
static tvbuff_t*
tvb_new_with_subset(const guint subset_tvb_offset, const guint subset_tvb_length)
{
	tvbuff_t *tvb = tvb_new(TVBUFF_SUBSET);

	tvb->tvbuffs.subset.offset = subset_tvb_offset;
	tvb->tvbuffs.subset.length = subset_tvb_length;

	return tvb;
}
static void
tvb_set_subset_no_exceptions(tvbuff_t *tvb, tvbuff_t *backing, const gint reported_length)
{
	tvb->tvbuffs.subset.tvb	     = backing;
	tvb->length		     = tvb->tvbuffs.subset.length;

	if (reported_length == -1) {
		tvb->reported_length = backing->reported_length - tvb->tvbuffs.subset.offset;
	}
	else {
		tvb->reported_length = reported_length;
	}
	tvb->initialized	     = TRUE;

	/* Optimization. If the backing buffer has a pointer to contiguous, real data,
	 * then we can point directly to our starting offset in that buffer */
	if (backing->real_data != NULL) {
		tvb->real_data = backing->real_data + tvb->tvbuffs.subset.offset;
	}
}
static tvbuff_t*
tvb_new_subset(tvbuff_t *backing, const gint backing_offset, const gint backing_length, const gint reported_length)
{
	tvbuff_t *tvb;
	guint	  subset_tvb_offset;
	guint	  subset_tvb_length;

	//DISSECTOR_ASSERT(backing && backing->initialized);

	//THROW_ON(reported_length < -1, ReportedBoundsError);

	check_offset_length(backing->length, backing->reported_length, backing_offset, backing_length,
			    &subset_tvb_offset,
			    &subset_tvb_length);

	tvb = tvb_new_with_subset(subset_tvb_offset, subset_tvb_length);

	tvb_set_subset_no_exceptions(tvb, backing, reported_length);

	/*
	 * The top-level data source of this tvbuff is the top-level
	 * data source of its parent.
	 */
	tvb->ds_tvb = backing->ds_tvb;

	return tvb;
}
static void
tvb_set_real_data_no_exceptions(tvbuff_t* tvb, const guint8* data, const guint length, const gint reported_length)
{
	tvb->real_data       = data;
	tvb->length          = length;
	tvb->reported_length = reported_length;
	tvb->initialized     = TRUE;
}
tvbuff_t*
tvb_new_real_data(const guint8* data, const guint length, const gint reported_length)
{
	tvbuff_t *tvb;

	//THROW_ON(reported_length < -1, ReportedBoundsError);

	tvb = tvb_new(TVBUFF_REAL_DATA);

	tvb_set_real_data_no_exceptions(tvb, data, length, reported_length);

	/*
	 * This is the top-level real tvbuff for this data source,
	 * so its data source tvbuff is itself.
	 */
	tvb->ds_tvb = tvb;
	return tvb;
}

tvbuff_t*
tvb_new_child_real_data(tvbuff_t *parent, const guint8* data, const guint length, const gint reported_length)
{
	tvbuff_t *tvb = tvb_new_real_data(data, length, reported_length);
	/*if (tvb) {
		tvb_set_child_real_data_tvbuff (parent, tvb);
	}
*/
	return tvb;
}
void
add_new_data_source(/*packet_info *pinfo,*/ tvbuff_t *tvb, const char *name)
{
	data_source *src;

	src =(data_source*) malloc(sizeof (data_source));
	src->tvb = tvb;
	src->name_initialized = FALSE;
	src->name = name;
	//pinfo->data_src = g_slist_append(pinfo->data_src, src);
}
static tvbuff_t *new_octet_aligned_subset(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, guint32 length)
{
  tvbuff_t *sub_tvb = NULL;
  guint32 boffset = offset >> 3;
  unsigned int i, shift0, shift1;
  guint8 octet0, octet1, *buf;
  guint8* buffer;
  guint32 actual_length;
  /*  XXX - why are we doing this?  Shouldn't we throw an exception if we've
   *  been asked to decode more octets than exist?
   */
  actual_length = tvb_length_remaining(tvb,boffset);
  if (length <= actual_length)
	  actual_length = length;

  if (offset & 0x07) {  /* unaligned */
    shift1 = offset & 0x07;
    shift0 = 8 - shift1;
    buf = (guint8*)malloc(actual_length);
	
    octet0 = tvb_get_guint8(tvb, boffset);
    for (i=0; i<actual_length; i++) {
      octet1 = octet0;
      octet0 = tvb_get_guint8(tvb, boffset + i + 1);
      buf[i] = (octet1 << shift1) | (octet0 >> shift0);
    }
    sub_tvb = tvb_new_child_real_data(tvb, buf, actual_length, length);
  //  tvb_set_free_cb(sub_tvb, g_free);
    add_new_data_source(/*actx->pinfo,*/ sub_tvb, "Unaligned OCTET STRING");
  } else {  /* aligned */
    sub_tvb = tvb_new_subset(tvb, boffset, actual_length, length);
	buffer=(guint8*)malloc(length);
	if(length==16 ){
	for(int i=0;i<length;i++){
		buffer[i]=tvb_get_guint8(sub_tvb,i);
		h_245_message_value.id[i]=tvb_get_guint8(sub_tvb,i);
		printf("%x",tvb_get_guint8(sub_tvb,i));
	}
	printf("\n");

	}

	/*h_225_message_value.octet_ip=(gint32*)tvb->real_data;*/
	} 
  return sub_tvb;
}

guint oid_encoded2subid(const guint8 *oid_bytes, gint oid_len, guint32** subids_p) {
	gint i;
	guint n = 1;
	gboolean is_first = TRUE;
	guint32* subids;
	guint32* subid_overflow;
	/*
	 * we cannot handle sub-ids greater than 32bytes
	 * have the subid in 64 bytes to be able to check the limit
	 */
	guint64 subid = 0;

	for (i=0; i<oid_len; i++) { if (! (oid_bytes[i] & 0x80 )) n++; }

	*subids_p = subids = (guint32*)malloc(sizeof(guint32)*n);
	subid_overflow = subids+n;

	for (i=0; i<oid_len; i++){
		guint8 byte = oid_bytes[i];

		subid <<= 7;
		subid |= byte & 0x7F;

		if (byte & 0x80) {
			continue;
		}

		if (is_first) {
			guint32 subid0 = 0;

			if (subid >= 40) { subid0++; subid-=40; }
			if (subid >= 40) { subid0++; subid-=40; }

			*subids++ = subid0;

			is_first = FALSE;
		}

		if( subids >= subid_overflow || subid > 0xffffffff) {
			*subids_p=NULL;
			return 0;
		}

		*subids++ = (guint32)subid;
		subid = 0;
	}

	return n;
}
int g_snprintf(char *str, size_t size, const char *fmt, ...)
    {
       va_list ap=0;
       int count;
   
      va_start(ap, fmt);
       count = vsnprintf(str, size, fmt, ap);
       va_end(ap);
    
       /* Windows' vsnprintf() doesn't always NUL-terminate the buffer */
       if (count == size)
           str[--count] = '\0';
   
        return count;
    }
const char* oid_subid2string(guint32* subids, guint len) {
	char* s =(char*) malloc(((len)*11)+1);
	char* w = s;

	if(!subids)
		return "*** Empty OID ***";

	do {
		w += g_snprintf(w,12,"%u.",*subids++);
	} while(--len);

	if (w!=s) *(w-1) = '\0'; else *(s) = '\0';

	return s;
}
const gchar* oid_encoded2string(const guint8* encoded, guint len) {
	guint32* subids;
	guint subids_len = oid_encoded2subid(encoded, len, &subids);

	if (subids_len) {
		return oid_subid2string(subids,subids_len);
	} else {
		return "";
	}
}
typedef struct version{
	char *val1;
	char *val2;
}version_t;
const version_t protocol_version_values[]={
	{"0.0.8.245.0.3","h245 version 3"},
	{"0.0.8.245.0.4","h245 version 4"},
	{"0.0.8.245.0.5","h245 version 5"},
	{"0.0.8.245.0.6","h245 version 6"},
	{"0.0.8.245.0.7","h245 version 7"},
	{"0.0.8.245.0.8","h245 version 8"},
	{"0.0.8.245.0.9","h245 version 9"},
	{"0.0.8.245.0.10","h245 version 10"},
	{"0.0.8.245.0.11","h245 version 11"},
	{"0.0.8.245.0.12","h245 version 12"},
	{"0.0.8.239.1.1","h239ControlCapability"},
	{"0.0.8.239.1.2","h239ExtendedVideoCapability"},
	{"0.0.8.239.1.2","generic-message"},



  //oid_add_from_string("h245 version 13","0.0.8.245.0.13");
  ///* This capability is defined in Annex E. */
  //oid_add_from_string("ISO/IEC 14496-2 MPEG-4 video","0.0.8.245.1.0.0");
  ///* This capability is defined in Annex H. */
  //oid_add_from_string("ISO/IEC 14496-3 MPEG-4 audio","0.0.8.245.1.1.0");
  ///* This capability is defined in Annex I. */
  //oid_add_from_string("AMR","0.0.8.245.1.1.1");
  ///* This capability is defined in Annex J. */
  //oid_add_from_string("acelp","0.0.8.245.1.1.2");
  ///* This capability is defined in Annex K. */
  //oid_add_from_string("us1","0.0.8.245.1.1.3");
  ///* This capability is defined in Annex L. */
  //oid_add_from_string("is127evrc","0.0.8.245.1.1.4");
  ///* This capability is defined in Annex M. */
  //oid_add_from_string("ISO/IEC 13818-7","0.0.8.245.1.1.5");
  ///* This capability is defined in Annex N. */
  //oid_add_from_string("rfc3389","0.0.8.245.1.1.6");
  ///* This capability is defined in Annex O. */
  //oid_add_from_string("L-16","0.0.8.245.1.1.7");
  ///* This capability is defined in Annex P. */
  //oid_add_from_string("bounded-audio-stream","0.0.8.245.1.1.8");
  ///* This capability is defined in Annex R. */
  //oid_add_from_string("AMR-NB","0.0.8.245.1.1.9");
  ///* This capability is defined in Annex R. */
  //oid_add_from_string("AMR-WB","0.0.8.245.1.1.10");
  ///* This capability is defined in Annex S. */
  //oid_add_from_string("ilbc","0.0.8.245.1.1.11");

  //oid_add_from_string("ISO/IEC 14496-1","0.0.8.245.1.2.0");
  //oid_add_from_string("Nx64","0.0.8.245.1.2.1");
  //oid_add_from_string("logical-channel-bit-ratemanagement","0.0.8.245.1.3.0");

  //oid_add_from_string("h264 generic-capabilities","0.0.8.241.0.0.1");
  //oid_add_from_string("iPpacketization_h241AnnexA(single NAL unit mode)","0.0.8.241.0.0.0.0");
  //oid_add_from_string("iPpacketization_RFC3984NonInterleaved","0.0.8.241.0.0.0.1");
  //oid_add_from_string("iPpacketization_RFC3984Interleaved","0.0.8.241.0.0.0.2");
	
};
char* display_str(const char*data)
{
	int i;
	char* val1;
	char* val2;
	
	for(i=0;i<6; i++ )
	{
		val1=protocol_version_values[i].val1;
	if(	strcmp(val1 , data)==0)
	{
   
		return protocol_version_values[i].val2;

	}

	}
	return "";
}

typedef struct version_h_225{
	char *val1;
	char *val2;
}version_t_225;
const version_t_225 protocol_version_values_225[]={
	{"0.0.8.2250.0.1","version 1"},
	{"0.0.8.2250.0.2","version 2"},
	{"0.0.8.2250.0.3","version 3"},
	{"0.0.8.2250.0.4","version 4"},
	{"0.0.8.2250.0.5","version 5"},
	{"0.0.8.2250.0.6","version 6"},
	
};
char* display_str_H_225(const char*data)
{
	int i;
	char* val1;
	char* val2;
	
	for(i=0;i<6; i++ )
	{
		val1=protocol_version_values_225[i].val1;
	if(	strcmp(val1 , data)==0)
	{
   
		return protocol_version_values_225[i].val2;

	}

	}
	return "";
}

/* 23 Encoding the object identifier type */
guint32
dissect_per_object_identifier(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx,int hf_index, tvbuff_t **value_tvb)
{
  guint length;
  const char *str;
  tvbuff_t *val_tvb = NULL;
  header_field_info *hfi;
  const char*version;
////DEBUG_ENTRY("dissect_per_object_identifier");

  offset = dissect_per_length_determinant(tvb, offset, actx, hf_per_object_identifier_length, &length);
  if (actx->aligned) BYTE_ALIGN_OFFSET(offset);
  val_tvb = new_octet_aligned_subset(tvb, offset, actx, length);

 //// hfi = proto_registrar_get_nth(hf_index);
 // if (hfi->type == FT_OID) {
 //   //actx->created_item = proto_tree_add_item(tree, hf_index, val_tvb, 0, length, ENC_BIG_ENDIAN);
 // } else if (IS_FT_STRING(hfi->type)) {
 str = oid_encoded2string(tvb_get_ptr(val_tvb, 0, length), length);
 //  // actx->created_item = proto_tree_add_string(tree, hf_index, val_tvb, 0, length, str);
 // } else {
 //  // DISSECTOR_ASSERT_NOT_REACHED();
 // }
 printf("%s",str);
  if (value_tvb) *value_tvb = val_tvb;

  offset += 8 * length;
  version=display_str(str);
  printf(" (%s)\n",version);
  return offset;
}
guint32
dissect_per_object_identifier_h225(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx,int hf_index, tvbuff_t **value_tvb)
{
  guint length;
  const char *str;
  tvbuff_t *val_tvb = NULL;
  header_field_info *hfi;
  const char*version;
////DEBUG_ENTRY("dissect_per_object_identifier");

  offset = dissect_per_length_determinant(tvb, offset, actx, hf_per_object_identifier_length, &length);
  if (actx->aligned) BYTE_ALIGN_OFFSET(offset);
  val_tvb = new_octet_aligned_subset(tvb, offset, actx, length);

 //// hfi = proto_registrar_get_nth(hf_index);
 // if (hfi->type == FT_OID) {
 //   //actx->created_item = proto_tree_add_item(tree, hf_index, val_tvb, 0, length, ENC_BIG_ENDIAN);
 // } else if (IS_FT_STRING(hfi->type)) {
 str = oid_encoded2string(tvb_get_ptr(val_tvb, 0, length), length);
 //  // actx->created_item = proto_tree_add_string(tree, hf_index, val_tvb, 0, length, str);
 // } else {
 //  // DISSECTOR_ASSERT_NOT_REACHED();
 // }
 printf("%s",str);
  if (value_tvb) *value_tvb = val_tvb;

  offset += 8 * length;
  version=display_str_H_225(str);
  printf(" (%s)\n",version);
  return offset;
}
static const guint8*
tvb_get_ptr(tvbuff_t *tvb, const gint offset, const gint length)
{
	return ensure_contiguous(tvb, offset, length);
}

guint32
dissect_per_object_identifier_str(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx,  int hf_index, const char **value_stringx)
{
  tvbuff_t *value_tvb = NULL;
  guint length;

  offset = dissect_per_object_identifier(tvb, offset, actx, hf_index, (value_stringx) ? &value_tvb : NULL);

  if (value_stringx) {
    if (value_tvb && (length = tvb_length(value_tvb))) {
//      *value_stringx = oid_encoded2string(tvb_get_ptr(value_tvb, 0, length), length);
    } else {
      *value_stringx = "";
    }
  }

  return offset;
}



static int
dissect_h245_T_object(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_object_identifier_str(tvb, offset, actx, hf_index, &nsiOID);

  return offset;
}
/* we currently only handle integers up to 32 bits in length. */
guint32
dissect_per_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gint32 *value)
{
	guint32 i, length;
	gint32 val;
	//proto_item *it=NULL;
	header_field_info *hfi;

	/* 12.2.6 b */
	offset=dissect_per_length_determinant(tvb, offset, actx,hf_per_integer_length, &length);
	/* gassert here? */
	if(length>4){
//PER_NOT_DECODED_YET("too long integer(per_integer)");
		length=4;
	}

	val=0;
	for(i=0;i<length;i++){
		if(i==0){
			if(tvb_get_guint8(tvb, offset>>3)&0x80){
				/* negative number */
				val=0xffffffff;
			} else {
				/* positive number */
				val=0;
			}
		}
		val=(val<<8)|tvb_get_guint8(tvb,offset>>3);
		offset+=8;
	}

	//hfi = proto_registrar_get_nth(hf_index);
	//if (! hfi)
		//THROW(ReportedBoundsError);
  /*      if (IS_FT_INT(hfi->type)) {
		it=proto_tree_add_int(tree, hf_index, tvb, (offset>>3)-(length+1), length+1, val);
        } else if (IS_FT_UINT(hfi->type)) {
		it=proto_tree_add_uint(tree, hf_index, tvb, (offset>>3)-(length+1), length+1, val);
	} else {
		proto_tree_add_text(tree, tvb, (offset>>3)-(length+1), length+1, "Field is not an integer: %s", hfi->abbrev);
		REPORT_DISSECTOR_BUG("PER integer field that's not an FT_INT* or FT_UINT*");
	}*/


	//actx->created_item = it;

	if(value){
		*value=val;
	}

	return offset;
}
static void per_check_value(guint32 value, guint32 min_len, guint32 max_len, asn1_ctx_t *actx, /*proto_item *item,*/ gboolean is_signed)
{
	if ((is_signed == FALSE) && (value > max_len)) {
		//expert_add_info_format(actx->pinfo, item, PI_PROTOCOL, PI_WARN,
			printf("Size constraint: value too big: %u (%u .. %u)\n", value, min_len, max_len);
	} else if ((is_signed == TRUE) && ((gint32)value > (gint32)max_len)) {
		//expert_add_info_format(actx->pinfo, item, PI_PROTOCOL, PI_WARN, 
		printf("Size constraint: value too big: %d (%d .. %d)\n", (gint32)value, (gint32)min_len, (gint32)max_len);
	}
}
guint32
dissect_per_constrained_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx,int hf_index, guint32 min, guint32 max, guint32 *value, gboolean has_extension)
{
	proto_item *it=NULL;
	guint32 range, val;
	gint val_start, val_length;
	nstime_t timeval;
	header_field_info *hfi;
	int num_bits;
	gboolean tmp;

////DEBUG_ENTRY("dissect_per_constrained_integer");
	if(has_extension){
		gboolean extension_present;
		offset=dissect_per_boolean(tvb, offset, actx,/* */hf_per_extension_present_bit, &extension_present);
	//	if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
		if(extension_present){
			offset = dissect_per_integer(tvb, offset, actx,/**/ hf_index, (gint32*)value);
			return offset;
		}
	}

//	hfi = proto_registrar_get_nth(hf_index);

	/* 10.5.3 Let "range" be defined as the integer value ("ub" - "lb"   1), and let the value to be encoded be "n".
	 * 10.5.7	In the case of the ALIGNED variant the encoding depends on whether
	 *			d)	"range" is greater than 64K (the indefinite length case).
	 */
	if(((max-min)>65536)&&(actx->aligned)){
		/* just set range really big so it will fall through
		   to the bottom of the encoding */
		range=1000000;
	} else {
		/* Really ugly hack.
		 * We should really use guint64 as parameters for min/max.
		 * This is to prevent range from being 0 if
		 * the range for a signed integer spans the entire 32 bit range.
		 * Special case the 2 common cases when this can happen until
		 * a real fix is implemented.
		 */
		if( (max==0x7fffffff && min==0x80000000)
		||  (max==0xffffffff && min==0x00000000) ){
			range=0xffffffff;
		} else {
			range=max-min+1;
		}
	}

	val=0;
	timeval.secs=val; timeval.nsecs=0;
	/* 10.5.4 If "range" has the value 1, then the result of the encoding shall be an empty bit-field (no bits).*/

	/* something is really wrong if range is 0 */
	//DISSECTOR_ASSERT(range!=0);

	if(range==1){
		val_start = offset>>3; val_length = 0;
		val = min;
	} else if((range<=255)||(!actx->aligned)) {
		/* 10.5.7.1
		 * 10.5.6	In the case of the UNALIGNED variant the value ("n" - "lb") shall be encoded
		 * as a non-negative  binary integer in a bit field as specified in 10.3 with the minimum
		 * number of bits necessary to represent the range.
		 */
		char *str;
		int  str_index = 0;
		int i, bit, length, str_length;
		guint32 mask,mask2;
		/* We only handle 32 bit integers */
		mask  = 0x80000000;
		mask2 = 0x7fffffff;
		i = 32;
		while ((range & mask)== 0){
			i = i - 1;
			mask = mask>>1;
			mask2 = mask2>>1;
		}
		if ((range & mask2) == 0)
			i = i-1;

		num_bits = i;
		length=1;
		if(range<=2){
			num_bits=1;
		}

		/* prepare the string (max number of bits + quartet separators + field name + ": ") */
		str_length = 256+64+/*(int)strlen(hfi->name)*/+2;
		str=(char*)malloc(str_length+1);
	//	str_index = /*g_*/fprintf(str, (const char*)str_length+1, "%s: "/*, hfi->name*/);
		for(bit=0;bit<((int)(offset&0x07));bit++){
			if(bit&&(!(bit%4))){
				if (str_index < str_length) str[str_index++] = ' ';
			}
			if (str_index < str_length) str[str_index++] = '.';
		}
		///* read the bits for the int */
		for(i=0;i<num_bits;i++){
			if(bit&&(!(bit%4))){
				if (str_index < str_length) str[str_index++] = ' ';
			}
			if(bit&&(!(bit%8))){
				length+=1;
				if (str_index < str_length) str[str_index++] = ' ';
			}
			bit++;
			offset=dissect_per_boolean(tvb, offset, actx,/**/ -1, &tmp);
			val<<=1;
			if(tmp){
				val|=1;
				if (str_index < str_length) str[str_index++] = '1';
			} else {
				if (str_index < str_length) str[str_index++] = '0';
			}
		}
		for(;bit%8;bit++){
			if(bit&&(!(bit%4))){
				if (str_index < str_length) str[str_index++] = ' ';
			}
			if (str_index < str_length) str[str_index++] = '.';
		}
		str[str_index] = '\0'; /* Terminate string */
		val_start = (offset-num_bits)>>3; val_length = length;
		val+=min;

		if (display_internal_per_fields)
			//proto_tree_add_text(tree, tvb, val_start,val_length,
		printf("Range = %u Bitfield length %u, %s\n", range, num_bits, str);
	} else if(range==256){
		/* 10.5.7.2 */

		/* in the aligned case, align to byte boundary */
		BYTE_ALIGN_OFFSET(offset);
		val=tvb_get_guint8(tvb, offset>>3);
		offset+=8;

		val_start = (offset>>3)-1; val_length = 1;
		val+=min;
	} else if(range<=65536){
		/* 10.5.7.3 */

		/* in the aligned case, align to byte boundary */
		BYTE_ALIGN_OFFSET(offset);
		val=tvb_get_guint8(tvb, offset>>3);
		val<<=8;
		offset+=8;
		val|=tvb_get_guint8(tvb, offset>>3);
		offset+=8;

		val_start = (offset>>3)-2; val_length = 2;
		val+=min;
	} else {
		int i,num_bytes;
		gboolean bit;

		/* 10.5.7.4 */
		/* 12.2.6 */
		offset=dissect_per_boolean(tvb, offset, actx, /*tree,*/ -1, &bit);
		num_bytes=bit;
		offset=dissect_per_boolean(tvb, offset, actx,/**/ -1, &bit);
		num_bytes=(num_bytes<<1)|bit;

		num_bytes++;  /* lower bound for length determinant is 1 */
		if (display_internal_per_fields)
			//proto_tree_add_uint(tree, hf_per_const_int_len, tvb, (offset>>3), 1, num_bytes);

		/* byte aligned */
		BYTE_ALIGN_OFFSET(offset);
		val=0;
		offset+=8;
		for(i=0;i<num_bytes;i++){
			//printf("%x",tvb_get_guint8(tvb,offset>>3));
			
			val=(val<<8)|tvb_get_guint8(tvb,offset>>3);
			offset+=8;
		}
		val_start = (offset>>3)-(num_bytes+1); val_length = num_bytes+1;
		val+=min;
	}

	timeval.secs = val;
	//if (IS_FT_UINT(hfi->type)) {
	//	//it = proto_tree_add_uint(tree, hf_index, tvb, val_start, val_length, val);
	per_check_value(val, min, max, actx,/* it,*/ FALSE);
	//} else if (IS_FT_INT(hfi->type)) {
	//	//it = proto_tree_add_int(tree, hf_index, tvb, val_start, val_length, val);
	//	per_check_value(val, min, max, actx,/* it,*/ TRUE);
	//} else if (IS_FT_TIME(hfi->type)) {
	//	//it = proto_tree_add_time(tree, hf_index, tvb, val_start, val_length, &timeval);
	//} else {
	//	//THROW(ReportedBoundsError);
	//}
	//actx->created_item = it;
	if (value) *value = val;
	
	h_245_message_value.vendor_value=val;
	h_225_message_value.vendor_value=val;
	return offset;
}



static int
dissect_h245_T_t35CountryCode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, &t35CountryCode, FALSE);

  return offset;
}



static int
dissect_h245_T_t35Extension(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, &t35Extension, FALSE);

  return offset;
}



static int
dissect_h245_T_manufacturerCode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, &manufacturerCode, FALSE);

  return offset;
}


static const per_sequence_t H221NonStandardID_sequence[] = {
  { &hf_h245_t35CountryCode , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_t35CountryCode },
  { &hf_h245_t35Extension   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_t35Extension },
  { &hf_h245_manufacturerCode, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_manufacturerCode },
  { NULL, 0, 0, NULL }
};
guint64
tvb_get_bits64(tvbuff_t *tvb, guint bit_offset, const gint no_of_bits, const guint encoding)
{
	/* note that encoding has no meaning here, as the tvb is considered to contain an octet array */
	return _tvb_get_bits64(tvb, bit_offset, no_of_bits);
}
static const guint8 inverse_bit_mask8[] = {
	0xff,
	0x7f,
	0x3f,
	0x1f,
	0x0f,
	0x07,
	0x03,
	0x01
};

static const guint8 bit_mask8[] = {
	0x00,
	0x01,
	0x03,
	0x07,
	0x0f,
	0x1f,
	0x3f,
	0x7f,
	0xff
};
guint16
tvb_get_ntohs(tvbuff_t *tvb, const gint offset)
{
	const guint8 *ptr;
         
	ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint16));
	return pntohs(ptr);
}

guint32
tvb_get_ntoh24(tvbuff_t *tvb, const gint offset)
{
	const guint8 *ptr;

	ptr = fast_ensure_contiguous(tvb, offset, 3);
	return pntoh24(ptr);
}

guint32
tvb_get_ntohl(tvbuff_t *tvb, const gint offset)
{
	const guint8 *ptr;

	ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32));
	return pntohl(ptr);
}
guint64
tvb_get_ntoh64(tvbuff_t *tvb, const gint offset)
{
	const guint8 *ptr;

	ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint64));
	return pntoh64(ptr);
}
static guint64
_tvb_get_bits64(tvbuff_t *tvb, guint bit_offset, const gint total_no_of_bits)
{
	guint64 value;
	guint octet_offset = bit_offset >> 3;
	guint8 required_bits_in_first_octet = 8 - (bit_offset % 8);

	if(required_bits_in_first_octet > total_no_of_bits)
	{
		/* the required bits don't extend to the end of the first octet */
		guint8 right_shift = required_bits_in_first_octet - total_no_of_bits;
		value = (tvb_get_guint8(tvb, octet_offset) >> right_shift) & bit_mask8[total_no_of_bits % 8];
	}
	else
	{
		guint8 remaining_bit_length = total_no_of_bits;

		/* get the bits up to the first octet boundary */
		value = 0;
		required_bits_in_first_octet %= 8;
		if(required_bits_in_first_octet != 0)
		{
			value = tvb_get_guint8(tvb, octet_offset) & bit_mask8[required_bits_in_first_octet];
			remaining_bit_length -= required_bits_in_first_octet;
			octet_offset ++;
		}
		/* take the biggest words, shorts or octets that we can */
		while (remaining_bit_length > 7)
		{
			switch (remaining_bit_length >> 4)
			{
			case 0:
				/* 8 - 15 bits. (note that 0 - 7 would have dropped out of the while() loop) */
				value <<= 8;
				value += tvb_get_guint8(tvb, octet_offset);
				remaining_bit_length -= 8;
				octet_offset ++;
				break;

			case 1:
				/* 16 - 31 bits */
				value <<= 16;
				value += tvb_get_ntohs(tvb, octet_offset);
				remaining_bit_length -= 16;
				octet_offset += 2;
				break;

			case 2:
			case 3:
				/* 32 - 63 bits */
				value <<= 32;
				value += tvb_get_ntohl(tvb, octet_offset);
				remaining_bit_length -= 32;
				octet_offset += 4;
				break;

			default:
				/* 64 bits (or more???) */
				value = tvb_get_ntoh64(tvb, octet_offset);
				remaining_bit_length -= 64;
				octet_offset += 8;
				break;
			}
		}
		/* get bits from any partial octet at the tail */
		if(remaining_bit_length)
		{
			value <<= remaining_bit_length;
			value += (tvb_get_guint8(tvb, octet_offset) >> (8 - remaining_bit_length));
		}
	}
	return value;
}
guint8
tvb_get_bits8(tvbuff_t *tvb, guint bit_offset, const gint no_of_bits)
{
	return (guint8)_tvb_get_bits64(tvb, bit_offset, no_of_bits);
}
guint16
tvb_get_bits16(tvbuff_t *tvb, guint bit_offset, const gint no_of_bits,const guint encoding)
{
	/* note that encoding has no meaning here, as the tvb is considered to contain an octet array */
	return (guint16)_tvb_get_bits64(tvb, bit_offset, no_of_bits);
}
guint32
tvb_get_bits32(tvbuff_t *tvb, guint bit_offset, const gint no_of_bits, const guint encoding)
{
	/* note that encoding has no meaning here, as the tvb is considered to contain an octet array */
	return (guint32)_tvb_get_bits64(tvb, bit_offset, no_of_bits);
}

/* 10.6   normally small non-negative whole number */
static guint32
dissect_per_normally_small_nonnegative_whole_number(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, guint32 *length)
{
	gboolean small_number, length_bit;
	guint32 len, length_determinant;
	//proto_item *pi;

////DEBUG_ENTRY("dissect_per_normally_small_nonnegative_whole_number");
	if(!length){
		length=&len;
	}

	offset=dissect_per_boolean(tvb, offset, actx, hf_per_small_number_bit, &small_number);
	//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
	if(!small_number){
		int i;
		/* 10.6.1 */
		*length=0;
		for(i=0;i<6;i++){
			offset=dissect_per_boolean(tvb, offset, actx, -1, &length_bit);
			*length<<=1;
			if (length_bit) {
				*length|=1;
			}
		}
		if(hf_index!=-1){
			//pi = proto_tree_add_uint(tree, hf_index, tvb, (offset-6)>>3, (offset%8<6)?2:1, *length);
			//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(pi);
		}
		return offset;
	}

	/* 10.6.2 */
	offset=dissect_per_length_determinant(tvb, offset, actx, hf_per_normally_small_nonnegative_whole_number_length, &length_determinant);
	switch (length_determinant) {
		case 0:
			*length = 0;
			break;
		case 1:
			*length = tvb_get_bits8(tvb, offset, 8);
			offset += 8;
			break;
		case 2:
			*length = tvb_get_bits16(tvb, offset, 16, ENC_BIG_ENDIAN);
			offset += 16;
			break;
	case 3:
			*length = tvb_get_bits32(tvb, offset, 24, ENC_BIG_ENDIAN);
			offset += 24;
			break;
			case 4:
			*length = tvb_get_bits32(tvb, offset, 32, ENC_BIG_ENDIAN);
			offset += 32;
			break;
		default:
			//PER_NOT_DECODED_YET("too long integer(per_normally_small_nonnegative_whole_number)");
			offset += 8*length_determinant;
			*length = 0;
			return offset;
	}
	//if(hf_index!=-1){
		//pi = proto_tree_add_uint(tree, hf_index, tvb, (offset-(8*length_determinant))>>3, length_determinant, *length);
	//	if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(pi);
	//}

	return offset;
}
guint32
dissect_per_sequence(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gint ett_index, const per_sequence_t *sequence)
{
	gboolean /*extension_present,*/ extension_flag, optional_field_flag;
	proto_item *item;
	//proto_tree *tree;
	guint32 old_offset=offset;
	guint32 i, num_opts;
	guint64 optional_mask;

//DEBUG_ENTRY("dissect_per_sequence");

	//item=proto_tree_add_item(parent_tree, hf_index, tvb, offset>>3, 0, ENC_BIG_ENDIAN);
	//tree=proto_item_add_subtree(item, ett_index);


	/* first check if there should be an extension bit for this CHOICE.
	   we do this by just checking the first choice arm
	 */
	/* 18.1 */
	extension_flag=0;
	if(sequence[0].extension==ASN1_NO_EXTENSIONS){
		/*extension_present=0;  ?? */
	} else {
		/*extension_present=1; ?? */
		offset=dissect_per_boolean(tvb, offset, actx, hf_per_extension_bit, &extension_flag);
		//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
	}
	/* 18.2 */
	num_opts=0;
	for(i=0;sequence[i].p_id;i++){
		if((sequence[i].extension!=ASN1_NOT_EXTENSION_ROOT)&&(sequence[i].optional==ASN1_OPTIONAL)){
			num_opts++;
		}
	}
	if (num_opts > 64) {
		//PER_NOT_DECODED_YET("more than 64 optional/default components");
	} 

	optional_mask=0;
	for(i=0;i<num_opts;i++){
		offset=dissect_per_boolean(tvb, offset, actx, hf_per_optional_field_bit, &optional_field_flag);
	/*	if (tree) {
			proto_item_append_text(actx->created_item, " (%s %s present)",
				index_get_optional_name(sequence, i), optional_field_flag?"is":"is NOT");
		}*/
		//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
		optional_mask<<=1;
		if(optional_field_flag){
			optional_mask|=0x01;
		}
	}


	/* 18.4 */
	for(i=0;sequence[i].p_id;i++){
		if( (sequence[i].extension==ASN1_NO_EXTENSIONS)
		||  (sequence[i].extension==ASN1_EXTENSION_ROOT) ){
			if(sequence[i].optional==ASN1_OPTIONAL){
				gboolean is_present;
				if (num_opts == 0){
					continue;
				}
				is_present=(((guint64)1<<(num_opts-1))&optional_mask) ? TRUE : FALSE;
				num_opts--;
				if(!is_present){
					continue;
				}
			}
			if(sequence[i].func){
				offset=sequence[i].func(tvb, offset, actx, *sequence[i].p_id);
			} else {
				//PER_NOT_DECODED_YET(index_get_field_name(sequence, i));
			}
		}
	}


	if(extension_flag){
		gboolean extension_bit;
		guint32 num_known_extensions;
		guint32 num_extensions;
		guint32 extension_mask;

		offset=dissect_per_normally_small_nonnegative_whole_number(tvb, offset, actx, hf_per_num_sequence_extensions, &num_extensions);
		num_extensions+=1;

		extension_mask=0;
		for(i=0;i<num_extensions;i++){
			offset=dissect_per_boolean(tvb, offset, actx, hf_per_extension_present_bit, &extension_bit);
			/*if (tree) {
				proto_item_append_text(actx->created_item, " (%s %s present)",
					index_get_extension_name(sequence, i), extension_bit?"is":"is NOT");
			}
			if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);*/

			extension_mask=(extension_mask<<1)|extension_bit;
		}

		/* find how many extensions we know about */
		num_known_extensions=0;
		for(i=0;sequence[i].p_id;i++){
			if(sequence[i].extension==ASN1_NOT_EXTENSION_ROOT){
				num_known_extensions++;
			}
		}

		/* decode the extensions one by one */
		for(i=0;i<num_extensions;i++){
			proto_item *cause;
			guint32 length;
			guint32 new_offset;
			guint32 difference;
			guint32 extension_index;
			guint32 j,k;

			if(!((1L<<(num_extensions-1-i))&extension_mask)){
				/* this extension is not encoded in this PDU */
				continue;
			}

			offset=dissect_per_length_determinant(tvb, offset, actx, hf_per_open_type_length, &length);

			if(i>=num_known_extensions){
				/* we don't know how to decode this extension */
				offset+=length*8;
				//expert_add_info_format(actx->pinfo, item, PI_UNDECODED, PI_NOTE, "unknown sequence extension");
				continue;
			}

			extension_index=0;
			for(j=0,k=0;sequence[j].p_id;j++){
				if(sequence[j].extension==ASN1_NOT_EXTENSION_ROOT){
					if(k==i){
						extension_index=j;
						break;
					}
					k++;
				}
			}

			if(sequence[extension_index].func){
				new_offset=sequence[extension_index].func(tvb, offset, actx, *sequence[extension_index].p_id);
				offset+=length*8;
				difference = offset - new_offset;
				/* A difference of 7 or less might be byte aligning */
                /* Difference could be 8 if open type has no bits and the length is 1 */
				if ((length > 1) && (difference > 7)) {
					//cause=proto_tree_add_text(tree, tvb, new_offset>>3, (offset-new_offset)>>3,
						printf("[Possible encoding error full length not decoded. Open type length %u ,decoded %u]\n",length, length - (difference>>3));
					//proto_item_set_expert_flags(cause, PI_MALFORMED, PI_WARN);
					//expert_add_info_format(actx->pinfo, cause, PI_MALFORMED, PI_WARN,
						printf("Possible encoding error full length not decoded. Open type length %u ,decoded %u",length, length - (difference>>3));
				}
			} else {
				//PER_NOT_DECODED_YET(index_get_field_name(sequence, extension_index));
				offset+=length*8;
			}
		}
	}

	//proto_item_set_len(item, (offset>>3)!=(old_offset>>3)?(offset>>3)-(old_offset>>3):1);
	//actx->created_item = item;
	return offset;
}

static int
dissect_h245_H221NonStandardID(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 970 "../../asn1/h245/h245.cnf"
  t35CountryCode = 0;
  t35Extension = 0;
  manufacturerCode = 0;

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H221NonStandardID, H221NonStandardID_sequence);

//#line 974 "../../asn1/h245/h245.cnf"
  h221NonStandard = ((t35CountryCode * 256) + t35Extension) * 65536 + manufacturerCode;
  //proto_tree_add_uint(tree, hf_h245Manufacturer, tvb, (offset>>3)-4, 4, h221NonStandard);

  return offset;
}


static const value_string h245_NonStandardIdentifier_vals[] = {
  {   0, "object" },
  {   1, "h221NonStandard" },
  { 0, NULL }
};

static const per_choice_t NonStandardIdentifier_choice[] = {
  {   0, &hf_h245_object         , ASN1_NO_EXTENSIONS     , dissect_h245_T_object },
  {   1, &hf_h245_h221NonStandardID, ASN1_NO_EXTENSIONS     , dissect_h245_H221NonStandardID },
  { 0, NULL, 0, NULL }
};

/* 22 Encoding the choice type */
guint32
dissect_per_choice(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gint ett_index,const per_choice_t *choice, gint *value)
{
	gboolean extension_present, extension_flag;
	int extension_root_entries;
	int extension_addition_entries;
	guint32 choice_index;
	int i, idx, cidx;
	guint32 ext_length;
	guint32 old_offset = offset;
	proto_item *choice_item = NULL;
	///proto_tree *choice_tree = NULL;

////DEBUG_ENTRY("dissect_per_choice");

	if (value) *value = -1;

	/* 22.5 */
	if (choice[0].extension == ASN1_NO_EXTENSIONS){
		/*extension_present = FALSE; ?? */
		extension_flag = FALSE;
	} else {
		/*extension_present = TRUE; ?? */
		offset = dissect_per_boolean(tvb, offset, actx,  hf_per_extension_bit, &extension_flag);
		if (!display_internal_per_fields) /*PROTO_ITEM_SET_HIDDEN(actx->created_item)*/;
	}

	/* count the number of entries in the extension root and extension addition */
	extension_root_entries = 0;
	extension_addition_entries = 0;
	for (i=0; choice[i].p_id; i++) {
		switch(choice[i].extension){
			case ASN1_NO_EXTENSIONS:
			case ASN1_EXTENSION_ROOT:
				extension_root_entries++;
				break;
			case ASN1_NOT_EXTENSION_ROOT:
				extension_addition_entries++;
				break;
		}
	}

	if (!extension_flag) {  /* 22.6, 22.7 */
		if (extension_root_entries == 1) {  /* 22.5 */
			choice_index = 0;
		} else {
			offset = dissect_per_constrained_integer(tvb, offset, actx,
				 hf_per_choice_index, 0, extension_root_entries - 1,
				&choice_index, FALSE);
			if (!display_internal_per_fields) /*PROTO_ITEM_SET_HIDDEN(actx->created_item)*/;
		}

		idx = -1; cidx = choice_index;
		for (i=0; choice[i].p_id; i++) {
			if(choice[i].extension != ASN1_NOT_EXTENSION_ROOT){
				if (!cidx) { idx = i; break; }
				cidx--;
			}
		}
	} else {  /* 22.8 */
		offset = dissect_per_normally_small_nonnegative_whole_number(tvb, offset, actx,  hf_per_choice_extension_index, &choice_index);
		offset = dissect_per_length_determinant(tvb, offset, actx, hf_per_open_type_length, &ext_length);

		idx = -1; cidx = choice_index;
		for (i=0; choice[i].p_id; i++) {
			if(choice[i].extension == ASN1_NOT_EXTENSION_ROOT){
				if (!cidx) { idx = i; break; }
				cidx--;
			}
		}
	}
h_245_message_value.msg_value=(int)choice[idx].value;
h_225_message_value.msg_value=(int)choice[idx].value;
	if (idx != -1) {
		//choice_item = proto_tree_add_uint(tree, hf_index, tvb, old_offset>>3, 0, choice[idx].value);
		//choice_tree = proto_item_add_subtree(choice_item, ett_index);
		if (!extension_flag) {
			offset = choice[idx].func(tvb, offset, actx,  *choice[idx].p_id);
		} else {
			choice[idx].func(tvb, offset, actx, *choice[idx].p_id);
			offset += ext_length * 8;
		}
		//proto_item_set_len(choice_item, BLEN(old_offset, offset));
	} else {
		if (!extension_flag) {
		////	PER_NOT_DECODED_YET("unknown extension root index in choice");
		} else {
			offset += ext_length * 8;
			//proto_tree_add_text(tree, tvb, old_offset>>3, BLEN(old_offset, offset), "Choice no. %d in extension", choice_index);
		//	expert_add_info_format(actx->pinfo, choice_item, PI_UNDECODED, PI_NOTE, "unknown choice extension");
		}
	}

	if (value && (idx != -1))
		*value = choice[idx].value;
	//
	/*printf("%s",&choice[idx].p_id);*/
	
	//printf("(%d)\n",(int)choice[idx].value);
	return offset;
}

static int
dissect_h245_NonStandardIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 951 "../../asn1/h245/h245.cnf"
	gint32 value;

	nsiOID = "";
	h221NonStandard = 0;

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_NonStandardIdentifier, NonStandardIdentifier_choice,
                                 &value);

	switch (value) {
		case 0 :  /* object */
			//nsp_handle = dissector_get_string_handle(nsp_object_dissector_table, nsiOID);
			break;
		case 1 :  /* h221NonStandard */
			//nsp_handle = dissector_get_uint_handle(nsp_h221_dissector_table, h221NonStandard);
			break;
		default :
			nsp_handle = NULL;
    }


  return offset;
}

guint32
dissect_per_octet_string(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx,int hf_index, int min_len, int max_len, gboolean has_extension, tvbuff_t **value_tvb)
{
	gint val_start = 0, val_length;
	guint32 length = 0;
	header_field_info *hfi;
	tvbuff_t *out_tvb = NULL;

	//hfi = (hf_index==-1) ? NULL : proto_registrar_get_nth(hf_index);

////DEBUG_ENTRY("dissect_per_octet_string");

	if (has_extension) {  /* 16.3 an extension marker is present */
		gboolean extension_present;
		offset = dissect_per_boolean(tvb, offset, actx, hf_per_extension_present_bit, &extension_present);
		//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
		if (extension_present) max_len = NO_BOUND;  /* skip to 16.8 */
	}

	if (min_len == NO_BOUND) {
		min_len = 0;
	}
	if (max_len==0) {  /* 16.5 if the length is 0 bytes there will be no encoding */
		val_start = offset>>3;
		val_length = 0;

	} else if((min_len==max_len)&&(max_len<=2)) {
		/* 16.6 if length is fixed and less than or equal to two bytes*/
		val_start = offset>>3;
		val_length = min_len;
		out_tvb = new_octet_aligned_subset(tvb, offset, actx, val_length);
		offset+=min_len*8;

	} else if ((min_len==max_len)&&(min_len<65536)) {
		/* 16.7 if length is fixed and less than to 64k*/

		/* align to byte */
		if (actx->aligned){
			BYTE_ALIGN_OFFSET(offset);
		}
		val_start = offset>>3;
		val_length = min_len;
		out_tvb = new_octet_aligned_subset(tvb, offset, actx, val_length);
		offset+=min_len*8;

	} else {  /* 16.8 */
		if(max_len>0) {
			offset = dissect_per_constrained_integer(tvb, offset, actx,
				hf_per_octet_string_length, min_len, max_len, &length, FALSE);

				//if (!display_internal_per_fields)
					//PROTO_ITEM_SET_HIDDEN(actx->created_item);
		} else {
			offset = dissect_per_length_determinant(tvb, offset, actx,
				hf_per_octet_string_length, &length);
		}

		if(length){
			/* align to byte */
			if (actx->aligned){
				BYTE_ALIGN_OFFSET(offset);
			}
			out_tvb = new_octet_aligned_subset(tvb, offset, actx, length);
		} else {
			val_start = offset>>3;
		}
		val_length = length;
		offset+=length*8;
	}

	//if (hfi) {
	//	if (IS_FT_UINT(hfi->type)||IS_FT_INT(hfi->type)) {
	//		/* If the type has been converted to FT_UINT or FT_INT in the .cnf file
	//		 * display the length of this octet string instead of the octetstring itself
	//		 */
	//		if (IS_FT_UINT(hfi->type))
	//			actx->created_item = proto_tree_add_uint(tree, hf_index, out_tvb, 0, val_length, val_length);
	//		else
	//			actx->created_item = proto_tree_add_int(tree, hf_index, out_tvb, 0, val_length, val_length);
	//		proto_item_append_text(actx->created_item,
	plurality(val_length, " octet", " octets");
	//	} else {
	//		if(out_tvb){
	//			actx->created_item = proto_tree_add_item(tree, hf_index, out_tvb, 0, val_length, ENC_BIG_ENDIAN);
	//		}else{
	//			/* Length = 0 */
	//			actx->created_item = proto_tree_add_item(tree, hf_index, tvb, val_start, val_length, ENC_BIG_ENDIAN);
	//		}
	//	}
	//}
	h_225_message_value.data_output=(const guint8 *)out_tvb->real_data;
	h_225_message_value.octet_ip=(gint32*)out_tvb;
	h_245_message_value.data_output=out_tvb->real_data;
	h_245_message_value.octet_ip=(gint32*)out_tvb;
	if (value_tvb)
		*value_tvb = (out_tvb) ? out_tvb : tvb_new_subset(tvb, val_start, val_length, val_length);

	return offset;
}



static int
dissect_h245_T_nsd_data(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 985 "../../asn1/h245/h245.cnf"
  tvbuff_t *next_tvb = NULL;

  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, &next_tvb);

  if (next_tvb && tvb_length(next_tvb)) {
   // call_dissector((nsp_handle)?nsp_handle:data_handle, next_tvb/*, actx->pinfo, tree*/);
  }


  return offset;
}


static const per_sequence_t NonStandardParameter_sequence[] = {
  { &hf_h245_nonStandardIdentifier, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_NonStandardIdentifier },
  { &hf_h245_nsd_data       , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_nsd_data },
  { NULL, 0, 0, NULL }
};
const value_string h245_Capability_vals[] = {
  {   0, "nonStandard" },
  {   1, "receiveVideoCapability" },
  {   2, "transmitVideoCapability" },
  {   3, "receiveAndTransmitVideoCapability" },
  {   4, "receiveAudioCapability" },
  {   5, "transmitAudioCapability" },
  {   6, "receiveAndTransmitAudioCapability" },
  {   7, "receiveDataApplicationCapability" },
  {   8, "transmitDataApplicationCapability" },
  {   9, "receiveAndTransmitDataApplicationCapability" },
  {  10, "h233EncryptionTransmitCapability" },
  {  11, "h233EncryptionReceiveCapability" },
  {  12, "conferenceCapability" },
  {  13, "h235SecurityCapability" },
  {  14, "maxPendingReplacementFor" },
  {  15, "receiveUserInputCapability" },
  {  16, "transmitUserInputCapability" },
  {  17, "receiveAndTransmitUserInputCapability" },
  {  18, "genericControlCapability" },
  {  19, "receiveMultiplexedStreamCapability" },
  {  20, "transmitMultiplexedStreamCapability" },
  {  21, "receiveAndTransmitMultiplexedStreamCapability" },
  {  22, "receiveRTPAudioTelephonyEventCapability" },
  {  23, "receiveRTPAudioToneCapability" },
  {  24, "depFecCapability" },
  {  25, "multiplePayloadStreamCapability" },
  {  26, "fecCapability" },
  {  27, "redundancyEncodingCap" },
  {  28, "oneOfCapabilities" },
  { 0, NULL }
};

static int
dissect_h245_NonStandardParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 983 "../../asn1/h245/h245.cnf"
  nsp_handle = NULL;

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_NonStandardParameter, NonStandardParameter_sequence);

  return offset;
}


static const per_sequence_t NonStandardMessage_sequence[] = {
  { &hf_h245_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_NonStandardParameter },
  { NULL, 0, 0, NULL }
};

static const value_string h245_ResponseMessage_vals[] = {
  { ResponseMessage_nonStandard, "nonStandard" },
  { ResponseMessage_masterSlaveDeterminationAck, "masterSlaveDeterminationAck" },
  { ResponseMessage_masterSlaveDeterminationReject, "masterSlaveDeterminationReject" },
  { ResponseMessage_terminalCapabilitySetAck, "terminalCapabilitySetAck" },
  { ResponseMessage_terminalCapabilitySetReject, "terminalCapabilitySetReject" },
  { ResponseMessage_openLogicalChannelAck, "openLogicalChannelAck" },
  { ResponseMessage_openLogicalChannelReject, "openLogicalChannelReject" },
  { ResponseMessage_closeLogicalChannelAck, "closeLogicalChannelAck" },
  { ResponseMessage_requestChannelCloseAck, "requestChannelCloseAck" },
  { ResponseMessage_requestChannelCloseReject, "requestChannelCloseReject" },
  { ResponseMessage_multiplexEntrySendAck, "multiplexEntrySendAck" },
  { ResponseMessage_multiplexEntrySendReject, "multiplexEntrySendReject" },
  { ResponseMessage_requestMultiplexEntryAck, "requestMultiplexEntryAck" },
  { ResponseMessage_requestMultiplexEntryReject, "requestMultiplexEntryReject" },
  { ResponseMessage_requestModeAck, "requestModeAck" },
  { ResponseMessage_requestModeReject, "requestModeReject" },
  { ResponseMessage_roundTripDelayResponse, "roundTripDelayResponse" },
  { ResponseMessage_maintenanceLoopAck, "maintenanceLoopAck" },
  { ResponseMessage_maintenanceLoopReject, "maintenanceLoopReject" },
  { ResponseMessage_communicationModeResponse, "communicationModeResponse" },
  { ResponseMessage_conferenceResponse, "conferenceResponse" },
  { ResponseMessage_multilinkResponse, "multilinkResponse" },
  { ResponseMessage_logicalChannelRateAcknowledge, "logicalChannelRateAcknowledge" },
  { ResponseMessage_logicalChannelRateReject, "logicalChannelRateReject" },
  { ResponseMessage_genericResponse, "genericResponse" },
  { 0, NULL }
};

static int
dissect_h245_NonStandardMessage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_NonStandardMessage, NonStandardMessage_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_0_255(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("terminalType: ");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}


static int
dissect_h245_INTEGER_0_255_(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("sessionID: ");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}


static int
dissect_h245_INTEGER_0_16777215(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("statusDeterminationNumber: ");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 16777215U, NULL, FALSE);
   printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}


static const per_sequence_t MasterSlaveDetermination_sequence[] = {
  { &hf_h245_terminalType   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
  { &hf_h245_statusDeterminationNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_16777215 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MasterSlaveDetermination(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
   printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MasterSlaveDetermination, MasterSlaveDetermination_sequence);

//#line 573 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_MastSlvDet;

  return offset;
}



static int
dissect_h245_SequenceNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("sequenceNumber:");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}



static int
dissect_h245_OBJECT_IDENTIFIER(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("protocolIdentifier:");
  offset = dissect_per_object_identifier(tvb, offset, actx, hf_index, NULL);

  return offset;
}


static const value_string h245_AudioCapability_vals[] = {
  { AudioCapability_nonStandard, "nonStandard" },
  { AudioCapability_g711Alaw64k, "g711Alaw64k" },
  { AudioCapability_g711Alaw56k, "g711Alaw56k" },
  { AudioCapability_g711Ulaw64k, "g711Ulaw64k" },
  { AudioCapability_g711Ulaw56k, "g711Ulaw56k" },
  { AudioCapability_g722_64k, "g722-64k" },
  { AudioCapability_g722_56k, "g722-56k" },
  { AudioCapability_g722_48k, "g722-48k" },
  { AudioCapability_g7231, "g7231" },
  { AudioCapability_g728, "g728" },
  { AudioCapability_g729, "g729" },
  { AudioCapability_g729AnnexA, "g729AnnexA" },
  { AudioCapability_is11172AudioCapability, "is11172AudioCapability" },
  { AudioCapability_is13818AudioCapability, "is13818AudioCapability" },
  { AudioCapability_g729wAnnexB, "g729wAnnexB" },
  { AudioCapability_g729AnnexAwAnnexB, "g729AnnexAwAnnexB" },
  { AudioCapability_g7231AnnexCCapability, "g7231AnnexCCapability" },
  { AudioCapability_gsmFullRate, "gsmFullRate" },
  { AudioCapability_gsmHalfRate, "gsmHalfRate" },
  { AudioCapability_gsmEnhancedFullRate, "gsmEnhancedFullRate" },
  { AudioCapability_genericAudioCapability, "genericAudioCapability" },
  { AudioCapability_g729Extensions, "g729Extensions" },
  { AudioCapability_vbd, "vbd" },
  { AudioCapability_audioTelephonyEvent, "audioTelephonyEvent" },
  { AudioCapability_audioTone, "audioTone" },
  { 0, NULL }
};


static int
dissect_h245_INTEGER_1_256(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
   printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_AudioCapability_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s:", val_to_str(	h_245_message_value.msg_value, h245_AudioCapability_vals, "<unknown>"));
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 256U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}

static int
dissect_h245_BOOLEAN(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  	
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   
  return offset;
  
}
static int
dissect_h245_BOOLEAN_t120DynamicPortCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  	  printf("t120DynamicPortCapability:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
  
}
static int
dissect_h245_BOOLEAN_logicalChannelSwitchingCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  	  printf("logicalChannelSwitchingCapability:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
  
}
static int
dissect_h245_BOOLEAN_h261aVideoPacketization(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  	  printf("h261aVideoPacketization:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;

}
static int
dissect_h245_BOOLEAN_rtcpVideoControlCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  	  printf("rtcpVideoControlCapability:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;

}


static int
dissect_h245_BOOLEAN_decentralizedConferenceMC(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  	  printf("decentralizedConferenceMC:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;

}
static int
dissect_h245_BOOLEAN_centralizedConferenceMC(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf("centralizedConferenceMC:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;

}
static int
dissect_h245_BOOLEAN_distributedVideo(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("distributedVideo:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}

static int
dissect_h245_BOOLEAN_centralizedVideo(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("centralizedVideo:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}







static int
dissect_h245_BOOLEAN_distributedAudio(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("distributedAudio:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h245_BOOLEAN_centralizedAudio(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("centralizedAudio:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h245_BOOLEAN_distributedControl(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("distributedControl:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h245_BOOLEAN_centralizedControl(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("centralizedControl:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h245_BOOLEAN_multicastCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("multicastCapability:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h245_BOOLEAN_multiUniCastConference(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("multiUniCastConference:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
   if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h245_BOOLEAN_flowControlToZero(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	 printf("flowControlToZero: ");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
	static int
dissect_h245_BOOLEAN_mediaGuaranteedDelivery(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("mediaGuaranteedDelivery:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  
  return offset;
}
	static int
dissect_h245_BOOLEAN_silenceSuppression(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("silenceSuppression:");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_245_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}

static const per_sequence_t T_aal1_sequence[] = {
  { &hf_h245_nullClockRecovery, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_srtsClockRecovery_bool, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_adaptiveClockRecovery, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_nullErrorCorrection, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_longInterleaver, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_shortInterleaver, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_errorCorrectionOnly, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_structuredDataTransfer, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_partiallyFilledCells, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_aal1(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_aal1, T_aal1_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_0_65535(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("portNumber:");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}


static const per_sequence_t T_aal5_sequence[] = {
  { &hf_h245_forwardMaximumSDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_backwardMaximumSDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_aal5(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_aal5, T_aal5_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1_65535(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 65535U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_rangeOfBitRates_sequence[] = {
  { &hf_h245_lowerBitRate   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65535 },
  { &hf_h245_higherBitRate  , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_rangeOfBitRates(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_rangeOfBitRates, T_rangeOfBitRates_sequence);

  return offset;
}


static const value_string h245_Avb_type_vals[] = {
  {   0, "singleBitRate" },
  {   1, "rangeOfBitRates" },
  { 0, NULL }
};

static const per_choice_t Avb_type_choice[] = {
  {   0, &hf_h245_singleBitRate  , ASN1_NO_EXTENSIONS     , dissect_h245_INTEGER_1_65535 },
  {   1, &hf_h245_rangeOfBitRates, ASN1_NO_EXTENSIONS     , dissect_h245_T_rangeOfBitRates },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Avb_type(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Avb_type, Avb_type_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_availableBitRates_sequence[] = {
  { &hf_h245_avb_type       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Avb_type },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_availableBitRates(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_availableBitRates, T_availableBitRates_sequence);

  return offset;
}
/* XXX we don't do >64k length strings   yet */
static guint32
dissect_per_restricted_character_string_sorted(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, int min_len, int max_len, gboolean has_extension,const char *alphabet, int alphabet_length, tvbuff_t **value_tvb)
{
	guint32 length;
	gboolean byte_aligned;
	guint8 *buf;
	guint char_pos;
	int bits_per_char;
	guint32 old_offset;

//DEBUG_ENTRY("dissect_per_restricted_character_string");

	/* xx.x if the length is 0 bytes there will be no encoding */
	if(max_len==0){
		if (value_tvb) {
//			*value_tvb = tvb_new_child_real_data(tvb, NULL, 0, 0);
		}
		return offset;
	}


	if (min_len == NO_BOUND) {
		min_len=0;
	}


	/* 27.5.2 depending of the alphabet length, find how many bits
	   are used to encode each character */
/* unaligned PER */
	if (actx->aligned){

		if(alphabet_length<=2){
			bits_per_char=1;
		} else if(alphabet_length<=4){
			bits_per_char=2;
		} else if(alphabet_length<=16){
			bits_per_char=4;
		} else {
			bits_per_char=8;
		}
	}else{
		if(alphabet_length<=2){
			bits_per_char=1;
		} else if(alphabet_length<=4){
			bits_per_char=2;
		} else if(alphabet_length<=8){
			bits_per_char=3;
		} else if(alphabet_length<=16){
			bits_per_char=4;
		} else if(alphabet_length<=32){
			bits_per_char=5;
		} else if(alphabet_length<=64){
			bits_per_char=6;
		} else if(alphabet_length<=128){
			bits_per_char=7;
		} else {
			bits_per_char=8;
		}
	}

	if (has_extension) {
		gboolean extension_present;
		offset = dissect_per_boolean(tvb, offset, actx, hf_per_extension_present_bit, &extension_present);
		if(extension_present){
			min_len = NO_BOUND;
			max_len = NO_BOUND;
		}
	}

	byte_aligned=TRUE;
	if((min_len==max_len)&&(max_len<=2)){
		byte_aligned=FALSE;
	}
	if ((max_len != NO_BOUND) && (max_len < 2)) {
		byte_aligned=FALSE;
	}

	/* xx.x */
	length=max_len;
	if (max_len == NO_BOUND) {
		offset = dissect_per_length_determinant(tvb, offset, actx, hf_per_octet_string_length, &length);
		/* the unconstrained strings are always byte aligned (27.6.3)*/
		byte_aligned=TRUE;
	} else if(min_len!=max_len){
		offset=dissect_per_constrained_integer(tvb, offset, actx,
			 hf_per_octet_string_length, min_len, max_len,
			&length, FALSE);
			//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
	}

	if(!length){
		/* there is no string at all, so don't do any byte alignment */
		/* byte_aligned=FALSE; */
		/* Advance offset to next 'element' */
		offset = offset + 1;	}

	if((byte_aligned)&&(actx->aligned)){
		//BYTE_ALIGN_OFFSET(offset);
	}


	buf = (guint8*)malloc(length+1);
	old_offset=offset;
	for(char_pos=0;char_pos<length;char_pos++){
		guchar val;
		int i;
		gboolean bit;

		val=0;
		for(i=0;i<bits_per_char;i++){
			offset=dissect_per_boolean(tvb, offset, actx, -1, &bit);
			val=(val<<1)|bit;
		}
		/* ALIGNED PER does not do any remapping of chars if
		   bitsperchar is 8
		*/
		/* If alphabet is not provided, do not do any remapping either */
		if((bits_per_char==8) || (alphabet==NULL)){
			buf[char_pos]=val;
		} else {
			if (val < alphabet_length){
				buf[char_pos]=alphabet[val];
			} else {
				buf[char_pos] = '?';	/* XXX - how to mark this? */
			}
		}
	}
	buf[char_pos]=0;
	//proto_tree_add_string(tree, hf_index, tvb, (old_offset>>3), (offset>>3)-(old_offset>>3), (char*)buf);
	/*if (value_tvb) {
		*value_tvb = tvb_new_child_real_data(tvb, buf, length, length);
		tvb_set_free_cb(*value_tvb, g_free);
	} else {
		g_free(buf);
	}*/
	return offset;
}

guint32
dissect_per_NumericString(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, int min_len, int max_len, gboolean has_extension)
{
	offset=dissect_per_restricted_character_string_sorted(tvb, offset, actx, hf_index, min_len, max_len, has_extension,
		" 0123456789", 11, NULL);

	return offset;
}


static int
dissect_h245_NumericString_SIZE_1_16(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_NumericString(tvb, offset, actx, hf_index,
                                          1, 16, FALSE);

  return offset;
}



static int
dissect_h245_OCTET_STRING_SIZE_1_20(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 20, FALSE, NULL);

  return offset;
}


static const value_string h245_T_address_vals[] = {
  {   0, "internationalNumber" },
  {   1, "nsapAddress" },
  { 0, NULL }
};

static const per_choice_t T_address_choice[] = {
  {   0, &hf_h245_internationalNumber, ASN1_EXTENSION_ROOT    , dissect_h245_NumericString_SIZE_1_16 },
  {   1, &hf_h245_nsapAddress    , ASN1_EXTENSION_ROOT    , dissect_h245_OCTET_STRING_SIZE_1_20 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_address(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_address, T_address_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t Q2931Address_sequence[] = {
  { &hf_h245_address        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_address },
  { &hf_h245_subaddress     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OCTET_STRING_SIZE_1_20 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Q2931Address(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Q2931Address, Q2931Address_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_256_OF_Q2931Address_set_of[1] = {
  { &hf_h245_gatewayAddress_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_Q2931Address },
};
/* this function dissects a constrained set of */
guint32
dissect_per_constrained_set_of(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gint ett_index, const per_sequence_t *seq, int min_len, int max_len, gboolean has_extension)
{
	/* for basic-per  a set-of is encoded in the same way as a sequence-of */
//DEBUG_ENTRY("dissect_per_constrained_set_of");
	offset=dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index, ett_index, seq, min_len, max_len, has_extension);
	return offset;
}
static int
dissect_h245_SET_SIZE_1_256_OF_Q2931Address(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_256_OF_Q2931Address, SET_SIZE_1_256_OF_Q2931Address_set_of,
                                             1, 256, FALSE);

  return offset;
}


static const per_sequence_t T_aal1ViaGateway_sequence[] = {
  { &hf_h245_gatewayAddress , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_256_OF_Q2931Address },
  { &hf_h245_nullClockRecovery, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_srtsClockRecoveryflag, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_adaptiveClockRecovery, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_nullErrorCorrection, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_longInterleaver, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_shortInterleaver, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_errorCorrectionOnly, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_structuredDataTransfer, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_partiallyFilledCells, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_aal1ViaGateway(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_aal1ViaGateway, T_aal1ViaGateway_sequence);

  return offset;
}


static const per_sequence_t VCCapability_sequence[] = {
  { &hf_h245_aal1           , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_aal1 },
  { &hf_h245_aal5           , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_aal5 },
  { &hf_h245_transportStream_bool, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_programStream  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_availableBitRates, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_availableBitRates },
  { &hf_h245_aal1ViaGateway , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_T_aal1ViaGateway },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_VCCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_VCCapability, VCCapability_sequence);

  return offset;
}


static const per_sequence_t SET_OF_VCCapability_set_of[1] = {
  { &hf_h245_vcCapability_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_VCCapability },
};
/* this function dissects a set of */
guint32
dissect_per_set_of(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gint ett_index, const per_sequence_t *seq)
{
	/* for basic-per  a set-of is encoded in the same way as a sequence-of */
//DEBUG_ENTRY("dissect_per_set_of");
	offset=dissect_per_sequence_of(tvb, offset, actx, hf_index, ett_index, seq);
	return offset;
}
static int
dissect_h245_SET_OF_VCCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_set_of(tvb, offset, actx, hf_index,
                                 ett_h245_SET_OF_VCCapability, SET_OF_VCCapability_set_of);

  return offset;
}


static const per_sequence_t H222Capability_sequence[] = {
  { &hf_h245_numberOfVCs    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_256 },
  { &hf_h245_vcCapability   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_OF_VCCapability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H222Capability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H222Capability, H222Capability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_0_1023(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("maximumAudioDelayJitter:");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 1023U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}

guint32
dissect_per_null(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index) {
  proto_item *ti_tmp;

  //ti_tmp = proto_tree_add_item( hf_index, tvb, offset>>3, 1, ENC_BIG_ENDIAN);
 // proto_item_append_text(ti_tmp, 
  printf("NULL\n");

  return offset;
}
static const value_string h245_T_decision_vals[] = {
  {   0, "master" },
  {   1, "slave" },
  { 0, NULL }
};
static int
dissect_h245_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static int
dissect_h245_NULL_master(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
 printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_T_decision_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s :", val_to_str(	h_245_message_value.msg_value, h245_T_decision_vals, "<unknown>"));
  offset = dissect_per_null(tvb, offset, actx, hf_index);
  
  return offset;
}

static int
dissect_h245_NULL_slave(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
   printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_T_decision_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s :", val_to_str(	h_245_message_value.msg_value, h245_T_decision_vals, "<unknown>"));
  offset = dissect_per_null(tvb, offset, actx, hf_index);
  
  return offset;
}


static int
dissect_h245_INTEGER_1_15(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 15U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_2_255(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            2U, 255U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_enhanced_sequence[] = {
  { &hf_h245_maximumNestingDepth, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_15 },
  { &hf_h245_maximumElementListSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_2_255 },
  { &hf_h245_maximumSubElementListSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_2_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_enhanced(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_enhanced, T_enhanced_sequence);

  return offset;
}


static const value_string h245_T_h223MultiplexTableCapability_vals[] = {
  {   0, "basic" },
  {   1, "enhanced" },
  { 0, NULL }
};

static const per_choice_t T_h223MultiplexTableCapability_choice[] = {
  {   0, &hf_h245_basic          , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_enhanced       , ASN1_NO_EXTENSIONS     , dissect_h245_T_enhanced },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_h223MultiplexTableCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_h223MultiplexTableCapability, T_h223MultiplexTableCapability_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_mobileOperationTransmitCapability_sequence[] = {
  { &hf_h245_modeChangeCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_h223AnnexA     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_h223AnnexADoubleFlagFlag, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_h223AnnexB     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_h223AnnexBwithHeader, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_mobileOperationTransmitCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_mobileOperationTransmitCapability, T_mobileOperationTransmitCapability_sequence);

  return offset;
}


static const per_sequence_t H223AnnexCCapability_sequence[] = {
  { &hf_h245_videoWithAL1M  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoWithAL2M  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoWithAL3M  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioWithAL1M  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioWithAL2M  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioWithAL3M  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dataWithAL1M   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dataWithAL2M   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dataWithAL3M   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_alpduInterleaving, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_maximumAL1MPDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_maximumAL2MSDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_maximumAL3MSDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_rsCodeCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H223AnnexCCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H223AnnexCCapability, H223AnnexCCapability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1_19200(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 19200U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_255(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("sessionID:");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 255U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}



static int
dissect_h245_INTEGER_1_65025(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 65025U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_mobileMultilinkFrameCapability_sequence[] = {
  { &hf_h245_maximumSampleSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { &hf_h245_maximumPayloadLength, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65025 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_mobileMultilinkFrameCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_mobileMultilinkFrameCapability, T_mobileMultilinkFrameCapability_sequence);

  return offset;
}


static const per_sequence_t H223Capability_sequence[] = {
  { &hf_h245_transportWithI_frames, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoWithAL1   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoWithAL2   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoWithAL3   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioWithAL1   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioWithAL2   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioWithAL3   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dataWithAL1    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dataWithAL2    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dataWithAL3    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_maximumAl2SDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_maximumAl3SDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_maximumDelayJitter, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_1023 },
  { &hf_h245_h223MultiplexTableCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_h223MultiplexTableCapability },
  { &hf_h245_maxMUXPDUSizeCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_nsrpSupport    , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_mobileOperationTransmitCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_T_mobileOperationTransmitCapability },
  { &hf_h245_h223AnnexCCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_H223AnnexCCapability },
  { &hf_h245_bitRate_1_19200, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_1_19200 },
  { &hf_h245_mobileMultilinkFrameCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_T_mobileMultilinkFrameCapability },
  { NULL, 0, 0, NULL }
};

int
dissect_h245_H223Capability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H223Capability, H223Capability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_2_8191(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            2U, 8191U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_4095(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 4095U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_127(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 127U, NULL, FALSE);

  return offset;
}


static const per_sequence_t V75Capability_sequence[] = {
  { &hf_h245_audioHeader    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_V75Capability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_V75Capability, V75Capability_sequence);

  return offset;
}


static const per_sequence_t V76Capability_sequence[] = {
  { &hf_h245_suspendResumeCapabilitywAddress, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_suspendResumeCapabilitywoAddress, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_rejCapability  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_sREJCapability , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_mREJCapability , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_crc8bitCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_crc16bitCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_crc32bitCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_uihCapability  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_numOfDLCS      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_2_8191 },
  { &hf_h245_twoOctetAddressFieldCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_loopBackTestCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_n401Capability , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_4095 },
  { &hf_h245_maxWindowSizeCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_127 },
  { &hf_h245_v75Capability  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_V75Capability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_V76Capability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_V76Capability, V76Capability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1_65536(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 65536U, NULL, FALSE);

  return offset;
}


static const per_sequence_t V42bis_sequence[] = {
  { &hf_h245_numberOfCodewords, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65536 },
  { &hf_h245_maximumStringLength, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_256 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_V42bis(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_V42bis, V42bis_sequence);

  return offset;
}


static const value_string h245_CompressionType_vals[] = {
  {   0, "v42bis" },
  { 0, NULL }
};

static const per_choice_t CompressionType_choice[] = {
  {   0, &hf_h245_v42bis         , ASN1_EXTENSION_ROOT    , dissect_h245_V42bis },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_CompressionType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_CompressionType, CompressionType_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_v76wCompression_vals[] = {
  {   0, "transmitCompression" },
  {   1, "receiveCompression" },
  {   2, "transmitAndReceiveCompression" },
  { 0, NULL }
};

static const per_choice_t T_v76wCompression_choice[] = {
  {   0, &hf_h245_transmitCompression, ASN1_EXTENSION_ROOT    , dissect_h245_CompressionType },
  {   1, &hf_h245_receiveCompression, ASN1_EXTENSION_ROOT    , dissect_h245_CompressionType },
  {   2, &hf_h245_transmitAndReceiveCompression, ASN1_EXTENSION_ROOT    , dissect_h245_CompressionType },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_v76wCompression(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_v76wCompression, T_v76wCompression_choice,
                                 NULL);

  return offset;
}


const value_string DataProtocolCapability_vals[] = {
  {   0, "nonStandard" },
  {   1, "v14buffered" },
  {   2, "v42lapm" },
  {   3, "hdlcFrameTunnelling" },
  {   4, "h310SeparateVCStack" },
  {   5, "h310SingleVCStack" },
  {   6, "transparent" },
  {   7, "segmentationAndReassembly" },
  {   8, "hdlcFrameTunnelingwSAR" },
  {   9, "v120" },
  {  10, "separateLANStack" },
  {  11, "v76wCompression" },
  {  12, "tcp" },
  {  13, "udp" },
  { 0, NULL }
};

static const per_choice_t DataProtocolCapability_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_v14buffered    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_v42lapm        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_hdlcFrameTunnelling, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_h310SeparateVCStack, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_h310SingleVCStack, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_transparent    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   7, &hf_h245_segmentationAndReassembly, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   8, &hf_h245_hdlcFrameTunnelingwSAR, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   9, &hf_h245_v120           , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  10, &hf_h245_separateLANStack, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  11, &hf_h245_v76wCompression, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_v76wCompression },
  {  12, &hf_h245_tcp            , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  13, &hf_h245_udp            , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

int
dissect_h245_DataProtocolCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_DataProtocolCapability, DataProtocolCapability_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_t84Restricted_sequence[] = {
  { &hf_h245_qcif_bool      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_cif_bool       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_ccir601Seq     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_ccir601Prog    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_hdtvSeq        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_hdtvProg       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_g3FacsMH200x100, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_g3FacsMH200x200, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_g4FacsMMR200x100, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_g4FacsMMR200x200, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_jbig200x200Seq , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_jbig200x200Prog, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_jbig300x300Seq , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_jbig300x300Prog, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_digPhotoLow    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_digPhotoMedSeq , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_digPhotoMedProg, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_digPhotoHighSeq, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_digPhotoHighProg, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_t84Restricted(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_t84Restricted, T_t84Restricted_sequence);

  return offset;
}


static const value_string h245_T84Profile_vals[] = {
  {   0, "t84Unrestricted" },
  {   1, "t84Restricted" },
  { 0, NULL }
};

static const per_choice_t T84Profile_choice[] = {
  {   0, &hf_h245_t84Unrestricted, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_t84Restricted  , ASN1_NO_EXTENSIONS     , dissect_h245_T_t84Restricted },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T84Profile(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T84Profile, T84Profile_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_t84_sequence[] = {
  { &hf_h245_t84Protocol    , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_DataProtocolCapability },
  { &hf_h245_t84Profile     , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T84Profile },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_t84(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_t84, T_t84_sequence);

  return offset;
}



static int
dissect_h245_OCTET_STRING(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, NULL);

  return offset;
}


static const per_sequence_t Nlpid_sequence[] = {
  { &hf_h245_nlpidProtocol  , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_DataProtocolCapability },
  { &hf_h245_nlpidData      , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Nlpid(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Nlpid, Nlpid_sequence);

  return offset;
}


static const value_string h245_T38FaxRateManagement_vals[] = {
  {   0, "localTCF" },
  {   1, "transferredTCF" },
  { 0, NULL }
};

static const per_choice_t T38FaxRateManagement_choice[] = {
  {   0, &hf_h245_localTCF       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_transferredTCF , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T38FaxRateManagement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T38FaxRateManagement, T38FaxRateManagement_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_INTEGER(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_integer(tvb, offset, actx, hf_index, NULL);

  return offset;
}


static const value_string h245_T_t38FaxUdpEC_vals[] = {
  {   0, "t38UDPFEC" },
  {   1, "t38UDPRedundancy" },
  { 0, NULL }
};

static const per_choice_t T_t38FaxUdpEC_choice[] = {
  {   0, &hf_h245_t38UDPFEC      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_t38UDPRedundancy, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_t38FaxUdpEC(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_t38FaxUdpEC, T_t38FaxUdpEC_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T38FaxUdpOptions_sequence[] = {
  { &hf_h245_t38FaxMaxBuffer, ASN1_NO_EXTENSIONS     , ASN1_OPTIONAL    , dissect_h245_INTEGER },
  { &hf_h245_t38FaxMaxDatagram, ASN1_NO_EXTENSIONS     , ASN1_OPTIONAL    , dissect_h245_INTEGER },
  { &hf_h245_t38FaxUdpEC    , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_t38FaxUdpEC },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T38FaxUdpOptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T38FaxUdpOptions, T38FaxUdpOptions_sequence);

  return offset;
}


static const per_sequence_t T38FaxTcpOptions_sequence[] = {
  { &hf_h245_t38TCPBidirectionalMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T38FaxTcpOptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T38FaxTcpOptions, T38FaxTcpOptions_sequence);

  return offset;
}


static const per_sequence_t T38FaxProfile_sequence[] = {
  { &hf_h245_fillBitRemoval , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_transcodingJBIG, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_transcodingMMR , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_version        , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
  { &hf_h245_t38FaxRateManagement, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_T38FaxRateManagement },
  { &hf_h245_t38FaxUdpOptions, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_T38FaxUdpOptions },
  { &hf_h245_t38FaxTcpOptions, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_T38FaxTcpOptions },
  { NULL, 0, 0, NULL }
};

int
dissect_h245_T38FaxProfile(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T38FaxProfile, T38FaxProfile_sequence);

  return offset;
}


static const per_sequence_t T_t38fax_sequence[] = {
  { &hf_h245_t38FaxProtocol , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_DataProtocolCapability },
  { &hf_h245_t38FaxProfile  , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T38FaxProfile },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_t38fax(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_t38fax, T_t38fax_sequence);

  return offset;
}



static int
dissect_h245_T_standardOid(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 730 "../../asn1/h245/h245.cnf"
  const gchar *standard_oid_str = NULL;
 // gef_ctx_t *gefx;

  offset = dissect_per_object_identifier_str(tvb, offset, actx, hf_index, &standard_oid_str);

  //gefx = gef_ctx_get(actx->private_data);
  //if (gefx) gefx->id = standard_oid_str;

  if(strcmp(standard_oid_str,"0.0.8.235.0.3.76") == 0) {  /* MIKEY */
    if (upcoming_channel)
	  upcoming_channel->srtp_flag = TRUE;
  }

  if(!h245_lc_dissector && strcmp(standard_oid_str,"0.0.8.245.1.1.1") == 0)
	h245_lc_dissector = amr_handle;


  return offset;
}



static int
dissect_h245_OCTET_STRING_SIZE_16(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       16, 16, FALSE, NULL);

  return offset;
}

guint32
dissect_per_IA5String(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx,int hf_index, int min_len, int max_len, gboolean has_extension)
{
	offset=dissect_per_restricted_character_string_sorted(tvb, offset, actx, hf_index, min_len, max_len, has_extension,
		NULL, 128, NULL);

	return offset;
}

static int
dissect_h245_IA5String_SIZE_1_64(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_IA5String(tvb, offset, actx, hf_index,
                                          1, 64, FALSE);

  return offset;
}


static const value_string h245_CapabilityIdentifier_vals[] = {
  {   0, "standard" },
  {   1, "h221NonStandard" },
  {   2, "uuid" },
  {   3, "domainBased" },
  { 0, NULL }
};

static const per_choice_t CapabilityIdentifier_choice[] = {
  {   0, &hf_h245_standardOid    , ASN1_EXTENSION_ROOT    , dissect_h245_T_standardOid },
  {   1, &hf_h245_h221NonStandard, ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   2, &hf_h245_uuid           , ASN1_EXTENSION_ROOT    , dissect_h245_OCTET_STRING_SIZE_16 },
  {   3, &hf_h245_domainBased    , ASN1_EXTENSION_ROOT    , dissect_h245_IA5String_SIZE_1_64 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_CapabilityIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 716 "../../asn1/h245/h245.cnf"
//  gef_ctx_t *gefx;

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_CapabilityIdentifier, CapabilityIdentifier_choice,
                                 NULL);

//#line 718 "../../asn1/h245/h245.cnf"
  //gef_ctx_update_key(gef_ctx_get(actx->private_data));
  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG CapabilityIdentifier: %s", gef_ctx_get(actx->private_data)->key);*/
  //gefx = gef_ctx_get(actx->private_data);
  //if (gefx) {
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  //  actx->pinfo->private_data = actx;
  //  dissector_try_string(gef_name_dissector_table, gefx->key, tvb_new_subset(tvb, offset>>3, 0, 0), actx->pinfo, tree);
  //}
  //actx->private_data = gefx;  /* subdissector could overwrite it */

  return offset;
}



static int
dissect_h245_INTEGER_0_4294967295(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 4294967295U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_T_standard(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 761 "../../asn1/h245/h245.cnf"
  guint32 value_int = (guint32)-1;
//  gef_ctx_t *gefx;

  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 127U, &value_int, FALSE);

  //gefx = gef_ctx_get(actx->private_data);
 // if (gefx) gefx->id = ep_strdup_printf("%d", value_int);


  return offset;
}


static const value_string h245_ParameterIdentifier_vals[] = {
  {   0, "standard" },
  {   1, "h221NonStandard" },
  {   2, "uuid" },
  {   3, "domainBased" },
  { 0, NULL }
};

static const per_choice_t ParameterIdentifier_choice[] = {
  {   0, &hf_h245_standard       , ASN1_EXTENSION_ROOT    , dissect_h245_T_standard },
  {   1, &hf_h245_h221NonStandard, ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   2, &hf_h245_uuid           , ASN1_EXTENSION_ROOT    , dissect_h245_OCTET_STRING_SIZE_16 },
  {   3, &hf_h245_domainBased    , ASN1_EXTENSION_ROOT    , dissect_h245_IA5String_SIZE_1_64 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ParameterIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 747 "../../asn1/h245/h245.cnf"
 // gef_ctx_t *gefx;

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ParameterIdentifier, ParameterIdentifier_choice,
                                 NULL);

//#line 749 "../../asn1/h245/h245.cnf"
 // gef_ctx_update_key(gef_ctx_get(actx->private_data));
  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG ParameterIdentifier: %s", gef_ctx_get(actx->private_data)->key);*/
 // gefx = gef_ctx_get(actx->private_data);
  //if (gefx) {
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  //  actx->pinfo->private_data = actx;
  //  dissector_try_string(gef_name_dissector_table, gefx->key, tvb_new_subset(tvb, offset>>3, 0, 0), actx->pinfo);
  //}
 // actx->private_data = gefx;  /* subdissector could overwrite it */

  return offset;
}



static int
dissect_h245_T_booleanArray(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 770 "../../asn1/h245/h245.cnf"
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
 // gef_ctx_t *gefx;

  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, &value, FALSE);

  //gefx = gef_ctx_get(actx->private_data);
  //if (gefx) {
  //  buf = ep_alloc(sizeof(guint8));
  //  buf[0] = value;
  //  value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint8), sizeof(guint8));
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  //  add_new_data_source(actx->pinfo, value_tvb, "booleanArray");
  //  dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, actx->pinfo, tree);
  //}


  return offset;
}



static int
dissect_h245_T_unsignedMin(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 787 "../../asn1/h245/h245.cnf"
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
//  gef_ctx_t *gefx;

  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, &value, FALSE);

  //gefx = gef_ctx_get(actx->private_data);
  //if (gefx) {
  //  buf = ep_alloc(sizeof(guint16));
  //  phtons(buf, value);
  //  value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint16), sizeof(guint16));
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  //  add_new_data_source(actx->pinfo, value_tvb, "unsignedMin");
  //  dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, actx->pinfo, tree);
  //}


  return offset;
}



static int
dissect_h245_T_unsignedMax(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 804 "../../asn1/h245/h245.cnf"
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
 // gef_ctx_t *gefx;

  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, &value, FALSE);

  //gefx = gef_ctx_get(actx->private_data);
  //if (gefx) {
  //  buf = ep_alloc(sizeof(guint16));
  //  phtons(buf, value);
  //  value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint16), sizeof(guint16));
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  //  add_new_data_source(actx->pinfo, value_tvb, "unsignedMax");
  //  dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, actx->pinfo, tree);
  //}


  return offset;
}



static int
dissect_h245_T_unsigned32Min(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 821 "../../asn1/h245/h245.cnf"
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
 // gef_ctx_t *gefx;

  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 4294967295U, &value, FALSE);

  //gefx = gef_ctx_get(actx->private_data);
  //if (gefx) {
  //  buf = ep_alloc(sizeof(guint32));
  //  phtonl(buf, value);
  //  value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint32), sizeof(guint32));
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  //  add_new_data_source(actx->pinfo, value_tvb, "unsigned32Min");
  //  dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, actx->pinfo, tree);
  //}


  return offset;
}



static int
dissect_h245_T_unsigned32Max(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 838 "../../asn1/h245/h245.cnf"
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
//  gef_ctx_t *gefx;

  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 4294967295U, &value, FALSE);

  //gefx = gef_ctx_get(actx->private_data);
  //if (gefx) {
  //  buf = ep_alloc(sizeof(guint32));
  //  phtonl(buf, value);
  //  value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint32), sizeof(guint32));
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  //  add_new_data_source(actx->pinfo, value_tvb, "unsigned32Max");
  //  dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, actx->pinfo, tree);
  //}


  return offset;
}



static int
dissect_h245_T_octetString(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 855 "../../asn1/h245/h245.cnf"
  tvbuff_t *value_tvb;
  //gef_ctx_t *gefx;

  //offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
  //                                     NO_BOUND, NO_BOUND, FALSE, &value_tvb);

  //gefx = gef_ctx_get(actx->private_data);
  //if (gefx) {
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  //  dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, actx->pinfo, tree);
  //}


  return offset;
}


static const per_sequence_t SEQUENCE_OF_GenericParameter_sequence_of[1] = {
  { &hf_h245_genericParameters_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_GenericParameter },
};
guint32
dissect_per_sequence_of(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gint ett_index, const per_sequence_t *seq)
{
	proto_item *item;
	//proto_tree *tree;
	guint32 old_offset=offset;
	guint32 length;
	header_field_info *hfi;

//DEBUG_ENTRY("dissect_per_sequence_of");

	/* semi-constrained whole number for number of elements */
	/* each element encoded as 10.9 */

	offset=dissect_per_length_determinant(tvb, offset, actx,hf_per_sequence_of_length, &length);

	//hfi = proto_registrar_get_nth(hf_index);
	//if (IS_FT_UINT(hfi->type)) {
	//	item = proto_tree_add_uint(parent_tree, hf_index, tvb, old_offset>>3, 0, length);
	//	proto_item_append_text(item, (length==1)?" item":" items");
	//} else {
	//	item=proto_tree_add_item(parent_tree, hf_index, tvb, old_offset>>3, 0, ENC_BIG_ENDIAN);
	//}
	//tree=proto_item_add_subtree(item, ett_index);

	offset=dissect_per_sequence_of_helper(tvb, offset, actx, seq->func, *seq->p_id, length);


	//proto_item_set_len(item, (offset>>3)!=(old_offset>>3)?(offset>>3)-(old_offset>>3):1);
	return offset;
}


static int
dissect_h245_SEQUENCE_OF_GenericParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_GenericParameter, SEQUENCE_OF_GenericParameter_sequence_of);

  return offset;
}


static const value_string h245_ParameterValue_vals[] = {
  {   0, "logical" },
  {   1, "booleanArray" },
  {   2, "unsignedMin" },
  {   3, "unsignedMax" },
  {   4, "unsigned32Min" },
  {   5, "unsigned32Max" },
  {   6, "octetString" },
  {   7, "genericParameter" },
  { 0, NULL }
};

static const per_choice_t ParameterValue_choice[] = {
  {   0, &hf_h245_logical        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_booleanArray   , ASN1_EXTENSION_ROOT    , dissect_h245_T_booleanArray },
  {   2, &hf_h245_unsignedMin    , ASN1_EXTENSION_ROOT    , dissect_h245_T_unsignedMin },
  {   3, &hf_h245_unsignedMax    , ASN1_EXTENSION_ROOT    , dissect_h245_T_unsignedMax },
  {   4, &hf_h245_unsigned32Min  , ASN1_EXTENSION_ROOT    , dissect_h245_T_unsigned32Min },
  {   5, &hf_h245_unsigned32Max  , ASN1_EXTENSION_ROOT    , dissect_h245_T_unsigned32Max },
  {   6, &hf_h245_octetString    , ASN1_EXTENSION_ROOT    , dissect_h245_T_octetString },
  {   7, &hf_h245_genericParameters, ASN1_EXTENSION_ROOT    , dissect_h245_SEQUENCE_OF_GenericParameter },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ParameterValue(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ParameterValue, ParameterValue_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_ParameterIdentifier_sequence_of[1] = {
  { &hf_h245_supersedes_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_ParameterIdentifier },
};

static int
dissect_h245_SEQUENCE_OF_ParameterIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_ParameterIdentifier, SEQUENCE_OF_ParameterIdentifier_sequence_of);

  return offset;
}


static const per_sequence_t GenericParameter_sequence[] = {
  { &hf_h245_parameterIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ParameterIdentifier },
  { &hf_h245_parameterValue , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ParameterValue },
  { &hf_h245_supersedes     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_ParameterIdentifier },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_GenericParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_GenericParameter, GenericParameter_sequence);

  return offset;
}



static int
dissect_h245_T_collapsing_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 672 "../../asn1/h245/h245.cnf"
//  gef_ctx_t *parent_gefx;

  //parent_gefx = gef_ctx_get(actx->private_data);
  //actx->private_data = gef_ctx_alloc(parent_gefx, "collapsing");

  offset = dissect_h245_GenericParameter(tvb, offset, actx, hf_index);

//#line 677 "../../asn1/h245/h245.cnf"
 // actx->private_data = parent_gefx;

  return offset;
}


static const per_sequence_t T_collapsing_sequence_of[1] = {
  { &hf_h245_collapsing_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_collapsing_item },
};

static int
dissect_h245_T_collapsing(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_T_collapsing, T_collapsing_sequence_of);

  return offset;
}



static int
dissect_h245_T_nonCollapsing_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 681 "../../asn1/h245/h245.cnf"
 // gef_ctx_t *parent_gefx;

  //parent_gefx = gef_ctx_get(actx->private_data);
 // actx->private_data = gef_ctx_alloc(parent_gefx, "nonCollapsing");

  offset = dissect_h245_GenericParameter(tvb, offset, actx, hf_index);

//#line 686 "../../asn1/h245/h245.cnf"
  //actx->private_data = parent_gefx;

  return offset;
}


static const per_sequence_t T_nonCollapsing_sequence_of[1] = {
  { &hf_h245_nonCollapsing_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_nonCollapsing_item },
};

static int
dissect_h245_T_nonCollapsing(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_T_nonCollapsing, T_nonCollapsing_sequence_of);

  return offset;
}



static int
dissect_h245_T_nonCollapsingRaw(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 690 "../../asn1/h245/h245.cnf"
  tvbuff_t *value_tvb;
  //gef_ctx_t *parent_gefx;
  //gef_ctx_t *gefx;

  //parent_gefx = gef_ctx_get(actx->private_data);
  //actx->private_data = gef_ctx_alloc(parent_gefx, "nonCollapsingRaw");
  //offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
  //                                     NO_BOUND, NO_BOUND, FALSE, &value_tvb);

  //gefx = gef_ctx_get(actx->private_data);
  //if (gefx) {
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  //  actx->pinfo->private_data = actx;
  //  dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, actx->pinfo, tree);
  //}
  //actx->private_data = parent_gefx;


  return offset;
}


static const per_sequence_t GenericCapability_sequence[] = {
  { &hf_h245_capabilityIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityIdentifier },
  { &hf_h245_maxBitRate2_0_4294967295, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_4294967295 },
  { &hf_h245_collapsing     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_collapsing },
  { &hf_h245_nonCollapsing  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_nonCollapsing },
  { &hf_h245_nonCollapsingRaw, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_nonCollapsingRaw },
  { &hf_h245_transport      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_DataProtocolCapability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_GenericCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 665 "../../asn1/h245/h245.cnf"
  void *priv_data = actx->private_data;
 // actx->private_data = gef_ctx_alloc(NULL, "GenericCapability");

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_GenericCapability, GenericCapability_sequence);

//#line 668 "../../asn1/h245/h245.cnf"
  actx->private_data = priv_data;

  return offset;
}


static const value_string h245_Application_vals[] = {
  {   0, "nonStandard" },
  {   1, "t120" },
  {   2, "dsm-cc" },
  {   3, "userData" },
  {   4, "t84" },
  {   5, "t434" },
  {   6, "h224" },
  {   7, "nlpid" },
  {   8, "dsvdControl" },
  {   9, "h222DataPartitioning" },
  {  10, "t30fax" },
  {  11, "t140" },
  {  12, "t38fax" },
  {  13, "genericDataCapability" },
  { 0, NULL }
};

static const per_choice_t Application_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_t120           , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   2, &hf_h245_dsm_cc         , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   3, &hf_h245_userData       , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   4, &hf_h245_t84            , ASN1_EXTENSION_ROOT    , dissect_h245_T_t84 },
  {   5, &hf_h245_t434           , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   6, &hf_h245_h224           , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   7, &hf_h245_nlpid          , ASN1_EXTENSION_ROOT    , dissect_h245_Nlpid },
  {   8, &hf_h245_dsvdControl    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   9, &hf_h245_h222DataPartitioning, ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {  10, &hf_h245_t30fax         , ASN1_NOT_EXTENSION_ROOT, dissect_h245_DataProtocolCapability },
  {  11, &hf_h245_t140           , ASN1_NOT_EXTENSION_ROOT, dissect_h245_DataProtocolCapability },
  {  12, &hf_h245_t38fax         , ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_t38fax },
  {  13, &hf_h245_genericDataCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericCapability },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Application(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 503 "../../asn1/h245/h245.cnf"
  gint32 value;

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Application, Application_choice,
                                 &value);

        codec_type = val_to_str(value, h245_Application_vals, "<unknown>");


  return offset;
}


static const per_sequence_t DataApplicationCapability_sequence[] = {
  { &hf_h245_application    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Application },
  { &hf_h245_maxBitRate2_0_4294967295, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_4294967295 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_DataApplicationCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_DataApplicationCapability, DataApplicationCapability_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_DataApplicationCapability_sequence_of[1] = {
  { &hf_h245_centralizedData_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_DataApplicationCapability },
};

static int
dissect_h245_SEQUENCE_OF_DataApplicationCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("centralizedData\n");
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_DataApplicationCapability, SEQUENCE_OF_DataApplicationCapability_sequence_of);

  return offset;
}


static const per_sequence_t MediaDistributionCapability_sequence[] = {
  { &hf_h245_centralizedControl, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_centralizedControl },
  { &hf_h245_distributedControl, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_distributedControl },
  { &hf_h245_centralizedAudio, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_centralizedAudio },
  { &hf_h245_distributedAudio, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_distributedAudio },
  { &hf_h245_centralizedVideo, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_centralizedVideo },
  { &hf_h245_distributedVideo, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_distributedVideo },
  { &hf_h245_centralizedData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_DataApplicationCapability },
  { &hf_h245_distributedData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_DataApplicationCapability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MediaDistributionCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("MediaDistributionCapability\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MediaDistributionCapability, MediaDistributionCapability_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_MediaDistributionCapability_sequence_of[1] = {
  { &hf_h245_mediaDistributionCapability_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MediaDistributionCapability },
};

static int
dissect_h245_SEQUENCE_OF_MediaDistributionCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("mediaDistributionCapability:");
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_MediaDistributionCapability, SEQUENCE_OF_MediaDistributionCapability_sequence_of);

  return offset;
}


static const per_sequence_t MultipointCapability_sequence[] = {
  { &hf_h245_multicastCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_multicastCapability },
  { &hf_h245_multiUniCastConference, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_multiUniCastConference },
  { &hf_h245_mediaDistributionCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SEQUENCE_OF_MediaDistributionCapability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultipointCapability_transmitMultipointCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("transmitMultipointCapability\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultipointCapability, MultipointCapability_sequence);

  return offset;
}
static int
dissect_h245_MultipointCapability_receiveAndTransmitMultipointCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("receiveAndTransmitMultipointCapability\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultipointCapability, MultipointCapability_sequence);

  return offset;
}
static int
dissect_h245_MultipointCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("receiveMultipointCapability\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultipointCapability, MultipointCapability_sequence);

  return offset;
}

static const per_sequence_t T_mcCapability_sequence[] = {
  { &hf_h245_centralizedConferenceMC, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_centralizedConferenceMC },
  { &hf_h245_decentralizedConferenceMC, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_decentralizedConferenceMC },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_mcCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("mcCapability\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_mcCapability, T_mcCapability_sequence);

  return offset;
}



static int
dissect_h245_T_rfc_number(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 32768U, &rfc_number, TRUE);

  return offset;
}


static const value_string h245_T_payloadDescriptor_vals[] = {
  {   0, "nonStandardIdentifier" },
  {   1, "rfc-number" },
  {   2, "oid" },
  { 0, NULL }
};

static const per_choice_t T_payloadDescriptor_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_rfc_number     , ASN1_EXTENSION_ROOT    , dissect_h245_T_rfc_number },
  {   2, &hf_h245_oid            , ASN1_EXTENSION_ROOT    , dissect_h245_OBJECT_IDENTIFIER },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_payloadDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_payloadDescriptor, T_payloadDescriptor_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_T_rtpPayloadType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 936 "../../asn1/h245/h245.cnf"
  unsigned int pt;

  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 127U, &pt, FALSE);


  if ((rfc_number == 2198) && upcoming_channel) {
    upcoming_channel->rfc2198 = pt;
  }


  return offset;
}


static const per_sequence_t RTPPayloadType_sequence[] = {
  { &hf_h245_payloadDescriptor, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_payloadDescriptor },
  { &hf_h245_rtpPayloadType_01, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_rtpPayloadType },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RTPPayloadType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 928 "../../asn1/h245/h245.cnf"
  rfc_number = 0;

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RTPPayloadType, RTPPayloadType_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_SIZE_1_256_OF_RTPPayloadType_sequence_of[1] = {
  { &hf_h245_rtpPayloadTypes_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_RTPPayloadType },
};

static int
dissect_h245_SEQUENCE_SIZE_1_256_OF_RTPPayloadType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_SEQUENCE_SIZE_1_256_OF_RTPPayloadType, SEQUENCE_SIZE_1_256_OF_RTPPayloadType_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t MediaPacketizationCapability_sequence[] = {
  { &hf_h245_h261aVideoPacketization, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_h261aVideoPacketization },
  { &hf_h245_rtpPayloadTypes, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_SIZE_1_256_OF_RTPPayloadType },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MediaPacketizationCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("mediaPacketizationCapability\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MediaPacketizationCapability, MediaPacketizationCapability_sequence);

  return offset;
}


static const value_string h245_QOSMode_vals[] = {
  {   0, "guaranteedQOS" },
  {   1, "controlledLoad" },
  { 0, NULL }
};

static const per_choice_t QOSMode_choice[] = {
  {   0, &hf_h245_guaranteedQOS  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_controlledLoad , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_QOSMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_QOSMode, QOSMode_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_INTEGER_1_4294967295(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 4294967295U, NULL, FALSE);

  return offset;
}


static const per_sequence_t RSVPParameters_sequence[] = {
  { &hf_h245_qosMode        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_QOSMode },
  { &hf_h245_tokenRate      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { &hf_h245_bucketSize     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { &hf_h245_peakRate       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { &hf_h245_minPoliced     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { &hf_h245_maxPktSize     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RSVPParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RSVPParameters, RSVPParameters_sequence);

  return offset;
}


static const per_sequence_t ATMParameters_sequence[] = {
  { &hf_h245_maxNTUSize     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_atmUBR         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_atmrtVBR       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_atmnrtVBR      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_atmABR         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_atmCBR         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_ATMParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_ATMParameters, ATMParameters_sequence);

  return offset;
}


static const per_sequence_t GenericTransportParameters_sequence[] = {
  { &hf_h245_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { &hf_h245_averageRate    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { &hf_h245_burst          , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { &hf_h245_peakRate       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { &hf_h245_maxPktSize     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_GenericTransportParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_GenericTransportParameters, GenericTransportParameters_sequence);

  return offset;
}


static const per_sequence_t ServicePriorityValue_sequence[] = {
  { &hf_h245_nonStandardParameter, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { &hf_h245_value          , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_ServicePriorityValue(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_ServicePriorityValue, ServicePriorityValue_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_0_4095(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 4095U, NULL, FALSE);

  return offset;
}


static const per_sequence_t ServicePriority_sequence[] = {
  { &hf_h245_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { &hf_h245_servicePrioritySignalled, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_servicePriorityValue, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_ServicePriorityValue },
  { &hf_h245_serviceClass   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_0_4095 },
  { &hf_h245_serviceSubclass, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_0_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_ServicePriority(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_ServicePriority, ServicePriority_sequence);

  return offset;
}


static const per_sequence_t AuthorizationParameters_sequence[] = {
  { &hf_h245_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_AuthorizationParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_AuthorizationParameters, AuthorizationParameters_sequence);

  return offset;
}


static const value_string h245_QOSType_vals[] = {
  {   0, "desired" },
  {   1, "required" },
  { 0, NULL }
};

static const per_choice_t QOSType_choice[] = {
  {   0, &hf_h245_desired        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_required       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_QOSType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_QOSType, QOSType_choice,
                                 NULL);

  return offset;
}


static const value_string h245_QOSClass_vals[] = {
  {   0, "class0" },
  {   1, "class1" },
  {   2, "class2" },
  {   3, "class3" },
  {   4, "class4" },
  {   5, "class5" },
  { 0, NULL }
};

static const per_choice_t QOSClass_choice[] = {
  {   0, &hf_h245_class0         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_class1         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_class2         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_class3         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_class4         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_class5         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_QOSClass(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_QOSClass, QOSClass_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t QOSDescriptor_sequence[] = {
  { &hf_h245_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { &hf_h245_qosType        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_QOSType },
  { &hf_h245_qosClass       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_QOSClass },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_QOSDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_QOSDescriptor, QOSDescriptor_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_0_63(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 63U, NULL, FALSE);

  return offset;
}


static const per_sequence_t QOSCapability_sequence[] = {
  { &hf_h245_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { &hf_h245_rsvpParameters , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_RSVPParameters },
  { &hf_h245_atmParameters  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_ATMParameters },
  { &hf_h245_localQoS       , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_BOOLEAN },
  { &hf_h245_genericTransportParameters, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_GenericTransportParameters },
  { &hf_h245_servicePriority, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_ServicePriority },
  { &hf_h245_authorizationParameter, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_AuthorizationParameters },
  { &hf_h245_qosDescriptor  , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_QOSDescriptor },
  { &hf_h245_dscpValue      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_0_63 },
  { NULL, 0, 0, NULL }
};

int
dissect_h245_QOSCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_QOSCapability, QOSCapability_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_SIZE_1_256_OF_QOSCapability_sequence_of[1] = {
  { &hf_h245_qOSCapabilities_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_QOSCapability },
};
/* 19 this function dissects a sequence of */
static guint32
dissect_per_sequence_of_helper(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, per_type_fn func, int hf_index, guint32 length)
{
	guint32 i;

//DEBUG_ENTRY("dissect_per_sequence_of_helper");
	for(i=0;i<length;i++){
		guint32 lold_offset=offset;
		proto_item *litem;
		//proto_tree *ltree;

		//litem=proto_tree_add_text(tree, tvb, offset>>3, 0,
		printf("Item %d\n", i);
		//ltree=proto_item_add_subtree(litem, ett_per_sequence_of_item);

		offset=(*func)(tvb, offset, actx, hf_index);
		//proto_item_set_len(litem, (offset>>3)!=(lold_offset>>3)?(offset>>3)-(lold_offset>>3):1);
	}

	return offset;
}

/* this function dissects a constrained sequence of */
guint32
dissect_per_constrained_sequence_of(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, gint ett_index, const per_sequence_t *seq, int min_len, int max_len, gboolean has_extension )
{
	proto_item *item;
	//proto_tree *tree;
	guint32 old_offset=offset;
	guint32 length;
	header_field_info *hfi;

//DEBUG_ENTRY("dissect_per_constrained_sequence_of");

	/* 19.4	If there is a PER-visible constraint and an extension marker is present in it,
	 * a single bit shall be added to the field-list in a bit-field of length one
	 */
	if(has_extension){
		gboolean extension_present;
		offset=dissect_per_boolean(tvb, offset, actx, hf_per_extension_present_bit, &extension_present);
		//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
		if(extension_present){
			/* 10.9 shall be invoked to add the length determinant as a semi-constrained whole number to the field-list,
			 * followed by the component values
			 * TODO: Handle extension
			 */
			//proto_tree_add_text(parent_tree, tvb, (offset>>3), 1, "dissect_per_constrained_sequence_of with extension is not handled");
		}
	}

	/* 19.5 if min==max and min,max<64k ==> no length determinant */
	if((min_len==max_len) && (min_len<65536)){
		length=min_len;
		goto call_sohelper;
	}

	/* 19.6 ub>=64k or unset */
	if ((max_len >= 65536) || (max_len == NO_BOUND)) {
		/* no constraint, see 10.9.4.2 */
		offset=dissect_per_length_determinant(tvb, offset, actx, hf_per_sequence_of_length, &length);
		goto call_sohelper;
	}

	/* constrained whole number for number of elements */
	offset=dissect_per_constrained_integer(tvb, offset, actx,
		 hf_per_sequence_of_length, min_len, max_len,
		&length, FALSE);
	//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);

call_sohelper:
	printf("%d item\n",h_245_message_value.true_false);
	//hfi = proto_registrar_get_nth(hf_index);
	/*if (IS_FT_UINT(hfi->type)) {
		item = proto_tree_add_uint(parent_tree, hf_index, tvb, offset>>3, 0, length);
		proto_item_append_text(item,
		(length==1)?" item":" items");
	} else {
		item=proto_tree_add_item(parent_tree, hf_index, tvb, offset>>3, 0, ENC_BIG_ENDIAN);
	}
	tree=proto_item_add_subtree(item, ett_index);
	per_check_items(length, min_len, max_len, actx, item);
*/
	old_offset = offset;
	offset=dissect_per_sequence_of_helper(tvb, offset, actx, seq->func, *seq->p_id, length);

	if (offset == old_offset)
		length = 0;
	else if (offset >> 3 == old_offset >> 3)
			length = 1;
		else
			length = (offset >> 3) - (old_offset >> 3);
	//printf("%d items \n");
	//proto_item_set_len(item, length);
	return offset;
}


static int
dissect_h245_SEQUENCE_SIZE_1_256_OF_QOSCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_SEQUENCE_SIZE_1_256_OF_QOSCapability, SEQUENCE_SIZE_1_256_OF_QOSCapability_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t T_atm_AAL5_compressed_sequence[] = {
  { &hf_h245_variable_delta , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_atm_AAL5_compressed(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_atm_AAL5_compressed, T_atm_AAL5_compressed_sequence);

  return offset;
}


static const value_string h245_MediaTransportType_vals[] = {
  {   0, "ip-UDP" },
  {   1, "ip-TCP" },
  {   2, "atm-AAL5-UNIDIR" },
  {   3, "atm-AAL5-BIDIR" },
  {   4, "atm-AAL5-compressed" },
  { 0, NULL }
};

static const per_choice_t MediaTransportType_choice[] = {
  {   0, &hf_h245_ip_UDP         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_ip_TCP         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_atm_AAL5_UNIDIR, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_atm_AAL5_BIDIR , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_atm_AAL5_compressed, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_atm_AAL5_compressed },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MediaTransportType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MediaTransportType, MediaTransportType_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MediaChannelCapability_sequence[] = {
  { &hf_h245_mediaTransport , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_MediaTransportType },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MediaChannelCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MediaChannelCapability, MediaChannelCapability_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_SIZE_1_256_OF_MediaChannelCapability_sequence_of[1] = {
  { &hf_h245_mediaChannelCapabilities_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MediaChannelCapability },
};

static int
dissect_h245_SEQUENCE_SIZE_1_256_OF_MediaChannelCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_SEQUENCE_SIZE_1_256_OF_MediaChannelCapability, SEQUENCE_SIZE_1_256_OF_MediaChannelCapability_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t TransportCapability_sequence[] = {
  { &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { &hf_h245_qOSCapabilities, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_SIZE_1_256_OF_QOSCapability },
  { &hf_h245_mediaChannelCapabilities, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_SIZE_1_256_OF_MediaChannelCapability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_TransportCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_TransportCapability, TransportCapability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1_16(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 16U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_0_15(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 15U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_frameSequence_sequence_of[1] = {
  { &hf_h245_frameSequence_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
};

static int
dissect_h245_T_frameSequence(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_T_frameSequence, T_frameSequence_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t RTPH263VideoRedundancyFrameMapping_sequence[] = {
  { &hf_h245_threadNumber   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_15 },
  { &hf_h245_frameSequence  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_frameSequence },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RTPH263VideoRedundancyFrameMapping(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RTPH263VideoRedundancyFrameMapping, RTPH263VideoRedundancyFrameMapping_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_SIZE_1_256_OF_RTPH263VideoRedundancyFrameMapping_sequence_of[1] = {
  { &hf_h245_custom_item    , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_RTPH263VideoRedundancyFrameMapping },
};

static int
dissect_h245_SEQUENCE_SIZE_1_256_OF_RTPH263VideoRedundancyFrameMapping(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_SEQUENCE_SIZE_1_256_OF_RTPH263VideoRedundancyFrameMapping, SEQUENCE_SIZE_1_256_OF_RTPH263VideoRedundancyFrameMapping_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const value_string h245_T_frameToThreadMapping_vals[] = {
  {   0, "roundrobin" },
  {   1, "custom" },
  { 0, NULL }
};

static const per_choice_t T_frameToThreadMapping_choice[] = {
  {   0, &hf_h245_roundrobin     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_custom         , ASN1_EXTENSION_ROOT    , dissect_h245_SEQUENCE_SIZE_1_256_OF_RTPH263VideoRedundancyFrameMapping },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_frameToThreadMapping(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_frameToThreadMapping, T_frameToThreadMapping_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_containedThreads_sequence_of[1] = {
  { &hf_h245_containedThreads_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_15 },
};

static int
dissect_h245_T_containedThreads(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_T_containedThreads, T_containedThreads_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t RTPH263VideoRedundancyEncoding_sequence[] = {
  { &hf_h245_numberOfThreads, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_16 },
  { &hf_h245_framesBetweenSyncPoints, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_256 },
  { &hf_h245_frameToThreadMapping, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_frameToThreadMapping },
  { &hf_h245_containedThreads, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_containedThreads },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RTPH263VideoRedundancyEncoding(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RTPH263VideoRedundancyEncoding, RTPH263VideoRedundancyEncoding_sequence);

  return offset;
}


static const value_string h245_RedundancyEncodingMethod_vals[] = {
  {   0, "nonStandard" },
  {   1, "rtpAudioRedundancyEncoding" },
  {   2, "rtpH263VideoRedundancyEncoding" },
  { 0, NULL }
};

static const per_choice_t RedundancyEncodingMethod_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_rtpAudioRedundancyEncoding, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_rtpH263VideoRedundancyEncoding, ASN1_NOT_EXTENSION_ROOT, dissect_h245_RTPH263VideoRedundancyEncoding },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_RedundancyEncodingMethod(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_RedundancyEncodingMethod, RedundancyEncodingMethod_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_CapabilityTableEntryNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("CapabilityTableEntryNumber:");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 65535U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}
static int
dissect_h245_CapabilityTableEntryNumber_(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("AlternativeCapability:");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 65535U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}

static const per_sequence_t SEQUENCE_SIZE_1_256_OF_CapabilityTableEntryNumber_sequence_of[1] = {
  { &hf_h245_secondaryEncodingCapability_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityTableEntryNumber },
};

static int
dissect_h245_SEQUENCE_SIZE_1_256_OF_CapabilityTableEntryNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_SEQUENCE_SIZE_1_256_OF_CapabilityTableEntryNumber, SEQUENCE_SIZE_1_256_OF_CapabilityTableEntryNumber_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t RedundancyEncodingCapability_sequence[] = {
  { &hf_h245_redundancyEncodingMethod, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_RedundancyEncodingMethod },
  { &hf_h245_primaryEncoding, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityTableEntryNumber },
  { &hf_h245_secondaryEncodingCapability, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_SIZE_1_256_OF_CapabilityTableEntryNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RedundancyEncodingCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RedundancyEncodingCapability, RedundancyEncodingCapability_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_SIZE_1_256_OF_RedundancyEncodingCapability_sequence_of[1] = {
  { &hf_h245_redundancyEncodingCapability_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_RedundancyEncodingCapability },
};

static int
dissect_h245_SEQUENCE_SIZE_1_256_OF_RedundancyEncodingCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_SEQUENCE_SIZE_1_256_OF_RedundancyEncodingCapability, SEQUENCE_SIZE_1_256_OF_RedundancyEncodingCapability_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t H2250Capability_sequence[] = {
  { &hf_h245_maximumAudioDelayJitter, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_1023 },
  { &hf_h245_receiveMultipointCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MultipointCapability },
  { &hf_h245_transmitMultipointCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MultipointCapability_transmitMultipointCapability },
  { &hf_h245_receiveAndTransmitMultipointCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MultipointCapability_receiveAndTransmitMultipointCapability },
  { &hf_h245_mcCapability   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_mcCapability },
  { &hf_h245_rtcpVideoControlCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_rtcpVideoControlCapability },
  { &hf_h245_mediaPacketizationCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MediaPacketizationCapability },
  { &hf_h245_transportCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_TransportCapability },
  { &hf_h245_redundancyEncodingCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_SIZE_1_256_OF_RedundancyEncodingCapability },
  { &hf_h245_logicalChannelSwitchingCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_logicalChannelSwitchingCapability },
  { &hf_h245_t120DynamicPortCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_t120DynamicPortCapability },
  { NULL, 0, 0, NULL }
};
static const value_string h245_MultiplexCapability_vals[] = {
  {   0, "nonStandard" },
  {   1, "h222Capability" },
  {   2, "h223Capability" },
  {   3, "v76Capability" },
  {   4, "h2250Capability" },
  {   5, "genericMultiplexCapability" },
  { 0, NULL }
};
static int
dissect_h245_H2250Capability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_MultiplexCapability_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_MultiplexCapability_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H2250Capability, H2250Capability_sequence);

  return offset;
}




static const per_choice_t MultiplexCapability_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_h222Capability , ASN1_EXTENSION_ROOT    , dissect_h245_H222Capability },
  {   2, &hf_h245_h223Capability , ASN1_EXTENSION_ROOT    , dissect_h245_H223Capability },
  {   3, &hf_h245_v76Capability  , ASN1_EXTENSION_ROOT    , dissect_h245_V76Capability },
  {   4, &hf_h245_h2250Capability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_H2250Capability },
  {   5, &hf_h245_genericMultiplexCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericCapability },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MultiplexCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("multiplexcapablity:");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MultiplexCapability, MultiplexCapability_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_INTEGER_1_4(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 4U, NULL, FALSE);

  return offset;
}


static const per_sequence_t H261VideoCapability_sequence[] = {
  { &hf_h245_qcifMPI_1_4    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4 },
  { &hf_h245_cifMPI_1_4     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4 },
  { &hf_h245_temporalSpatialTradeOffCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_maxBitRate_1_19200, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_19200 },
  { &hf_h245_stillImageTransmission, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoBadMBsCap , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H261VideoCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H261VideoCapability, H261VideoCapability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_0_1073741823(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 1073741823U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_0_262143(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 262143U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_0_16383(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 16383U, NULL, FALSE);

  return offset;
}


static const per_sequence_t H262VideoCapability_sequence[] = {
  { &hf_h245_profileAndLevel_SPatML, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_MPatLL, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_MPatML, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_MPatH_14, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_MPatHL, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_SNRatLL, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_SNRatML, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_SpatialatH_14, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_HPatML, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_HPatH_14, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_profileAndLevel_HPatHL, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoBitRate   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_1073741823 },
  { &hf_h245_vbvBufferSize  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_262143 },
  { &hf_h245_samplesPerLine , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_16383 },
  { &hf_h245_linesPerFrame  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_16383 },
  { &hf_h245_framesPerSecond, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_15 },
  { &hf_h245_luminanceSampleRate, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_4294967295 },
  { &hf_h245_videoBadMBsCap , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H262VideoCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H262VideoCapability, H262VideoCapability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1_32(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 32U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_192400(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 192400U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_0_524287(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 524287U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_3600(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 3600U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_M262144_262143(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            -262144, 262143U, NULL, FALSE);

  return offset;
}


static const per_sequence_t TransparencyParameters_sequence[] = {
  { &hf_h245_presentationOrder, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_256 },
  { &hf_h245_offset_x       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_M262144_262143 },
  { &hf_h245_offset_y       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_M262144_262143 },
  { &hf_h245_scale_x        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { &hf_h245_scale_y        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_TransparencyParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_TransparencyParameters, TransparencyParameters_sequence);

  return offset;
}


static const per_sequence_t T_additionalPictureMemory_sequence[] = {
  { &hf_h245_sqcifAdditionalPictureMemory, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_256 },
  { &hf_h245_qcifAdditionalPictureMemory, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_256 },
  { &hf_h245_cifAdditionalPictureMemory, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_256 },
  { &hf_h245_cif4AdditionalPictureMemory, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_256 },
  { &hf_h245_cif16AdditionalPictureMemory, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_256 },
  { &hf_h245_bigCpfAdditionalPictureMemory, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_256 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_additionalPictureMemory(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_additionalPictureMemory, T_additionalPictureMemory_sequence);

  return offset;
}


static const value_string h245_T_videoBackChannelSend_vals[] = {
  {   0, "none" },
  {   1, "ackMessageOnly" },
  {   2, "nackMessageOnly" },
  {   3, "ackOrNackMessageOnly" },
  {   4, "ackAndNackMessage" },
  { 0, NULL }
};

static const per_choice_t T_videoBackChannelSend_choice[] = {
  {   0, &hf_h245_none           , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_ackMessageOnly , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_nackMessageOnly, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_ackOrNackMessageOnly, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_ackAndNackMessage, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_videoBackChannelSend(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_videoBackChannelSend, T_videoBackChannelSend_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_INTEGER_1_128(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 128U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_72(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 72U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_subPictureRemovalParameters_sequence[] = {
  { &hf_h245_mpuHorizMBs    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_128 },
  { &hf_h245_mpuVertMBs     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_72 },
  { &hf_h245_mpuTotalNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65536 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_subPictureRemovalParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_subPictureRemovalParameters, T_subPictureRemovalParameters_sequence);

  return offset;
}


static const per_sequence_t T_enhancedReferencePicSelect_sequence[] = {
  { &hf_h245_subPictureRemovalParameters, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_subPictureRemovalParameters },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_enhancedReferencePicSelect(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_enhancedReferencePicSelect, T_enhancedReferencePicSelect_sequence);

  return offset;
}


static const per_sequence_t RefPictureSelection_sequence[] = {
  { &hf_h245_additionalPictureMemory, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_additionalPictureMemory },
  { &hf_h245_videoMux       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoBackChannelSend, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_videoBackChannelSend },
  { &hf_h245_enhancedReferencePicSelect, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_T_enhancedReferencePicSelect },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RefPictureSelection(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RefPictureSelection, RefPictureSelection_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1000_1001(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1000U, 1001U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_2048(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 2048U, NULL, FALSE);

  return offset;
}


static const per_sequence_t CustomPictureClockFrequency_sequence[] = {
  { &hf_h245_clockConversionCode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1000_1001 },
  { &hf_h245_clockDivisor   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_127 },
  { &hf_h245_sqcifMPI       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_2048 },
  { &hf_h245_qcifMPI_1_2048 , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_2048 },
  { &hf_h245_cifMPI2_1_2048 , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_2048 },
  { &hf_h245_cif4MPI        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_2048 },
  { &hf_h245_cif16MPI       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_2048 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CustomPictureClockFrequency(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CustomPictureClockFrequency, CustomPictureClockFrequency_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_16_OF_CustomPictureClockFrequency_set_of[1] = {
  { &hf_h245_customPictureClockFrequency_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CustomPictureClockFrequency },
};

static int
dissect_h245_SET_SIZE_1_16_OF_CustomPictureClockFrequency(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_16_OF_CustomPictureClockFrequency, SET_SIZE_1_16_OF_CustomPictureClockFrequency_set_of,
                                             1, 16, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_31(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 31U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_customPCF_item_sequence[] = {
  { &hf_h245_clockConversionCode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1000_1001 },
  { &hf_h245_clockDivisor   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_127 },
  { &hf_h245_customMPI      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_2048 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_customPCF_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_customPCF_item, T_customPCF_item_sequence);

  return offset;
}


static const per_sequence_t T_customPCF_set_of[1] = {
  { &hf_h245_customPCF_item , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_customPCF_item },
};

static int
dissect_h245_T_customPCF(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_T_customPCF, T_customPCF_set_of,
                                             1, 16, FALSE);

  return offset;
}


static const per_sequence_t T_mPI_sequence[] = {
  { &hf_h245_standardMPI    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_31 },
  { &hf_h245_customPCF      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_customPCF },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_mPI(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_mPI, T_mPI_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1_14(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 14U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_pixelAspectCode_set_of[1] = {
  { &hf_h245_pixelAspectCode_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_14 },
};

static int
dissect_h245_T_pixelAspectCode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_T_pixelAspectCode, T_pixelAspectCode_set_of,
                                             1, 14, FALSE);

  return offset;
}


static const per_sequence_t T_extendedPAR_item_sequence[] = {
  { &hf_h245_width          , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { &hf_h245_height         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_extendedPAR_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_extendedPAR_item, T_extendedPAR_item_sequence);

  return offset;
}


static const per_sequence_t T_extendedPAR_set_of[1] = {
  { &hf_h245_extendedPAR_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_extendedPAR_item },
};

static int
dissect_h245_T_extendedPAR(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_T_extendedPAR, T_extendedPAR_set_of,
                                             1, 256, FALSE);

  return offset;
}


static const value_string h245_T_pixelAspectInformation_vals[] = {
  {   0, "anyPixelAspectRatio" },
  {   1, "pixelAspectCode" },
  {   2, "extendedPAR" },
  { 0, NULL }
};

static const per_choice_t T_pixelAspectInformation_choice[] = {
  {   0, &hf_h245_anyPixelAspectRatio, ASN1_EXTENSION_ROOT    , dissect_h245_BOOLEAN },
  {   1, &hf_h245_pixelAspectCode, ASN1_EXTENSION_ROOT    , dissect_h245_T_pixelAspectCode },
  {   2, &hf_h245_extendedPAR    , ASN1_EXTENSION_ROOT    , dissect_h245_T_extendedPAR },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_pixelAspectInformation(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_pixelAspectInformation, T_pixelAspectInformation_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t CustomPictureFormat_sequence[] = {
  { &hf_h245_maxCustomPictureWidth, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_2048 },
  { &hf_h245_maxCustomPictureHeight, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_2048 },
  { &hf_h245_minCustomPictureWidth, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_2048 },
  { &hf_h245_minCustomPictureHeight, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_2048 },
  { &hf_h245_mPI            , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_mPI },
  { &hf_h245_pixelAspectInformation, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_pixelAspectInformation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CustomPictureFormat(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CustomPictureFormat, CustomPictureFormat_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_16_OF_CustomPictureFormat_set_of[1] = {
  { &hf_h245_customPictureFormat_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CustomPictureFormat },
};

static int
dissect_h245_SET_SIZE_1_16_OF_CustomPictureFormat(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_16_OF_CustomPictureFormat, SET_SIZE_1_16_OF_CustomPictureFormat_set_of,
                                             1, 16, FALSE);

  return offset;
}


static const per_sequence_t H263Version3Options_sequence[] = {
  { &hf_h245_dataPartitionedSlices, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_fixedPointIDCT0, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_interlacedFields, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_currentPictureHeaderRepetition, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_previousPictureHeaderRepetition, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_nextPictureHeaderRepetition, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_pictureNumberBoolean, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_spareReferencePictures, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H263Version3Options(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H263Version3Options, H263Version3Options_sequence);

  return offset;
}


static const per_sequence_t H263ModeComboFlags_sequence[] = {
  { &hf_h245_unrestrictedVector, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_arithmeticCoding, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_advancedPrediction, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_pbFrames       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_advancedIntraCodingMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_deblockingFilterMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_unlimitedMotionVectors, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_slicesInOrder_NonRect, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_slicesInOrder_Rect, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_slicesNoOrder_NonRect, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_slicesNoOrder_Rect, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_improvedPBFramesMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_referencePicSelect, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dynamicPictureResizingByFour, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dynamicPictureResizingSixteenthPel, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dynamicWarpingHalfPel, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dynamicWarpingSixteenthPel, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_reducedResolutionUpdate, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_independentSegmentDecoding, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_alternateInterVLCMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_modifiedQuantizationMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_enhancedReferencePicSelectBool, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_h263Version3Options, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_H263Version3Options },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H263ModeComboFlags(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H263ModeComboFlags, H263ModeComboFlags_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_16_OF_H263ModeComboFlags_set_of[1] = {
  { &hf_h245_h263VideoCoupledModes_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_H263ModeComboFlags },
};

static int
dissect_h245_SET_SIZE_1_16_OF_H263ModeComboFlags(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_16_OF_H263ModeComboFlags, SET_SIZE_1_16_OF_H263ModeComboFlags_set_of,
                                             1, 16, FALSE);

  return offset;
}


static const per_sequence_t H263VideoModeCombos_sequence[] = {
  { &hf_h245_h263VideoUncoupledModes, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_H263ModeComboFlags },
  { &hf_h245_h263VideoCoupledModes, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_16_OF_H263ModeComboFlags },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H263VideoModeCombos(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H263VideoModeCombos, H263VideoModeCombos_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_16_OF_H263VideoModeCombos_set_of[1] = {
  { &hf_h245_modeCombos_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_H263VideoModeCombos },
};

static int
dissect_h245_SET_SIZE_1_16_OF_H263VideoModeCombos(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_16_OF_H263VideoModeCombos, SET_SIZE_1_16_OF_H263VideoModeCombos_set_of,
                                             1, 16, FALSE);

  return offset;
}


static const per_sequence_t H263Options_sequence[] = {
  { &hf_h245_advancedIntraCodingMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_deblockingFilterMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_improvedPBFramesMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_unlimitedMotionVectors, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_fullPictureFreeze, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_partialPictureFreezeAndRelease, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_resizingPartPicFreezeAndRelease, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_fullPictureSnapshot, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_partialPictureSnapshot, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoSegmentTagging, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_progressiveRefinement, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dynamicPictureResizingByFour, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dynamicPictureResizingSixteenthPel, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dynamicWarpingHalfPel, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_dynamicWarpingSixteenthPel, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_independentSegmentDecoding, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_slicesInOrder_NonRect, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_slicesInOrder_Rect, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_slicesNoOrder_NonRect, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_slicesNoOrder_Rect, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_alternateInterVLCMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_modifiedQuantizationMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_reducedResolutionUpdate, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_transparencyParameters, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_TransparencyParameters },
  { &hf_h245_separateVideoBackChannel, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_refPictureSelection, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_RefPictureSelection },
  { &hf_h245_customPictureClockFrequency, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_16_OF_CustomPictureClockFrequency },
  { &hf_h245_customPictureFormat, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_16_OF_CustomPictureFormat },
  { &hf_h245_modeCombos     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_16_OF_H263VideoModeCombos },
  { &hf_h245_videoBadMBsCap , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_h263Version3Options, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_H263Version3Options },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H263Options(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H263Options, H263Options_sequence);

  return offset;
}


static const per_sequence_t EnhancementOptions_sequence[] = {
  { &hf_h245_sqcifMPI_1_32  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_qcifMPI        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_cifMPI         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_cif4MPI_1_32   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_cif16MPI_1_32  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_maxBitRate     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_192400 },
  { &hf_h245_unrestrictedVector, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_arithmeticCoding, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_temporalSpatialTradeOffCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_slowSqcifMPI   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_slowQcifMPI    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_slowCifMPI     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_slowCif4MPI    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_slowCif16MPI   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_errorCompensation, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_h263Options    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_H263Options },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_EnhancementOptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_EnhancementOptions, EnhancementOptions_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_14_OF_EnhancementOptions_set_of[1] = {
  { &hf_h245_snrEnhancement_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_EnhancementOptions },
};

static int
dissect_h245_SET_SIZE_1_14_OF_EnhancementOptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_14_OF_EnhancementOptions, SET_SIZE_1_14_OF_EnhancementOptions_set_of,
                                             1, 14, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_64(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 64U, NULL, FALSE);

  return offset;
}


static const per_sequence_t BEnhancementParameters_sequence[] = {
  { &hf_h245_enhancementOptions, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_EnhancementOptions },
  { &hf_h245_numberOfBPictures, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_64 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_BEnhancementParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_BEnhancementParameters, BEnhancementParameters_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_14_OF_BEnhancementParameters_set_of[1] = {
  { &hf_h245_bPictureEnhancement_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_BEnhancementParameters },
};

static int
dissect_h245_SET_SIZE_1_14_OF_BEnhancementParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_14_OF_BEnhancementParameters, SET_SIZE_1_14_OF_BEnhancementParameters_set_of,
                                             1, 14, FALSE);

  return offset;
}


static const per_sequence_t EnhancementLayerInfo_sequence[] = {
  { &hf_h245_baseBitRateConstrained, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_snrEnhancement , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_14_OF_EnhancementOptions },
  { &hf_h245_spatialEnhancement, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_14_OF_EnhancementOptions },
  { &hf_h245_bPictureEnhancement, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_14_OF_BEnhancementParameters },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_EnhancementLayerInfo(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_EnhancementLayerInfo, EnhancementLayerInfo_sequence);

  return offset;
}


static const per_sequence_t H263VideoCapability_sequence[] = {
  { &hf_h245_sqcifMPI_1_32  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_qcifMPI        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_cifMPI         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_cif4MPI_1_32   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_cif16MPI_1_32  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_32 },
  { &hf_h245_maxBitRate     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_192400 },
  { &hf_h245_unrestrictedVector, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_arithmeticCoding, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_advancedPrediction, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_pbFrames       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_temporalSpatialTradeOffCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_hrd_B          , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_524287 },
  { &hf_h245_bppMaxKb       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_65535 },
  { &hf_h245_slowSqcifMPI   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_slowQcifMPI    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_slowCifMPI     , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_slowCif4MPI    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_slowCif16MPI   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_1_3600 },
  { &hf_h245_errorCompensation, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_enhancementLayerInfo, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_EnhancementLayerInfo },
  { &hf_h245_h263Options    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_H263Options },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H263VideoCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H263VideoCapability, H263VideoCapability_sequence);

//#line 364 "../../asn1/h245/h245.cnf"
  h245_lc_dissector = h263_handle;

  return offset;
}


static const per_sequence_t IS11172VideoCapability_sequence[] = {
  { &hf_h245_constrainedBitstream, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoBitRate   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_1073741823 },
  { &hf_h245_vbvBufferSize  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_262143 },
  { &hf_h245_samplesPerLine , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_16383 },
  { &hf_h245_linesPerFrame  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_16383 },
  { &hf_h245_pictureRate    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_15 },
  { &hf_h245_luminanceSampleRate, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_4294967295 },
  { &hf_h245_videoBadMBsCap , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_IS11172VideoCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_IS11172VideoCapability, IS11172VideoCapability_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_VideoCapability_sequence_of[1] = {
  { &hf_h245_videoCapability_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_VideoCapability },
};

static int
dissect_h245_SEQUENCE_OF_VideoCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_VideoCapability, SEQUENCE_OF_VideoCapability_sequence_of);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_GenericCapability_sequence_of[1] = {
  { &hf_h245_videoCapabilityExtension_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_GenericCapability },
};

static int
dissect_h245_SEQUENCE_OF_GenericCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_GenericCapability, SEQUENCE_OF_GenericCapability_sequence_of);

  return offset;
}


static const per_sequence_t ExtendedVideoCapability_sequence[] = {
  { &hf_h245_videoCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SEQUENCE_OF_VideoCapability },
  { &hf_h245_videoCapabilityExtension, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_GenericCapability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_ExtendedVideoCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_ExtendedVideoCapability, ExtendedVideoCapability_sequence);

  return offset;
}


static const value_string h245_VideoCapability_vals[] = {
  {   0, "nonStandard" },
  {   1, "h261VideoCapability" },
  {   2, "h262VideoCapability" },
  {   3, "h263VideoCapability" },
  {   4, "is11172VideoCapability" },
  {   5, "genericVideoCapability" },
  {   6, "extendedVideoCapability" },
  { 0, NULL }
};

static const per_choice_t VideoCapability_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_h261VideoCapability, ASN1_EXTENSION_ROOT    , dissect_h245_H261VideoCapability },
  {   2, &hf_h245_h262VideoCapability, ASN1_EXTENSION_ROOT    , dissect_h245_H262VideoCapability },
  {   3, &hf_h245_h263VideoCapability, ASN1_EXTENSION_ROOT    , dissect_h245_H263VideoCapability },
  {   4, &hf_h245_is11172VideoCapability, ASN1_EXTENSION_ROOT    , dissect_h245_IS11172VideoCapability },
  {   5, &hf_h245_genericVideoCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericCapability },
  {   6, &hf_h245_extendedVideoCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_ExtendedVideoCapability },
  { 0, NULL, 0, NULL }
};
static const gchar*
match_strval_idx(const guint32 val, const value_string *vs, gint *idx) {
  gint i = 0;

  if(vs) {
    while (vs[i].strptr) {
      if (vs[i].value == val) {
        *idx = i;
        return(vs[i].strptr);
      }
      i++;
    }
  }

  *idx = -1;
  return NULL;
}
static const gchar*
match_strval(const guint32 val, const value_string *vs) {
    gint ignore_me;
    return match_strval_idx(val, vs, &ignore_me);
}
static gchar *
emem_strdup_vprintf(const gchar *fmt, va_list ap, void *allocator(size_t))
{
	va_list ap2;
	gsize len = 0;
	gchar* dst;

	//G_VA_COPY(ap2, ap);

			//len = g_printf_string_upper_bound(fmt, ap);

	dst = (gchar *)allocator(len+1);
	//g_vsnprintf (dst, (gulong) len, fmt, ap2);
	va_end(ap2);

	return dst;
}
static gchar *
ep_strdup_vprintf(const gchar *fmt, va_list ap)
{
	return emem_strdup_vprintf(fmt, ap,malloc);// ep_alloc);
}
static gchar *
ep_strdup_printf(const gchar *fmt, ...)
{
	va_list ap = 0;
	gchar *dst;

	va_start(ap, fmt);
	dst = ep_strdup_vprintf(fmt, ap);
	va_end(ap);
	return dst;
}
static const gchar*
val_to_str(const guint32 val, const value_string *vs, const char *fmt) {
  const gchar *ret;

  g_assert(fmt != NULL);

  ret = match_strval(val, vs);
  if (ret != NULL)
    return ret;

  return ep_strdup_printf(fmt, val);
}
static int
dissect_h245_VideoCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 495 "../../asn1/h245/h245.cnf"
  gint32 value;

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_VideoCapability, VideoCapability_choice,
                                 &value);

        codec_type = val_to_str(value, h245_VideoCapability_vals, "<unknown>");



  return offset;
}


static const per_sequence_t T_g7231_sequence[] = {
  { &hf_h245_maxAl_sduAudioFrames, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_256 },
  { &hf_h245_silenceSuppression, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_g7231(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_g7231, T_g7231_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1_448(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 448U, NULL, FALSE);

  return offset;
}


static const per_sequence_t IS11172AudioCapability_sequence[] = {
  { &hf_h245_audioLayer1    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioLayer2    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioLayer3    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioSampling32k, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioSampling44k1, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioSampling48k, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_singleChannel  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_twoChannels    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_bitRate_1_448  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_448 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_IS11172AudioCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_IS11172AudioCapability, IS11172AudioCapability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1_1130(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 1130U, NULL, FALSE);

  return offset;
}


static const per_sequence_t IS13818AudioCapability_sequence[] = {
  { &hf_h245_audioLayer1    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioLayer2    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioLayer3    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioSampling16k, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioSampling22k05, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioSampling24k, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioSampling32k, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioSampling44k1, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_audioSampling48k, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_singleChannel  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_twoChannels    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_threeChannels2_1, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_threeChannels3_0, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_fourChannels2_0_2_0, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_fourChannels2_2, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_fourChannels3_1, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_fiveChannels3_0_2_0, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_fiveChannels3_2, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_lowFrequencyEnhancement, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_multilingual   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_bitRate2_1_1130, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_1130 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_IS13818AudioCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_IS13818AudioCapability, IS13818AudioCapability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_27_78(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            27U, 78U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_23_66(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            23U, 66U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_6_17(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            6U, 17U, NULL, FALSE);

  return offset;
}


static const per_sequence_t G723AnnexCAudioMode_sequence[] = {
  { &hf_h245_highRateMode0  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_27_78 },
  { &hf_h245_highRateMode1  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_27_78 },
  { &hf_h245_lowRateMode0   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_23_66 },
  { &hf_h245_lowRateMode1   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_23_66 },
  { &hf_h245_sidMode0       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_6_17 },
  { &hf_h245_sidMode1       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_6_17 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_G723AnnexCAudioMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_G723AnnexCAudioMode, G723AnnexCAudioMode_sequence);

  return offset;
}


static const per_sequence_t G7231AnnexCCapability_sequence[] = {
  { &hf_h245_maxAl_sduAudioFrames, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_256 },
  { &hf_h245_silenceSuppression, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_g723AnnexCAudioMode, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_G723AnnexCAudioMode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_G7231AnnexCCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_G7231AnnexCCapability, G7231AnnexCCapability_sequence);

  return offset;
}


static const per_sequence_t GSMAudioCapability_sequence[] = {
  { &hf_h245_audioUnitSize  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_256 },
  { &hf_h245_comfortNoise   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_scrambled      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_GSMAudioCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_GSMAudioCapability, GSMAudioCapability_sequence);

  return offset;
}


static const per_sequence_t G729Extensions_sequence[] = {
  { &hf_h245_audioUnit      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_256 },
  { &hf_h245_annexA         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_annexB         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_annexD         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_annexE         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_annexF         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_annexG         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_annexH         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_G729Extensions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_G729Extensions, G729Extensions_sequence);

  return offset;
}


static const per_sequence_t VBDCapability_sequence[] = {
  { &hf_h245_vbd_cap_type   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_AudioCapability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_VBDCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_VBDCapability, VBDCapability_sequence);

  return offset;
}

guint32
dissect_per_GeneralString(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index)
{
	guint32 length;

	offset=dissect_per_length_determinant(tvb, offset, actx, hf_per_GeneralString_length, &length);

	//proto_tree_add_item( hf_index, tvb, offset>>3, length, ENC_BIG_ENDIAN);

	offset+=length*8;

	return offset;
}


static int
dissect_h245_GeneralString(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_GeneralString(tvb, offset, actx, hf_index);

  return offset;
}


static const per_sequence_t NoPTAudioTelephonyEventCapability_sequence[] = {
  { &hf_h245_audioTelephoneEvent, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_GeneralString },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_NoPTAudioTelephonyEventCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_NoPTAudioTelephonyEventCapability, NoPTAudioTelephonyEventCapability_sequence);

  return offset;
}


static const per_sequence_t NoPTAudioToneCapability_sequence[] = {
  { NULL, ASN1_EXTENSION_ROOT, 0, NULL }
};

static int
dissect_h245_NoPTAudioToneCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_NoPTAudioToneCapability, NoPTAudioToneCapability_sequence);

  return offset;
}


static const per_choice_t AudioCapability_choice[] = {
  { AudioCapability_nonStandard, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  { AudioCapability_g711Alaw64k, &hf_h245_g711Alaw64k    , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_g711Alaw56k, &hf_h245_g711Alaw56k    , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_g711Ulaw64k, &hf_h245_g711Ulaw64k    , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_g711Ulaw56k, &hf_h245_g711Ulaw56k    , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_g722_64k, &hf_h245_g722_64k       , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_g722_56k, &hf_h245_g722_56k       , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_g722_48k, &hf_h245_g722_48k       , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_g7231, &hf_h245_g7231          , ASN1_EXTENSION_ROOT    , dissect_h245_T_g7231 },
  { AudioCapability_g728, &hf_h245_g728           , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_g729, &hf_h245_g729           , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_g729AnnexA, &hf_h245_g729AnnexA     , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_256 },
  { AudioCapability_is11172AudioCapability, &hf_h245_is11172AudioCapability, ASN1_EXTENSION_ROOT    , dissect_h245_IS11172AudioCapability },
  { AudioCapability_is13818AudioCapability, &hf_h245_is13818AudioCapability, ASN1_EXTENSION_ROOT    , dissect_h245_IS13818AudioCapability },
  { AudioCapability_g729wAnnexB, &hf_h245_g729wAnnexB    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_INTEGER_1_256 },
  { AudioCapability_g729AnnexAwAnnexB, &hf_h245_g729AnnexAwAnnexB, ASN1_NOT_EXTENSION_ROOT, dissect_h245_INTEGER_1_256 },
  { AudioCapability_g7231AnnexCCapability, &hf_h245_g7231AnnexCCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_G7231AnnexCCapability },
  { AudioCapability_gsmFullRate, &hf_h245_gsmFullRate    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_GSMAudioCapability },
  { AudioCapability_gsmHalfRate, &hf_h245_gsmHalfRate    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_GSMAudioCapability },
  { AudioCapability_gsmEnhancedFullRate, &hf_h245_gsmEnhancedFullRate, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GSMAudioCapability },
  { AudioCapability_genericAudioCapability, &hf_h245_genericAudioCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericCapability },
  { AudioCapability_g729Extensions, &hf_h245_g729Extensions , ASN1_NOT_EXTENSION_ROOT, dissect_h245_G729Extensions },
  { AudioCapability_vbd, &hf_h245_vbd            , ASN1_NOT_EXTENSION_ROOT, dissect_h245_VBDCapability },
  { AudioCapability_audioTelephonyEvent, &hf_h245_audioTelephonyEvent, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NoPTAudioTelephonyEventCapability },
  { AudioCapability_audioTone, &hf_h245_audioTone      , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NoPTAudioToneCapability },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_AudioCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 488 "../../asn1/h245/h245.cnf"
  gint32 value;
  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_Capability_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s:", val_to_str(	h_245_message_value.msg_value, h245_Capability_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_AudioCapability, AudioCapability_choice,
                                 &value);

        //codec_type = val_to_str(value, h245_AudioCapability_short_vals, "<unknown>");


  return offset;
}


static const per_sequence_t T_h233EncryptionReceiveCapability_sequence[] = {
  { &hf_h245_h233IVResponseTime, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_h233EncryptionReceiveCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_h233EncryptionReceiveCapability, T_h233EncryptionReceiveCapability_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_NonStandardParameter_sequence_of[1] = {
  { &hf_h245_nonStandardParams_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_NonStandardParameter },
};

static int
dissect_h245_SEQUENCE_OF_NonStandardParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_NonStandardParameter, SEQUENCE_OF_NonStandardParameter_sequence_of);

  return offset;
}


static const per_sequence_t ConferenceCapability_sequence[] = {
  { &hf_h245_nonStandardParams, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_NonStandardParameter },
  { &hf_h245_chairControlCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoIndicateMixingCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_multipointVisualizationCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_ConferenceCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_ConferenceCapability, ConferenceCapability_sequence);

  return offset;
}


static const value_string h245_MediaEncryptionAlgorithm_vals[] = {
  {   0, "nonStandard" },
  {   1, "algorithm" },
  { 0, NULL }
};

static const per_choice_t MediaEncryptionAlgorithm_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_algorithm      , ASN1_EXTENSION_ROOT    , dissect_h245_OBJECT_IDENTIFIER },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MediaEncryptionAlgorithm(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MediaEncryptionAlgorithm, MediaEncryptionAlgorithm_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t EncryptionCapability_sequence_of[1] = {
  { &hf_h245_EncryptionCapability_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MediaEncryptionAlgorithm },
};

static int
dissect_h245_EncryptionCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_EncryptionCapability, EncryptionCapability_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t AuthenticationCapability_sequence[] = {
  { &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { &hf_h245_antiSpamAlgorithm, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_OBJECT_IDENTIFIER },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_AuthenticationCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_AuthenticationCapability, AuthenticationCapability_sequence);

  return offset;
}


static const per_sequence_t IntegrityCapability_sequence[] = {
  { &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_IntegrityCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_IntegrityCapability, IntegrityCapability_sequence);

  return offset;
}


static const per_sequence_t EncryptionAuthenticationAndIntegrity_sequence[] = {
  { &hf_h245_encryptionCapability, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_EncryptionCapability },
  { &hf_h245_authenticationCapability, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_AuthenticationCapability },
  { &hf_h245_integrityCapability, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_IntegrityCapability },
  { &hf_h245_genericH235SecurityCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_GenericCapability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_EncryptionAuthenticationAndIntegrity(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_EncryptionAuthenticationAndIntegrity, EncryptionAuthenticationAndIntegrity_sequence);

  return offset;
}


static const per_sequence_t H235SecurityCapability_sequence[] = {
  { &hf_h245_encryptionAuthenticationAndIntegrity, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_EncryptionAuthenticationAndIntegrity },
  { &hf_h245_mediaCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityTableEntryNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H235SecurityCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H235SecurityCapability, H235SecurityCapability_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_SIZE_1_16_OF_NonStandardParameter_sequence_of[1] = {
  { &hf_h245_ui_nonStandard_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_NonStandardParameter },
};

static int
dissect_h245_SEQUENCE_SIZE_1_16_OF_NonStandardParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_SEQUENCE_SIZE_1_16_OF_NonStandardParameter, SEQUENCE_SIZE_1_16_OF_NonStandardParameter_sequence_of,
                                                  1, 16, FALSE);

  return offset;
}


static const value_string h245_UserInputCapability_vals[] = {
  {   0, "nonStandard" },
  {   1, "basicString" },
  {   2, "iA5String" },
  {   3, "generalString" },
  {   4, "dtmf" },
  {   5, "hookflash" },
  {   6, "extendedAlphanumeric" },
  {   7, "encryptedBasicString" },
  {   8, "encryptedIA5String" },
  {   9, "encryptedGeneralString" },
  {  10, "secureDTMF" },
  {  11, "genericUserInputCapability" },
  { 0, NULL }
};

static const per_choice_t UserInputCapability_choice[] = {
  {   0, &hf_h245_ui_nonStandard , ASN1_EXTENSION_ROOT    , dissect_h245_SEQUENCE_SIZE_1_16_OF_NonStandardParameter },
  {   1, &hf_h245_basicString    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_iA5String      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_generalString  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_dtmf           , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_hookflash      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_extendedAlphanumericFlag, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   7, &hf_h245_encryptedBasicString, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   8, &hf_h245_encryptedIA5String, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   9, &hf_h245_encryptedGeneralString, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  10, &hf_h245_secureDTMF     , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  11, &hf_h245_genericUserInputCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericCapability },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_UserInputCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_UserInputCapability, UserInputCapability_choice,
                                 NULL);

  return offset;
}


static const value_string h245_MultiplexFormat_vals[] = {
  {   0, "nonStandard" },
  {   1, "h222Capability" },
  {   2, "h223Capability" },
  { 0, NULL }
};

static const per_choice_t MultiplexFormat_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_h222Capability , ASN1_EXTENSION_ROOT    , dissect_h245_H222Capability },
  {   2, &hf_h245_h223Capability , ASN1_EXTENSION_ROOT    , dissect_h245_H223Capability },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MultiplexFormat(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MultiplexFormat, MultiplexFormat_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t AlternativeCapabilitySet_sequence_of[1] = {
  { &hf_h245_AlternativeCapabilitySet_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityTableEntryNumber_ },
};

static int
dissect_h245_AlternativeCapabilitySet(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {

	printf("AlternativeCapability:");
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_AlternativeCapabilitySet, AlternativeCapabilitySet_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t SET_SIZE_1_256_OF_AlternativeCapabilitySet_set_of[1] = {
  { &hf_h245_simultaneousCapabilities_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_AlternativeCapabilitySet },
};

static int
dissect_h245_SET_SIZE_1_256_OF_AlternativeCapabilitySet(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("simultaneousCapabilities:");
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_256_OF_AlternativeCapabilitySet, SET_SIZE_1_256_OF_AlternativeCapabilitySet_set_of,
                                             1, 256, FALSE);

  return offset;
}


static const per_sequence_t MultiplexedStreamCapability_sequence[] = {
  { &hf_h245_multiplexFormat, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexFormat },
  { &hf_h245_controlOnMuxStream, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_capabilityOnMuxStream, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_256_OF_AlternativeCapabilitySet },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexedStreamCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexedStreamCapability, MultiplexedStreamCapability_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_96_127(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            96U, 127U, NULL, FALSE);

  return offset;
}


static const per_sequence_t AudioTelephonyEventCapability_sequence[] = {
  { &hf_h245_dynamicRTPPayloadType, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_96_127 },
  { &hf_h245_audioTelephoneEvent, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_GeneralString },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_AudioTelephonyEventCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_AudioTelephonyEventCapability, AudioTelephonyEventCapability_sequence);

  return offset;
}


static const per_sequence_t AudioToneCapability_sequence[] = {
  { &hf_h245_dynamicRTPPayloadType, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_96_127 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_AudioToneCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_AudioToneCapability, AudioToneCapability_sequence);

  return offset;
}


static const per_sequence_t T_separateStreamBool_sequence[] = {
  { &hf_h245_separatePort   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_samePortBool   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_separateStreamBool(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_separateStreamBool, T_separateStreamBool_sequence);

  return offset;
}


static const per_sequence_t FECC_rfc2733_sequence[] = {
  { &hf_h245_redundancyEncodingBool, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_separateStreamBool, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_separateStreamBool },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_FECC_rfc2733(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_FECC_rfc2733, FECC_rfc2733_sequence);

  return offset;
}


static const value_string h245_DepFECCapability_vals[] = {
  {   0, "rfc2733" },
  { 0, NULL }
};

static const per_choice_t DepFECCapability_choice[] = {
  {   0, &hf_h245_fecc_rfc2733   , ASN1_EXTENSION_ROOT    , dissect_h245_FECC_rfc2733 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_DepFECCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_DepFECCapability, DepFECCapability_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MultiplePayloadStreamCapability_sequence[] = {
  { &hf_h245_capabilities   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_256_OF_AlternativeCapabilitySet },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplePayloadStreamCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplePayloadStreamCapability, MultiplePayloadStreamCapability_sequence);

  return offset;
}



static int
dissect_h245_MaxRedundancy(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, NO_BOUND, NULL, FALSE);

  return offset;
}


static const value_string h245_Rfc2733Format_vals[] = {
  {   0, "rfc2733rfc2198" },
  {   1, "rfc2733sameport" },
  {   2, "rfc2733diffport" },
  { 0, NULL }
};

static const per_choice_t Rfc2733Format_choice[] = {
  {   0, &hf_h245_rfc2733rfc2198 , ASN1_NO_EXTENSIONS     , dissect_h245_MaxRedundancy },
  {   1, &hf_h245_rfc2733sameport, ASN1_NO_EXTENSIONS     , dissect_h245_MaxRedundancy },
  {   2, &hf_h245_rfc2733diffport, ASN1_NO_EXTENSIONS     , dissect_h245_MaxRedundancy },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Rfc2733Format(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Rfc2733Format, Rfc2733Format_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t FECCapability_sequence[] = {
  { &hf_h245_protectedCapability, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityTableEntryNumber },
  { &hf_h245_fecScheme      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OBJECT_IDENTIFIER },
  { &hf_h245_rfc2733Format  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_Rfc2733Format },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_FECCapability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_FECCapability, FECCapability_sequence);

  return offset;
}



static const per_choice_t Capability_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_receiveVideoCapability, ASN1_EXTENSION_ROOT    , dissect_h245_VideoCapability },
  {   2, &hf_h245_transmitVideoCapability, ASN1_EXTENSION_ROOT    , dissect_h245_VideoCapability },
  {   3, &hf_h245_receiveAndTransmitVideoCapability, ASN1_EXTENSION_ROOT    , dissect_h245_VideoCapability },
  {   4, &hf_h245_receiveAudioCapability, ASN1_EXTENSION_ROOT    , dissect_h245_AudioCapability },
  {   5, &hf_h245_transmitAudioCapability, ASN1_EXTENSION_ROOT    , dissect_h245_AudioCapability },
  {   6, &hf_h245_receiveAndTransmitAudioCapability, ASN1_EXTENSION_ROOT    , dissect_h245_AudioCapability },
  {   7, &hf_h245_receiveDataApplicationCapability, ASN1_EXTENSION_ROOT    , dissect_h245_DataApplicationCapability },
  {   8, &hf_h245_transmitDataApplicationCapability, ASN1_EXTENSION_ROOT    , dissect_h245_DataApplicationCapability },
  {   9, &hf_h245_receiveAndTransmitDataApplicationCapability, ASN1_EXTENSION_ROOT    , dissect_h245_DataApplicationCapability },
  {  10, &hf_h245_h233EncryptionTransmitCapability, ASN1_EXTENSION_ROOT    , dissect_h245_BOOLEAN },
  {  11, &hf_h245_h233EncryptionReceiveCapability, ASN1_EXTENSION_ROOT    , dissect_h245_T_h233EncryptionReceiveCapability },
  {  12, &hf_h245_conferenceCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_ConferenceCapability },
  {  13, &hf_h245_h235SecurityCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_H235SecurityCapability },
  {  14, &hf_h245_maxPendingReplacementFor, ASN1_NOT_EXTENSION_ROOT, dissect_h245_INTEGER_0_255 },
  {  15, &hf_h245_receiveUserInputCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_UserInputCapability },
  {  16, &hf_h245_transmitUserInputCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_UserInputCapability },
  {  17, &hf_h245_receiveAndTransmitUserInputCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_UserInputCapability },
  {  18, &hf_h245_genericControlCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericCapability },
  {  19, &hf_h245_receiveMultiplexedStreamCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultiplexedStreamCapability },
  {  20, &hf_h245_transmitMultiplexedStreamCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultiplexedStreamCapability },
  {  21, &hf_h245_receiveAndTransmitMultiplexedStreamCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultiplexedStreamCapability },
  {  22, &hf_h245_receiveRTPAudioTelephonyEventCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_AudioTelephonyEventCapability },
  {  23, &hf_h245_receiveRTPAudioToneCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_AudioToneCapability },
  {  24, &hf_h245_depFecCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_DepFECCapability },
  {  25, &hf_h245_multiplePayloadStreamCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultiplePayloadStreamCapability },
  {  26, &hf_h245_fecCapability  , ASN1_NOT_EXTENSION_ROOT, dissect_h245_FECCapability },
  {  27, &hf_h245_redundancyEncodingCap, ASN1_NOT_EXTENSION_ROOT, dissect_h245_RedundancyEncodingCapability },
  {  28, &hf_h245_oneOfCapabilities, ASN1_NOT_EXTENSION_ROOT, dissect_h245_AlternativeCapabilitySet },
  { 0, NULL, 0, NULL }
};

int
dissect_h245_Capability(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("Capability:");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Capability, Capability_choice,
                                 NULL);
  
  return offset;
}


static const per_sequence_t CapabilityTableEntry_sequence[] = {
  { &hf_h245_capabilityTableEntryNumber, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityTableEntryNumber },
  { &hf_h245_capability     , ASN1_NO_EXTENSIONS     , ASN1_OPTIONAL    , dissect_h245_Capability },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CapabilityTableEntry(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("CapabilityTableEntry\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CapabilityTableEntry, CapabilityTableEntry_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_256_OF_CapabilityTableEntry_set_of[1] = {
  { &hf_h245_capabilityTable_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityTableEntry },
};

static int
dissect_h245_SET_SIZE_1_256_OF_CapabilityTableEntry(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("capabilityTable:");
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_256_OF_CapabilityTableEntry, SET_SIZE_1_256_OF_CapabilityTableEntry_set_of,
                                             1, 256, FALSE);

  return offset;
}



static int
dissect_h245_CapabilityDescriptorNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("CapabilityDescriptorNumber:");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, NULL, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  return offset;
}


static const per_sequence_t CapabilityDescriptor_sequence[] = {
  { &hf_h245_capabilityDescriptorNumber, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityDescriptorNumber },
  { &hf_h245_simultaneousCapabilities, ASN1_NO_EXTENSIONS     , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_256_OF_AlternativeCapabilitySet },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CapabilityDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("CapabilityDescriptor\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CapabilityDescriptor, CapabilityDescriptor_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_256_OF_CapabilityDescriptor_set_of[1] = {
  { &hf_h245_capabilityDescriptors_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityDescriptor },
};

static int
dissect_h245_SET_SIZE_1_256_OF_CapabilityDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("CapabilityDescriptors:");
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_256_OF_CapabilityDescriptor, SET_SIZE_1_256_OF_CapabilityDescriptor_set_of,
                                             1, 256, FALSE);

  return offset;
}



static int
dissect_h245_T_subMessageIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 620 "../../asn1/h245/h245.cnf"
  guint32 subMessageIdentifer;
////  gef_ctx_t *gefx;

  //gefx = gef_ctx_get(actx->private_data);
 // if (gefx) {
	///* If this is a standard generic message use hf_h245_subMessageIdentifier_standard to get
	// * the value translated and make it fileterable.
	// */
 //   if (strcmp("GenericMessage/0.0.8.239.2", gefx->key) == 0) {
 //     hf_index = hf_h245_subMessageIdentifier_standard;
 //   }
 // }
  
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 127U, &subMessageIdentifer, FALSE);

  //if (gefx) {
  //  gefx->subid = ep_strdup_printf("%u", subMessageIdentifer);
  // // gef_ctx_update_key(gef_ctx_get(actx->private_data));
  //  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG CapabilityIdentifier: %s", gef_ctx_get(actx->private_data)->key);*/
  //}
  if (hf_index == hf_h245_subMessageIdentifier_standard)
  {
   /// col_append_fstr(actx->pinfo->cinfo, COL_INFO, 
	  printf("%s\n", val_to_str(subMessageIdentifer, h245_h239subMessageIdentifier_vals, "<unknown>") );
 //   g_snprintf(h245_pi->frame_label, 50, "%s", val_to_str(subMessageIdentifer, h245_h239subMessageIdentifier_vals, "<unknown>"));
  }


  return offset;
}



static int
dissect_h245_T_messageContent_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 647 "../../asn1/h245/h245.cnf"
 /* gef_ctx_t *parent_gefx;

  parent_gefx = gef_ctx_get(actx->private_data);
  actx->private_data = gef_ctx_alloc(parent_gefx, NULL);
*/
  offset = dissect_h245_GenericParameter(tvb, offset, actx, hf_index);

//#line 652 "../../asn1/h245/h245.cnf"
  //actx->private_data = parent_gefx;

  return offset;
}


static const per_sequence_t T_messageContent_sequence_of[1] = {
  { &hf_h245_messageContent_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_messageContent_item },
};

static int
dissect_h245_T_messageContent(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_T_messageContent, T_messageContent_sequence_of);

  return offset;
}


static const per_sequence_t GenericMessage_sequence[] = {
  { &hf_h245_messageIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityIdentifier },
  { &hf_h245_subMessageIdentifier, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_subMessageIdentifier },
  { &hf_h245_messageContent , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_messageContent },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_GenericMessage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 606 "../../asn1/h245/h245.cnf"
  void *priv_data = actx->private_data;
 // gef_ctx_t *gefx;

  /* check if not inherited from GenericInformation */
  /*gefx = gef_ctx_get(actx->private_data);
  if (!gefx) {
    gefx = gef_ctx_alloc(NULL, "GenericMessage");
    actx->private_data = gefx;
  }*/
    printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_GenericMessage, GenericMessage_sequence);

//#line 616 "../../asn1/h245/h245.cnf"
  actx->private_data = priv_data;

  return offset;
}



static int
dissect_h245_GenericInformation(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 657 "../../asn1/h245/h245.cnf"
  void *priv_data = actx->private_data;
 // actx->private_data = gef_ctx_alloc(NULL, "GenericInformation");

  offset = dissect_h245_GenericMessage(tvb, offset, actx, hf_index);

//#line 660 "../../asn1/h245/h245.cnf"
  actx->private_data = priv_data;

  return offset;
}


static const per_sequence_t SEQUENCE_OF_GenericInformation_sequence_of[1] = {
  { &hf_h245_genericInformation_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_GenericInformation },
};

static int
dissect_h245_SEQUENCE_OF_GenericInformation(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_GenericInformation, SEQUENCE_OF_GenericInformation_sequence_of);

  return offset;
}


static const per_sequence_t TerminalCapabilitySet_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OBJECT_IDENTIFIER },
  { &hf_h245_multiplexCapability, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_MultiplexCapability },
  { &hf_h245_capabilityTable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_256_OF_CapabilityTableEntry },
  { &hf_h245_capabilityDescriptors, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_256_OF_CapabilityDescriptor },
  { &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_GenericInformation },
  { NULL, 0, 0, NULL }
};


static int
dissect_h245_TerminalCapabilitySet(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
   printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_TerminalCapabilitySet, TerminalCapabilitySet_sequence);

//#line 591 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_TermCapSet;

  return offset;
}



static int
dissect_h245_LogicalChannelNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 123 "../../asn1/h245/h245.cnf"
  guint32 value;
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 65535U, &value, FALSE);
  printf("%d\n",h_245_message_value.vendor_value);
  h245_lc_temp = value & 0xfff;


  return offset;
}



static int
dissect_h245_OLC_fw_lcn(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("forwardLogicalChannelNumber:");
  offset = dissect_h245_LogicalChannelNumber(tvb, offset, actx, hf_index);

//#line 164 "../../asn1/h245/h245.cnf"
  if (upcoming_olc) upcoming_olc->fwd_lc_num = h245_lc_temp;
  h223_fw_lc_num = h245_lc_temp;

  return offset;
}


static const value_string h245_EncryptionMode_vals[] = {
  {   0, "nonStandard" },
  {   1, "h233Encryption" },
  { 0, NULL }
};

static const per_choice_t EncryptionMode_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_h233Encryption , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_EncryptionMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_EncryptionMode, EncryptionMode_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_INTEGER_0_127(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 127U, NULL, FALSE);

  return offset;
}


static const per_sequence_t RedundancyEncodingElement_sequence[] = {
  { &hf_h245_dataType       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_DataType },
  { &hf_h245_payloadType    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_127 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RedundancyEncodingElement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RedundancyEncodingElement, RedundancyEncodingElement_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_RedundancyEncodingElement_sequence_of[1] = {
  { &hf_h245_secondary_item , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_RedundancyEncodingElement },
};

static int
dissect_h245_SEQUENCE_OF_RedundancyEncodingElement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_RedundancyEncodingElement, SEQUENCE_OF_RedundancyEncodingElement_sequence_of);

  return offset;
}


static const per_sequence_t T_rtpRedundancyEncoding_sequence[] = {
  { &hf_h245_primary        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_RedundancyEncodingElement },
  { &hf_h245_secondary      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_RedundancyEncodingElement },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_rtpRedundancyEncoding(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_rtpRedundancyEncoding, T_rtpRedundancyEncoding_sequence);

  return offset;
}


static const per_sequence_t RedundancyEncoding_sequence[] = {
  { &hf_h245_redundancyEncodingMethod, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_RedundancyEncodingMethod },
  { &hf_h245_secondaryEncoding, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_DataType },
  { &hf_h245_rtpRedundancyEncoding, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_T_rtpRedundancyEncoding },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RedundancyEncoding(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RedundancyEncoding, RedundancyEncoding_sequence);

  return offset;
}


static const per_sequence_t MultiplePayloadStreamElement_sequence[] = {
  { &hf_h245_dataType       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_DataType },
  { &hf_h245_payloadType    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_127 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplePayloadStreamElement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplePayloadStreamElement, MultiplePayloadStreamElement_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_MultiplePayloadStreamElement_sequence_of[1] = {
  { &hf_h245_elements_item  , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MultiplePayloadStreamElement },
};

static int
dissect_h245_SEQUENCE_OF_MultiplePayloadStreamElement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_MultiplePayloadStreamElement, SEQUENCE_OF_MultiplePayloadStreamElement_sequence_of);

  return offset;
}


static const per_sequence_t MultiplePayloadStream_sequence[] = {
  { &hf_h245_elements       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SEQUENCE_OF_MultiplePayloadStreamElement },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplePayloadStream(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplePayloadStream, MultiplePayloadStream_sequence);

  return offset;
}


static const per_sequence_t T_differentPort_sequence[] = {
  { &hf_h245_protectedSessionID, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { &hf_h245_protectedPayloadType, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_127 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_differentPort(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_differentPort, T_differentPort_sequence);

  return offset;
}


static const per_sequence_t T_samePort_sequence[] = {
  { &hf_h245_protectedPayloadType, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_127 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_samePort(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_samePort, T_samePort_sequence);

  return offset;
}


static const value_string h245_DepSeparateStream_vals[] = {
  {   0, "differentPort" },
  {   1, "samePort" },
  { 0, NULL }
};

static const per_choice_t DepSeparateStream_choice[] = {
  {   0, &hf_h245_differentPort  , ASN1_EXTENSION_ROOT    , dissect_h245_T_differentPort },
  {   1, &hf_h245_samePort       , ASN1_EXTENSION_ROOT    , dissect_h245_T_samePort },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_DepSeparateStream(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_DepSeparateStream, DepSeparateStream_choice,
                                 NULL);

  return offset;
}


static const value_string h245_FECdata_mode_vals[] = {
  {   0, "redundancyEncoding" },
  {   1, "separateStream" },
  { 0, NULL }
};

static const per_choice_t FECdata_mode_choice[] = {
  {   0, &hf_h245_redundancyEncodingFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_separateStream , ASN1_EXTENSION_ROOT    , dissect_h245_DepSeparateStream },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_FECdata_mode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_FECdata_mode, FECdata_mode_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t RFC2733Data_sequence[] = {
  { &hf_h245_fec_data_mode  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_FECdata_mode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RFC2733Data(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RFC2733Data, RFC2733Data_sequence);

  return offset;
}


static const value_string h245_DepFECData_vals[] = {
  {   0, "rfc2733" },
  { 0, NULL }
};

static const per_choice_t DepFECData_choice[] = {
  {   0, &hf_h245_dep_rfc2733    , ASN1_NO_EXTENSIONS     , dissect_h245_RFC2733Data },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_DepFECData(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_DepFECData, DepFECData_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_mode_rfc2733sameport_sequence[] = {
  { NULL, ASN1_EXTENSION_ROOT, 0, NULL }
};

static int
dissect_h245_T_mode_rfc2733sameport(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_mode_rfc2733sameport, T_mode_rfc2733sameport_sequence);

  return offset;
}


static const per_sequence_t T_mode_rfc2733diffport_sequence[] = {
  { &hf_h245_protectedChannel, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_mode_rfc2733diffport(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_mode_rfc2733diffport, T_mode_rfc2733diffport_sequence);

  return offset;
}


static const value_string h245_T_pktMode_vals[] = {
  {   0, "rfc2198coding" },
  {   1, "rfc2733sameport" },
  {   2, "rfc2733diffport" },
  { 0, NULL }
};

static const per_choice_t T_pktMode_choice[] = {
  {   0, &hf_h245_rfc2198coding  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_mode_rfc2733sameport, ASN1_EXTENSION_ROOT    , dissect_h245_T_mode_rfc2733sameport },
  {   2, &hf_h245_mode_rfc2733diffport, ASN1_EXTENSION_ROOT    , dissect_h245_T_mode_rfc2733diffport },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_pktMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_pktMode, T_pktMode_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_rfc2733_sequence[] = {
  { &hf_h245_protectedPayloadType, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_127 },
  { &hf_h245_fecScheme      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OBJECT_IDENTIFIER },
  { &hf_h245_pktMode        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_pktMode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_rfc2733(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_rfc2733, T_rfc2733_sequence);

  return offset;
}


static const value_string h245_FECData_vals[] = {
  {   0, "rfc2733" },
  { 0, NULL }
};

static const per_choice_t FECData_choice[] = {
  {   0, &hf_h245_rfc2733        , ASN1_EXTENSION_ROOT    , dissect_h245_T_rfc2733 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_FECData(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_FECData, FECData_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_mediaType_vals[] = {
  {   0, "nonStandard" },
  {   1, "videoData" },
  {   2, "audioData" },
  {   3, "data" },
  {   4, "redundancyEncoding" },
  {   5, "multiplePayloadStream" },
  {   6, "depFec" },
  {   7, "fec" },
  { 0, NULL }
};

static const per_choice_t T_mediaType_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_videoData      , ASN1_EXTENSION_ROOT    , dissect_h245_VideoCapability },
  {   2, &hf_h245_audioData      , ASN1_EXTENSION_ROOT    , dissect_h245_AudioCapability },
  {   3, &hf_h245_data           , ASN1_EXTENSION_ROOT    , dissect_h245_DataApplicationCapability },
  {   4, &hf_h245_redundancyEncoding, ASN1_NOT_EXTENSION_ROOT, dissect_h245_RedundancyEncoding },
  {   5, &hf_h245_multiplePayloadStream, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultiplePayloadStream },
  {   6, &hf_h245_depFec         , ASN1_NOT_EXTENSION_ROOT, dissect_h245_DepFECData },
  {   7, &hf_h245_fec            , ASN1_NOT_EXTENSION_ROOT, dissect_h245_FECData },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_mediaType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_mediaType, T_mediaType_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H235Media_sequence[] = {
  { &hf_h245_encryptionAuthenticationAndIntegrity, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_EncryptionAuthenticationAndIntegrity },
  { &hf_h245_mediaType      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_mediaType },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H235Media(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H235Media, H235Media_sequence);

  return offset;
}


static const per_sequence_t MultiplexedStreamParameter_sequence[] = {
  { &hf_h245_multiplexFormat, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexFormat },
  { &hf_h245_controlOnMuxStream, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexedStreamParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexedStreamParameter, MultiplexedStreamParameter_sequence);

  return offset;
}


static const value_string h245_DataType_vals[] = {
  {   0, "nonStandard" },
  {   1, "nullData" },
  {   2, "videoData" },
  {   3, "audioData" },
  {   4, "data" },
  {   5, "encryptionData" },
  {   6, "h235Control" },
  {   7, "h235Media" },
  {   8, "multiplexedStream" },
  {   9, "redundancyEncoding" },
  {  10, "multiplePayloadStream" },
  {  11, "depFec" },
  {  12, "fec" },
  { 0, NULL }
};

static const per_choice_t DataType_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_nullData       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_videoData      , ASN1_EXTENSION_ROOT    , dissect_h245_VideoCapability },
  {   3, &hf_h245_audioData      , ASN1_EXTENSION_ROOT    , dissect_h245_AudioCapability },
  {   4, &hf_h245_data           , ASN1_EXTENSION_ROOT    , dissect_h245_DataApplicationCapability },
  {   5, &hf_h245_encryptionData , ASN1_EXTENSION_ROOT    , dissect_h245_EncryptionMode },
  {   6, &hf_h245_h235Control    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NonStandardParameter },
  {   7, &hf_h245_h235Media      , ASN1_NOT_EXTENSION_ROOT, dissect_h245_H235Media },
  {   8, &hf_h245_multiplexedStream, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultiplexedStreamParameter },
  {   9, &hf_h245_redundancyEncoding, ASN1_NOT_EXTENSION_ROOT, dissect_h245_RedundancyEncoding },
  {  10, &hf_h245_multiplePayloadStream, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultiplePayloadStream },
  {  11, &hf_h245_depFec         , ASN1_NOT_EXTENSION_ROOT, dissect_h245_DepFECData },
  {  12, &hf_h245_fec            , ASN1_NOT_EXTENSION_ROOT, dissect_h245_FECData },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_DataType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 1012 "../../asn1/h245/h245.cnf"
gint choice_index;
printf("DataType:");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_DataType, DataType_choice,
                                 &choice_index);


if (upcoming_channel){
	if (choice_index==2){
		upcoming_channel->is_video=TRUE;
	}else{
		upcoming_channel->is_video=FALSE;
	}
}



  return offset;
}



static int
dissect_h245_INTEGER_0_8191(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 8191U, NULL, FALSE);

  return offset;
}


static const per_sequence_t H222LogicalChannelParameters_sequence[] = {
  { &hf_h245_resourceID     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_subChannelID   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_8191 },
  { &hf_h245_pcr_pid        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_8191 },
  { &hf_h245_programDescriptors, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OCTET_STRING },
  { &hf_h245_streamDescriptors, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OCTET_STRING },
  { NULL, 0, 0, NULL }
};
static const value_string h245_OLC_forw_multiplexParameters_vals[] = {
  {   0, "h222LogicalChannelParameters" },
  {   1, "h223LogicalChannelParameters" },
  {   2, "v76LogicalChannelParameters" },
  {   3, "h2250LogicalChannelParameters" },
  {   4, "none" },
  { 0, NULL }
};

static int
dissect_h245_H222LogicalChannelParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H222LogicalChannelParameters, H222LogicalChannelParameters_sequence);

  return offset;
}



static int
dissect_h245_T_h223_al_type_al1Framed(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 295 "../../asn1/h245/h245.cnf"
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al1Framed;

  offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}



static int
dissect_h245_T_h223_al_type_al1NotFramed(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 300 "../../asn1/h245/h245.cnf"
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al1NotFramed;

  offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}



static int
dissect_h245_T_h223_al_type_al2WithoutSequenceNumbers(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 305 "../../asn1/h245/h245.cnf"
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al2WithoutSequenceNumbers;

  offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}



static int
dissect_h245_T_h223_al_type_al2WithSequenceNumbers(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 310 "../../asn1/h245/h245.cnf"
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al2WithSequenceNumbers;

  offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}



static int
dissect_h245_T_controlFieldOctets(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 324 "../../asn1/h245/h245.cnf"
  guint32 value;
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 2U, &value, FALSE);

  if(h223_lc_params_temp && h223_lc_params_temp->al_params)
	((h223_al3_params*)h223_lc_params_temp->al_params)->control_field_octets = value & 3 ;


  return offset;
}



static int
dissect_h245_T_al3_sendBufferSize(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 333 "../../asn1/h245/h245.cnf"
  guint32 value;
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 16777215U, &value, FALSE);

  if(h223_lc_params_temp && h223_lc_params_temp->al_params)
	((h223_al3_params*)h223_lc_params_temp->al_params)->send_buffer_size = value & 0xfffff;


  return offset;
}


static const per_sequence_t Al3_sequence[] = {
  { &hf_h245_controlFieldOctets, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_controlFieldOctets },
  { &hf_h245_al3_sendBufferSize, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T_al3_sendBufferSize },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Al3(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Al3, Al3_sequence);

  return offset;
}



static int
dissect_h245_T_h223_al_type_al3(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 315 "../../asn1/h245/h245.cnf"
 if(h223_lc_params_temp) {
	h223_lc_params_temp->al_type = al3;
	//h223_lc_params_temp->al_params = se_alloc(sizeof(h223_al3_params));
  }

  offset = dissect_h245_Al3(tvb, offset, actx, hf_index);

  return offset;
}


static const value_string h245_T_transferMode_vals[] = {
  {   0, "framed" },
  {   1, "unframed" },
  { 0, NULL }
};

static const per_choice_t T_transferMode_choice[] = {
  {   0, &hf_h245_framed         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_unframed       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_transferMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_transferMode, T_transferMode_choice,
                                 NULL);

  return offset;
}


static const value_string h245_AL1HeaderFEC_vals[] = {
  {   0, "sebch16-7" },
  {   1, "golay24-12" },
  { 0, NULL }
};

static const per_choice_t AL1HeaderFEC_choice[] = {
  {   0, &hf_h245_sebch16_7      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_golay24_12     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_AL1HeaderFEC(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_AL1HeaderFEC, AL1HeaderFEC_choice,
                                 NULL);

  return offset;
}


static const value_string h245_AL1CrcLength_vals[] = {
  {   0, "crc4bit" },
  {   1, "crc12bit" },
  {   2, "crc20bit" },
  {   3, "crc28bit" },
  {   4, "crc8bit" },
  {   5, "crc16bit" },
  {   6, "crc32bit" },
  {   7, "crcNotUsed" },
  { 0, NULL }
};

static const per_choice_t AL1CrcLength_choice[] = {
  {   0, &hf_h245_crc4bit        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_crc12bit       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_crc20bit       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_crc28bit       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_crc8bit        , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   5, &hf_h245_crc16bit       , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   6, &hf_h245_crc32bit       , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   7, &hf_h245_crcNotUsed     , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_AL1CrcLength(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_AL1CrcLength, AL1CrcLength_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_INTEGER_8_32(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            8U, 32U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_0_16(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 16U, NULL, FALSE);

  return offset;
}


static const value_string h245_T_numberOfRetransmissions_vals[] = {
  {   0, "finite" },
  {   1, "infinite" },
  { 0, NULL }
};

static const per_choice_t T_numberOfRetransmissions_choice[] = {
  {   0, &hf_h245_finite         , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_0_16 },
  {   1, &hf_h245_infinite       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_numberOfRetransmissions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_numberOfRetransmissions, T_numberOfRetransmissions_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H223AnnexCArqParameters_sequence[] = {
  { &hf_h245_numberOfRetransmissions, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_numberOfRetransmissions },
  { &hf_h245_sendBufferSize , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_16777215 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H223AnnexCArqParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H223AnnexCArqParameters, H223AnnexCArqParameters_sequence);

  return offset;
}


static const value_string h245_ArqType_vals[] = {
  {   0, "noArq" },
  {   1, "typeIArq" },
  {   2, "typeIIArq" },
  { 0, NULL }
};

static const per_choice_t ArqType_choice[] = {
  {   0, &hf_h245_noArq          , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_typeIArq       , ASN1_EXTENSION_ROOT    , dissect_h245_H223AnnexCArqParameters },
  {   2, &hf_h245_typeIIArq      , ASN1_EXTENSION_ROOT    , dissect_h245_H223AnnexCArqParameters },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ArqType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ArqType, ArqType_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H223AL1MParameters_sequence[] = {
  { &hf_h245_transferMode   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_transferMode },
  { &hf_h245_aL1HeaderFEC   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_AL1HeaderFEC },
  { &hf_h245_crcLength2     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_AL1CrcLength },
  { &hf_h245_rcpcCodeRate   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_8_32 },
  { &hf_h245_arqType        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ArqType },
  { &hf_h245_alpduInterleaving, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_alsduSplitting , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_rsCodeCorrection, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_0_127 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H223AL1MParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H223AL1MParameters, H223AL1MParameters_sequence);

  return offset;
}



static int
dissect_h245_T_h223_al_type_al1M(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 340 "../../asn1/h245/h245.cnf"
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al1M;

  offset = dissect_h245_H223AL1MParameters(tvb, offset, actx, hf_index);

  return offset;
}


static const value_string h245_AL2HeaderFEC_vals[] = {
  {   0, "sebch16-5" },
  {   1, "golay24-12" },
  { 0, NULL }
};

static const per_choice_t AL2HeaderFEC_choice[] = {
  {   0, &hf_h245_sebch16_5      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_golay24_12     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_AL2HeaderFEC(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_AL2HeaderFEC, AL2HeaderFEC_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H223AL2MParameters_sequence[] = {
  { &hf_h245_aL2HeaderFEC   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_AL2HeaderFEC },
  { &hf_h245_alpduInterleaving, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H223AL2MParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H223AL2MParameters, H223AL2MParameters_sequence);

  return offset;
}



static int
dissect_h245_T_h223_al_type_al2M(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 345 "../../asn1/h245/h245.cnf"
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al2M;

  offset = dissect_h245_H223AL2MParameters(tvb, offset, actx, hf_index);

  return offset;
}


static const value_string h245_T_headerFormat_vals[] = {
  {   0, "sebch16-7" },
  {   1, "golay24-12" },
  { 0, NULL }
};

static const per_choice_t T_headerFormat_choice[] = {
  {   0, &hf_h245_sebch16_7      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_golay24_12     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_headerFormat(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_headerFormat, T_headerFormat_choice,
                                 NULL);

  return offset;
}


static const value_string h245_AL3CrcLength_vals[] = {
  {   0, "crc4bit" },
  {   1, "crc12bit" },
  {   2, "crc20bit" },
  {   3, "crc28bit" },
  {   4, "crc8bit" },
  {   5, "crc16bit" },
  {   6, "crc32bit" },
  {   7, "crcNotUsed" },
  { 0, NULL }
};

static const per_choice_t AL3CrcLength_choice[] = {
  {   0, &hf_h245_crc4bit        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_crc12bit       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_crc20bit       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_crc28bit       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_crc8bit        , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   5, &hf_h245_crc16bit       , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   6, &hf_h245_crc32bit       , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   7, &hf_h245_crcNotUsed     , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_AL3CrcLength(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_AL3CrcLength, AL3CrcLength_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H223AL3MParameters_sequence[] = {
  { &hf_h245_headerFormat   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_headerFormat },
  { &hf_h245_crlength2      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_AL3CrcLength },
  { &hf_h245_rcpcCodeRate   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_8_32 },
  { &hf_h245_arqType        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ArqType },
  { &hf_h245_alpduInterleaving, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_rsCodeCorrection, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_0_127 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H223AL3MParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H223AL3MParameters, H223AL3MParameters_sequence);

  return offset;
}



static int
dissect_h245_T_h223_al_type_al3M(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 350 "../../asn1/h245/h245.cnf"
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al3M;

  offset = dissect_h245_H223AL3MParameters(tvb, offset, actx, hf_index);

  return offset;
}


static const value_string h245_T_adaptationLayerType_vals[] = {
  {   0, "nonStandard" },
  {   1, "al1Framed" },
  {   2, "al1NotFramed" },
  {   3, "al2WithoutSequenceNumbers" },
  {   4, "al2WithSequenceNumbers" },
  {   5, "al3" },
  {   6, "al1M" },
  {   7, "al2M" },
  {   8, "al3M" },
  { 0, NULL }
};

static const per_choice_t T_adaptationLayerType_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_h223_al_type_al1Framed, ASN1_EXTENSION_ROOT    , dissect_h245_T_h223_al_type_al1Framed },
  {   2, &hf_h245_h223_al_type_al1NotFramed, ASN1_EXTENSION_ROOT    , dissect_h245_T_h223_al_type_al1NotFramed },
  {   3, &hf_h245_h223_al_type_al2WithoutSequenceNumbers, ASN1_EXTENSION_ROOT    , dissect_h245_T_h223_al_type_al2WithoutSequenceNumbers },
  {   4, &hf_h245_h223_al_type_al2WithSequenceNumbers, ASN1_EXTENSION_ROOT    , dissect_h245_T_h223_al_type_al2WithSequenceNumbers },
  {   5, &hf_h245_h223_al_type_al3, ASN1_EXTENSION_ROOT    , dissect_h245_T_h223_al_type_al3 },
  {   6, &hf_h245_h223_al_type_al1M, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_h223_al_type_al1M },
  {   7, &hf_h245_h223_al_type_al2M, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_h223_al_type_al2M },
  {   8, &hf_h245_h223_al_type_al3M, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_h223_al_type_al3M },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_adaptationLayerType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_adaptationLayerType, T_adaptationLayerType_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_T_h223_lc_segmentableFlag(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 357 "../../asn1/h245/h245.cnf"
  gboolean value;
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, &value);

  if(h223_lc_params_temp)
	h223_lc_params_temp->segmentable = value;


  return offset;
}


static const per_sequence_t H223LogicalChannelParameters_sequence[] = {
  { &hf_h245_adaptationLayerType, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_adaptationLayerType },
  { &hf_h245_h223_lc_segmentableFlag, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_h223_lc_segmentableFlag },
  { NULL, 0, 0, NULL }
};

int
dissect_h245_H223LogicalChannelParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H223LogicalChannelParameters, H223LogicalChannelParameters_sequence);

  return offset;
}



static int
dissect_h245_OLC_fw_h223_params(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 186 "../../asn1/h245/h245.cnf"
//  h223_fw_lc_params = se_alloc(sizeof(h223_lc_params));
  h223_fw_lc_params->al_type = al_nonStandard;
  h223_fw_lc_params->al_params = NULL;
  h223_fw_lc_params->segmentable = 0;
  h223_fw_lc_params->subdissector = NULL;
  h223_lc_params_temp = h223_fw_lc_params;

  offset = dissect_h245_H223LogicalChannelParameters(tvb, offset, actx, hf_index);

  return offset;
}


static const value_string h245_CRCLength_vals[] = {
  {   0, "crc8bit" },
  {   1, "crc16bit" },
  {   2, "crc32bit" },
  { 0, NULL }
};

static const per_choice_t CRCLength_choice[] = {
  {   0, &hf_h245_crc8bit        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_crc16bit       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_crc32bit       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_CRCLength(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_CRCLength, CRCLength_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t V76HDLCParameters_sequence[] = {
  { &hf_h245_crcLength      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_CRCLength },
  { &hf_h245_n401           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_4095 },
  { &hf_h245_loopbackTestProcedure, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_V76HDLCParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_V76HDLCParameters, V76HDLCParameters_sequence);

  return offset;
}


static const value_string h245_T_suspendResume_vals[] = {
  {   0, "noSuspendResume" },
  {   1, "suspendResumewAddress" },
  {   2, "suspendResumewoAddress" },
  { 0, NULL }
};

static const per_choice_t T_suspendResume_choice[] = {
  {   0, &hf_h245_noSuspendResume, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_suspendResumewAddress, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_suspendResumewoAddress, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_suspendResume(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_suspendResume, T_suspendResume_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_recovery_vals[] = {
  {   0, "rej" },
  {   1, "sREJ" },
  {   2, "mSREJ" },
  { 0, NULL }
};

static const per_choice_t T_recovery_choice[] = {
  {   0, &hf_h245_rej            , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_sREJ           , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_mSREJ          , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_recovery(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_recovery, T_recovery_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_eRM_sequence[] = {
  { &hf_h245_windowSize     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_127 },
  { &hf_h245_recovery       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_recovery },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_eRM(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_eRM, T_eRM_sequence);

  return offset;
}


static const value_string h245_V76LCP_mode_vals[] = {
  {   0, "eRM" },
  {   1, "uNERM" },
  { 0, NULL }
};

static const per_choice_t V76LCP_mode_choice[] = {
  {   0, &hf_h245_eRM            , ASN1_EXTENSION_ROOT    , dissect_h245_T_eRM },
  {   1, &hf_h245_uNERM          , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_V76LCP_mode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_V76LCP_mode, V76LCP_mode_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t V75Parameters_sequence[] = {
  { &hf_h245_audioHeaderPresent, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_V75Parameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_V75Parameters, V75Parameters_sequence);

  return offset;
}


static const per_sequence_t V76LogicalChannelParameters_sequence[] = {
  { &hf_h245_hdlcParameters , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_V76HDLCParameters },
  { &hf_h245_suspendResume  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_suspendResume },
  { &hf_h245_uIH            , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_v76_mode       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_V76LCP_mode },
  { &hf_h245_v75Parameters  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_V75Parameters },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_V76LogicalChannelParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_V76LogicalChannelParameters, V76LogicalChannelParameters_sequence);

  return offset;
}



static int
dissect_h245_Ipv4_network(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 870 "../../asn1/h245/h245.cnf"
  tvbuff_t *value_tvb;
  printf("network:");
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       4, 4, FALSE, &value_tvb);

  for(int i=0;i<4;i++){
	  printf("%d.",tvb_get_guint8((tvbuff_t*)h_245_message_value.octet_ip,i));
  }
  printf("\n");
  if (upcoming_channel && upcoming_channel->upcoming_addr) {
    tvb_memcpy(value_tvb, upcoming_channel->upcoming_addr->addr_buf, 0, 4);
    SET_ADDRESS(&upcoming_channel->upcoming_addr->addr, AT_IPv4, 4, upcoming_channel->upcoming_addr->addr_buf);
  }


  return offset;
}



static int
dissect_h245_TsapIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 881 "../../asn1/h245/h245.cnf"
  guint32 tsapIdentifier;
   printf("TsapIdentifier:");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, &tsapIdentifier, FALSE);

  printf("%d\n",h_245_message_value.vendor_value);
  if (upcoming_channel && upcoming_channel->upcoming_addr) {
    upcoming_channel->upcoming_addr->port = tsapIdentifier;
  }


  return offset;
}


static const per_sequence_t T_iPAddress_sequence[] = {
  { &hf_h245_ip4_network    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Ipv4_network },
  { &hf_h245_tsapIdentifier , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TsapIdentifier },
  { NULL, 0, 0, NULL }
};
const value_string h245_UnicastAddress_vals[] = {
  {   0, "iPAddress" },
  {   1, "iPXAddress" },
  {   2, "iP6Address" },
  {   3, "netBios" },
  {   4, "iPSourceRouteAddress" },
  {   5, "nsap" },
  {   6, "nonStandardAddress" },
  { 0, NULL }
};
static int
dissect_h245_T_iPAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_UnicastAddress_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_UnicastAddress_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_iPAddress, T_iPAddress_sequence);

  return offset;
}



static int
dissect_h245_OCTET_STRING_SIZE_6(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       6, 6, FALSE, NULL);

  return offset;
}



static int
dissect_h245_OCTET_STRING_SIZE_4(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       4, 4, FALSE, NULL);

  return offset;
}



static int
dissect_h245_OCTET_STRING_SIZE_2(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       2, 2, FALSE, NULL);

  return offset;
}


static const per_sequence_t T_iPXAddress_sequence[] = {
  { &hf_h245_node           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_6 },
  { &hf_h245_netnum         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_4 },
  { &hf_h245_ipx_tsapIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_2 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_iPXAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_iPXAddress, T_iPXAddress_sequence);

  return offset;
}


static const per_sequence_t T_iP6Address_sequence[] = {
  { &hf_h245_ip6_network    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_16 },
  { &hf_h245_ipv6_tsapIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_iP6Address(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_iP6Address, T_iP6Address_sequence);

  return offset;
}


static const value_string h245_T_routing_vals[] = {
  {   0, "strict" },
  {   1, "loose" },
  { 0, NULL }
};

static const per_choice_t T_routing_choice[] = {
  {   0, &hf_h245_strict         , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_loose          , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_routing(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_routing, T_routing_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_route_sequence_of[1] = {
  { &hf_h245_route_item     , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_4 },
};

static int
dissect_h245_T_route(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_T_route, T_route_sequence_of);

  return offset;
}


static const per_sequence_t T_iPSourceRouteAddress_sequence[] = {
  { &hf_h245_routing        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_routing },
  { &hf_h245_network        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_4 },
  { &hf_h245_iPSrcRoute_tsapIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_route          , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_route },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_iPSourceRouteAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_iPSourceRouteAddress, T_iPSourceRouteAddress_sequence);

  return offset;
}




static const per_choice_t UnicastAddress_choice[] = {
  {   0, &hf_h245_iPAddress      , ASN1_EXTENSION_ROOT    , dissect_h245_T_iPAddress },
  {   1, &hf_h245_iPXAddress     , ASN1_EXTENSION_ROOT    , dissect_h245_T_iPXAddress },
  {   2, &hf_h245_iP6Address     , ASN1_EXTENSION_ROOT    , dissect_h245_T_iP6Address },
  {   3, &hf_h245_netBios        , ASN1_EXTENSION_ROOT    , dissect_h245_OCTET_STRING_SIZE_16 },
  {   4, &hf_h245_iPSourceRouteAddress, ASN1_EXTENSION_ROOT    , dissect_h245_T_iPSourceRouteAddress },
  {   5, &hf_h245_nsap           , ASN1_NOT_EXTENSION_ROOT, dissect_h245_OCTET_STRING_SIZE_1_20 },
  {   6, &hf_h245_nonStandardAddress, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NonStandardParameter },
  { 0, NULL, 0, NULL }
};
const value_string h245_TransportAddress_vals[] = {
  {   0, "unicastAddress" },
  {   1, "multicastAddress" },
  { 0, NULL }
};
int
dissect_h245_UnicastAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_TransportAddress_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s:", val_to_str(	h_245_message_value.msg_value, h245_TransportAddress_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_UnicastAddress, UnicastAddress_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MIPAddress_sequence[] = {
  { &hf_h245_mip4_network   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_4 },
  { &hf_h245_multicast_tsapIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MIPAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MIPAddress, MIPAddress_sequence);

  return offset;
}


static const per_sequence_t MIP6Address_sequence[] = {
  { &hf_h245_mip6_network   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_16 },
  { &hf_h245_multicast_IPv6_tsapIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MIP6Address(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MIP6Address, MIP6Address_sequence);

  return offset;
}


const value_string h245_MulticastAddress_vals[] = {
  {   0, "iPAddress" },
  {   1, "iP6Address" },
  {   2, "nsap" },
  {   3, "nonStandardAddress" },
  { 0, NULL }
};

static const per_choice_t MulticastAddress_choice[] = {
  {   0, &hf_h245_mIPAddress     , ASN1_EXTENSION_ROOT    , dissect_h245_MIPAddress },
  {   1, &hf_h245_mIP6Address    , ASN1_EXTENSION_ROOT    , dissect_h245_MIP6Address },
  {   2, &hf_h245_nsap           , ASN1_NOT_EXTENSION_ROOT, dissect_h245_OCTET_STRING_SIZE_1_20 },
  {   3, &hf_h245_nonStandardAddress, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NonStandardParameter },
  { 0, NULL, 0, NULL }
};

int
dissect_h245_MulticastAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MulticastAddress, MulticastAddress_choice,
                                 NULL);

  return offset;
}




static const per_choice_t TransportAddress_choice[] = {
  {   0, &hf_h245_unicastAddress , ASN1_EXTENSION_ROOT    , dissect_h245_UnicastAddress },
  {   1, &hf_h245_multicastAddress, ASN1_EXTENSION_ROOT    , dissect_h245_MulticastAddress },
  { 0, NULL, 0, NULL }
};

int
dissect_h245_TransportAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_TransportAddress, TransportAddress_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_T_mediaChannel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 900 "../../asn1/h245/h245.cnf"
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = &upcoming_channel->media_addr;

  offset = dissect_h245_TransportAddress(tvb, offset, actx, hf_index);

//#line 904 "../../asn1/h245/h245.cnf"
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = NULL;

  return offset;
}



static int
dissect_h245_T_mediaControlChannel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 918 "../../asn1/h245/h245.cnf"
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = &upcoming_channel->media_control_addr;
  printf("mediaControlChannel:");
  offset = dissect_h245_TransportAddress(tvb, offset, actx, hf_index);

//#line 922 "../../asn1/h245/h245.cnf"
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = NULL;

  return offset;
}



static int
dissect_h245_McuNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 192U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_TerminalNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 192U, NULL, FALSE);

  return offset;
}


static const per_sequence_t TerminalLabel_sequence[] = {
  { &hf_h245_mcuNumber      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_McuNumber },
  { &hf_h245_terminalNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_TerminalLabel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_TerminalLabel, TerminalLabel_sequence);

  return offset;
}


static const value_string h245_T_mediaPacketization_vals[] = {
  {   0, "h261aVideoPacketization" },
  {   1, "rtpPayloadType" },
  { 0, NULL }
};

static const per_choice_t T_mediaPacketization_choice[] = {
  {   0, &hf_h245_h261aVideoPacketizationFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_rtpPayloadType , ASN1_NOT_EXTENSION_ROOT, dissect_h245_RTPPayloadType },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_mediaPacketization(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_mediaPacketization, T_mediaPacketization_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H2250LogicalChannelParameters_sequence[] = {
  { &hf_h245_nonStandardParams, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_NonStandardParameter },
  { &hf_h245_sessionID_0_255, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255_ },
  { &hf_h245_associatedSessionID, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_255 },
  { &hf_h245_mediaChannel   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_mediaChannel },
  { &hf_h245_mediaGuaranteedDelivery, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_BOOLEAN_mediaGuaranteedDelivery },
  { &hf_h245_mediaControlChannel, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_mediaControlChannel },
  { &hf_h245_mediaControlGuaranteedDelivery, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_BOOLEAN },
  { &hf_h245_silenceSuppression, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_BOOLEAN_silenceSuppression },
  { &hf_h245_destination    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_TerminalLabel },
  { &hf_h245_dynamicRTPPayloadType, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_96_127 },
  { &hf_h245_mediaPacketization, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_mediaPacketization },
  { &hf_h245_transportCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_TransportCapability },
  { &hf_h245_redundancyEncoding, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_RedundancyEncoding },
  { &hf_h245_source         , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_TerminalLabel },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H2250LogicalChannelParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	 printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_OLC_forw_multiplexParameters_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_OLC_forw_multiplexParameters_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H2250LogicalChannelParameters, H2250LogicalChannelParameters_sequence);

  return offset;
}



static const per_choice_t OLC_forw_multiplexParameters_choice[] = {
  {   0, &hf_h245_h222LogicalChannelParameters, ASN1_EXTENSION_ROOT    , dissect_h245_H222LogicalChannelParameters },
  {   1, &hf_h245_olc_fw_h223_params, ASN1_EXTENSION_ROOT    , dissect_h245_OLC_fw_h223_params },
  {   2, &hf_h245_v76LogicalChannelParameters, ASN1_EXTENSION_ROOT    , dissect_h245_V76LogicalChannelParameters },
  {   3, &hf_h245_h2250LogicalChannelParameters, ASN1_NOT_EXTENSION_ROOT, dissect_h245_H2250LogicalChannelParameters },
  {   4, &hf_h245_none           , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_OLC_forw_multiplexParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("multiplexParameters:");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_OLC_forw_multiplexParameters, OLC_forw_multiplexParameters_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_forwardLogicalChannelParameters_sequence[] = {
  { &hf_h245_portNumber     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_65535 },
  { &hf_h245_dataType       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_DataType },
  { &hf_h245_olc_forw_multiplexParameters, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OLC_forw_multiplexParameters },
  { &hf_h245_forwardLogicalChannelDependency, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_LogicalChannelNumber },
  { &hf_h245_replacementFor , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_forwardLogicalChannelParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 169 "../../asn1/h245/h245.cnf"

  upcoming_channel = (upcoming_olc) ? &upcoming_olc->fwd_lc : NULL;

  h245_lc_dissector = NULL;
  printf("forwardLogicalChannelParameters\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_forwardLogicalChannelParameters, T_forwardLogicalChannelParameters_sequence);

  if(h223_lc_params_temp && h245_lc_dissector)
	h223_lc_params_temp->subdissector = h245_lc_dissector;
  else if(h223_lc_params_temp)
	h223_lc_params_temp->subdissector = data_handle;

  if (upcoming_channel && codec_type) {
//    g_strlcpy(upcoming_channel->data_type_str, codec_type, sizeof(upcoming_channel->data_type_str));
  }
  upcoming_channel = NULL;


  return offset;
}



static int
dissect_h245_OLC_rev_h223_params(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 207 "../../asn1/h245/h245.cnf"
//  h223_rev_lc_params = se_alloc(sizeof(h223_lc_params));
  h223_rev_lc_params->al_type = al_nonStandard;
  h223_rev_lc_params->al_params = NULL;
  h223_rev_lc_params->segmentable = 0;
  h223_rev_lc_params->subdissector = NULL;
  h223_lc_params_temp = h223_rev_lc_params;

  offset = dissect_h245_H223LogicalChannelParameters(tvb, offset, actx, hf_index);

  return offset;
}


static const value_string h245_OLC_rev_multiplexParameters_vals[] = {
  {   0, "h223LogicalChannelParameters" },
  {   1, "v76LogicalChannelParameters" },
  {   2, "h2250LogicalChannelParameters" },
  { 0, NULL }
};

static const per_choice_t OLC_rev_multiplexParameters_choice[] = {
  {   0, &hf_h245_olc_rev_h223_params, ASN1_EXTENSION_ROOT    , dissect_h245_OLC_rev_h223_params },
  {   1, &hf_h245_v76LogicalChannelParameters, ASN1_EXTENSION_ROOT    , dissect_h245_V76LogicalChannelParameters },
  {   2, &hf_h245_h2250LogicalChannelParameters, ASN1_NOT_EXTENSION_ROOT, dissect_h245_H2250LogicalChannelParameters },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_OLC_rev_multiplexParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_OLC_rev_multiplexParameters, OLC_rev_multiplexParameters_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t OLC_reverseLogicalChannelParameters_sequence[] = {
  { &hf_h245_dataType       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_DataType },
  { &hf_h245_olc_rev_multiplexParameter, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OLC_rev_multiplexParameters },
  { &hf_h245_reverseLogicalChannelDependency, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_LogicalChannelNumber },
  { &hf_h245_replacementFor , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_OLC_reverseLogicalChannelParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 195 "../../asn1/h245/h245.cnf"

  upcoming_channel = (upcoming_olc) ? &upcoming_olc->rev_lc : NULL;

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_OLC_reverseLogicalChannelParameters, OLC_reverseLogicalChannelParameters_sequence);

	
  if (upcoming_channel && codec_type) {
//    g_strlcpy(upcoming_channel->data_type_str, codec_type, sizeof(upcoming_channel->data_type_str));
  }
  upcoming_channel = NULL;


  return offset;
}


static const value_string h245_T_distribution_vals[] = {
  {   0, "unicast" },
  {   1, "multicast" },
  { 0, NULL }
};

static const per_choice_t T_distribution_choice[] = {
  {   0, &hf_h245_unicast        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_multicast      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_distribution(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_distribution, T_distribution_choice,
                                 NULL);

  return offset;
}

static const char*
sort_alphabet(char *sorted_alphabet, const char *alphabet, int alphabet_length)
{
  int i, j;
  char c, c_max, c_min;
  char tmp_buf[256];

  if (!alphabet_length) return sorted_alphabet;
  memset(tmp_buf, 0, 256);
  c_min = c_max = alphabet[0];
  for (i=0; i<alphabet_length; i++) {
    c = alphabet[i];
    tmp_buf[(int)c] = 1;
    if (c > c_max) c_max = c;
    else if (c < c_min) c_min = c;
  }
  for (i=c_min,j=0; i<=c_max; i++) {
    if (tmp_buf[i]) sorted_alphabet[j++] = i;
  }
  return sorted_alphabet;
}

guint32
dissect_per_restricted_character_string(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, int min_len, int max_len, gboolean has_extension, const char *alphabet, int alphabet_length, tvbuff_t **value_tvb)
{
  const char *alphabet_ptr;
  char sorted_alphabet[128];

  if (alphabet_length > 127) {
    alphabet_ptr = alphabet;
  } else {
    alphabet_ptr = sort_alphabet(sorted_alphabet, alphabet, alphabet_length);
  }
  return dissect_per_restricted_character_string_sorted(tvb, offset, actx,  hf_index, min_len, max_len, has_extension, alphabet_ptr, alphabet_length, value_tvb);
}


static int
dissect_h245_T_e164Address(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_restricted_character_string(tvb, offset, actx, hf_index,
                                                      1, 128, FALSE, "0123456789#*,", 13,
                                                      NULL);

  return offset;
}


static const value_string h245_T_networkAddress_vals[] = {
  {   0, "q2931Address" },
  {   1, "e164Address" },
  {   2, "localAreaAddress" },
  { 0, NULL }
};

static const per_choice_t T_networkAddress_choice[] = {
  {   0, &hf_h245_q2931Address   , ASN1_EXTENSION_ROOT    , dissect_h245_Q2931Address },
  {   1, &hf_h245_e164Address    , ASN1_EXTENSION_ROOT    , dissect_h245_T_e164Address },
  {   2, &hf_h245_localAreaAddress, ASN1_EXTENSION_ROOT    , dissect_h245_TransportAddress },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_networkAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_networkAddress, T_networkAddress_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_OCTET_STRING_SIZE_1_255(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 255, FALSE, NULL);

  return offset;
}


static const value_string h245_T_t120SetupProcedure_vals[] = {
  {   0, "originateCall" },
  {   1, "waitForCall" },
  {   2, "issueQuery" },
  { 0, NULL }
};

static const per_choice_t T_t120SetupProcedure_choice[] = {
  {   0, &hf_h245_originateCall  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_waitForCall    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_issueQuery     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_t120SetupProcedure(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_t120SetupProcedure, T_t120SetupProcedure_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t NetworkAccessParameters_sequence[] = {
  { &hf_h245_distribution   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_distribution },
  { &hf_h245_networkAddress , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_networkAddress },
  { &hf_h245_associateConference, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_externalReference, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OCTET_STRING_SIZE_1_255 },
  { &hf_h245_t120SetupProcedure, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_T_t120SetupProcedure },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_NetworkAccessParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_NetworkAccessParameters, NetworkAccessParameters_sequence);

  return offset;
}



static int
dissect_h245_OCTET_STRING_SIZE_1_65535(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 65535, FALSE, NULL);

  return offset;
}
guint32
dissect_per_bit_string(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, int min_len, int max_len, gboolean has_extension, tvbuff_t **value_tvb)
{
	/*gint val_start, val_length;*/
	guint32 length;
	header_field_info *hfi;
	tvbuff_t *out_tvb = NULL;

	//hfi = (hf_index==-1) ? NULL : proto_registrar_get_nth(hf_index);

//DEBUG_ENTRY("dissect_per_bit_string");
	/* 15.8 if the length is 0 bytes there will be no encoding */
	if(max_len==0) {
		return offset;
	}

	if (min_len == NO_BOUND) {
		min_len = 0;
	}
	/* 15.6	If an extension marker is present in the size constraint specification of the bitstring type,
	 * a single bit shall be added to the field-list in a bit-field of length one.
	 * The bit shall be set to 1 if the length of this encoding is not within the range of the extension root,
	 * and zero otherwise.
	 */
	 if (has_extension) {
		 gboolean extension_present;
		 offset = dissect_per_boolean(tvb, offset, actx, hf_per_extension_present_bit, &extension_present);
		 if(extension_present){
			offset=dissect_per_length_determinant(tvb, offset, actx, hf_per_bit_string_length, &length);
			if(length){
				/* align to byte */
				if (actx->aligned){
					//BYTE_ALIGN_OFFSET(offset);
				}
				//out_tvb = dissect_per_bit_string_display(tvb, offset, actx,  hf_index, hfi, length);
			}
			/* XXX: ?? */
			/*val_start = offset>>3;*/
			/*val_length = (length+7)/8;*/
			offset+=length;

			if (value_tvb)
				*value_tvb = out_tvb;

			return offset;
		 }
	 }

	/* 15.9 if length is fixed and less than or equal to sixteen bits*/
	if ((min_len==max_len) && (max_len<=16)) {
		//out_tvb = dissect_per_bit_string_display(tvb, offset, actx, hf_index, hfi, min_len);
		offset+=min_len;
		if (value_tvb)
			*value_tvb = out_tvb;
		return offset;
	}


	/* 15.10 if length is fixed and less than to 64kbits*/
	if((min_len==max_len)&&(min_len<65536)){
		/* (octet-aligned in the ALIGNED variant)
		 * align to byte
		 */
		if (actx->aligned){
			//BYTE_ALIGN_OFFSET(offset);
		}
	//	out_tvb = dissect_per_bit_string_display(tvb, offset, actx, hf_index, hfi, min_len);
		offset+=min_len;
		if (value_tvb)
			*value_tvb = out_tvb;
		return offset;
	}

	/* 15.11 */
	if (max_len != NO_BOUND) {
		offset=dissect_per_constrained_integer(tvb, offset, actx,
			 hf_per_bit_string_length, min_len, max_len,
			&length, FALSE);
			//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
	} else {
		offset=dissect_per_length_determinant(tvb, offset, actx, hf_per_bit_string_length, &length);
	}
	if(length){
		/* align to byte */
		if (actx->aligned){
			//BYTE_ALIGN_OFFSET(offset);
		}
		//out_tvb = dissect_per_bit_string_display(tvb, offset, actx, hf_index, hfi, length);
	}
	/* XXX: ?? */
	/*val_start = offset>>3;*/
	/*val_length = (length+7)/8;*/
	offset+=length;

	if (value_tvb)
		*value_tvb = out_tvb;

	return offset;
}




static int
dissect_h245_BIT_STRING_SIZE_1_65535(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_bit_string(tvb, offset, actx, hf_index,
                                     1, 65535, FALSE, NULL);

  return offset;
}


static const per_sequence_t EscrowData_sequence[] = {
  { &hf_h245_escrowID       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OBJECT_IDENTIFIER },
  { &hf_h245_escrowValue    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BIT_STRING_SIZE_1_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_EscrowData(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_EscrowData, EscrowData_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_SIZE_1_256_OF_EscrowData_sequence_of[1] = {
  { &hf_h245_escrowentry_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_EscrowData },
};

static int
dissect_h245_SEQUENCE_SIZE_1_256_OF_EscrowData(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_SEQUENCE_SIZE_1_256_OF_EscrowData, SEQUENCE_SIZE_1_256_OF_EscrowData_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t EncryptionSync_sequence[] = {
  { &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NonStandardParameter },
  { &hf_h245_synchFlag      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
  { &hf_h245_h235Key        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_1_65535 },
  { &hf_h245_escrowentry    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_SIZE_1_256_OF_EscrowData },
  { &hf_h245_genericParameter, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_GenericParameter },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_EncryptionSync(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 708 "../../asn1/h245/h245.cnf"
  void *priv_data = actx->private_data;
//  actx->private_data = gef_ctx_alloc(NULL, "EncryptionSync");

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_EncryptionSync, EncryptionSync_sequence);

//#line 711 "../../asn1/h245/h245.cnf"
  actx->private_data = priv_data;

  return offset;
}


static const per_sequence_t OpenLogicalChannel_sequence[] = {
  { &hf_h245_olc_fw_lcn     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OLC_fw_lcn },
  { &hf_h245_forwardLogicalChannelParameters, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_forwardLogicalChannelParameters },
  { &hf_h245_reverseLogicalChannelParameters, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OLC_reverseLogicalChannelParameters },
  { &hf_h245_separateStack  , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_NetworkAccessParameters },
  { &hf_h245_encryptionSync , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_EncryptionSync },
  { &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_GenericInformation },
  { NULL, 0, 0, NULL }
};

int
dissect_h245_OpenLogicalChannel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 130 "../../asn1/h245/h245.cnf"
  gint32 temp;

 // upcoming_olc = (!actx->pinfo->fd->flags.visited) ? se_alloc0(sizeof(olc_info_t)) : NULL;

  h223_fw_lc_num = 0;
  h223_lc_params_temp = NULL;
    printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_OpenLogicalChannel, OpenLogicalChannel_sequence);


  if(h223_fw_lc_num != 0 && h223_fw_lc_params) {
	//h223_pending_olc *pending = se_alloc(sizeof(h223_pending_olc));
	//pending->fw_channel_params = h223_fw_lc_params;
	//pending->rev_channel_params = h223_rev_lc_params;
	temp = h223_fw_lc_num;
	//if (actx->pinfo->p2p_dir > -1)
	//	g_hash_table_insert(h223_pending_olc_reqs[actx->pinfo->p2p_dir], GINT_TO_POINTER(temp), pending);
  }

  if (upcoming_olc) {
    if (fast_start) {
     // h245_setup_channels(actx->pinfo, &upcoming_olc->rev_lc);
    } else {
     // g_hash_table_insert(h245_pending_olc_reqs, 
       // se_strdup(gen_olc_key(upcoming_olc->fwd_lc_num, &actx->pinfo->dst, &actx->pinfo->src)), 
        //upcoming_olc);
    }
  }
  upcoming_olc = NULL;

  if (h245_pi != NULL)
    h245_pi->msg_type = H245_OpenLogChn;


  return offset;
}


static const value_string h245_T_cLC_source_vals[] = {
  {   0, "user" },
  {   1, "lcse" },
  { 0, NULL }
};

static const per_choice_t T_cLC_source_choice[] = {
  {   0, &hf_h245_user           , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_lcse           , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_cLC_source(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_cLC_source, T_cLC_source_choice,
                                 NULL);

  return offset;
}


static const value_string h245_Clc_reason_vals[] = {
  {   0, "unknown" },
  {   1, "reopen" },
  {   2, "reservationFailure" },
  {   3, "networkErrorCode" },
  { 0, NULL }
};

static const per_choice_t Clc_reason_choice[] = {
  {   0, &hf_h245_unknown        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_reopen         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_reservationFailure, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_networkErrorCode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_INTEGER_0_255 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Clc_reason(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Clc_reason, Clc_reason_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t CloseLogicalChannel_sequence[] = {
  { &hf_h245_forwardLogicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_cLC_source     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_cLC_source },
  { &hf_h245_clc_reason     , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_Clc_reason },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CloseLogicalChannel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CloseLogicalChannel, CloseLogicalChannel_sequence);

//#line 549 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_CloseLogChn;

  return offset;
}


static const value_string h245_T_reason_vals[] = {
  {   0, "unknown" },
  {   1, "normal" },
  {   2, "reopen" },
  {   3, "reservationFailure" },
  {   4, "networkErrorCode" },
  { 0, NULL }
};

static const per_choice_t T_reason_choice[] = {
  {   0, &hf_h245_unknown        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_normal         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_reopen         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_reservationFailure, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_networkErrorCode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_INTEGER_0_255 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_reason(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_reason, T_reason_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t RequestChannelClose_sequence[] = {
  { &hf_h245_forwardLogicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_qosCapability  , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_QOSCapability },
  { &hf_h245_reason         , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_T_reason },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestChannelClose(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestChannelClose, RequestChannelClose_sequence);

  return offset;
}



static int
dissect_h245_MultiplexTableEntryNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 66 "../../asn1/h245/h245.cnf"
  guint32 value;
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 15U, &value, FALSE);

  h223_mc = value & 0xf;


  return offset;
}



static int
dissect_h245_T_logicalChannelNum(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 93 "../../asn1/h245/h245.cnf"
  /*MultiplexElement/type/logicalChannelNumber*/
  guint32 value;
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, &value, FALSE);

  h223_me->sublist = NULL;
  h223_me->vc = value & 0xffff;


  return offset;
}


static const per_sequence_t T_subElementList_sequence_of[1] = {
  { &hf_h245_subElementList_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexElement },
};

static int
dissect_h245_T_subElementList(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 101 "../../asn1/h245/h245.cnf"
  h223_mux_element dummy_me, *parent_me = h223_me;
  memset (&dummy_me, 0, sizeof (h223_mux_element));
  h223_me = &dummy_me;
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_T_subElementList, T_subElementList_sequence_of,
                                                  2, 255, FALSE);

  parent_me->sublist = dummy_me.next;
  h223_me = parent_me;
  h223_me->vc = 0;


  return offset;
}


static const value_string h245_Me_type_vals[] = {
  {   0, "logicalChannelNumber" },
  {   1, "subElementList" },
  { 0, NULL }
};

static const per_choice_t Me_type_choice[] = {
  {   0, &hf_h245_logicalChannelNum, ASN1_NO_EXTENSIONS     , dissect_h245_T_logicalChannelNum },
  {   1, &hf_h245_subElementList , ASN1_NO_EXTENSIONS     , dissect_h245_T_subElementList },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Me_type(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Me_type, Me_type_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_ME_finiteRepeatCount(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 117 "../../asn1/h245/h245.cnf"
  guint32 value;
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 65535U, &value, FALSE);

  h223_me->repeat_count = value & 0xffff;


  return offset;
}



static int
dissect_h245_T_untilClosingFlag(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_null(tvb, offset, actx, hf_index);

//#line 111 "../../asn1/h245/h245.cnf"
  h223_me->repeat_count = 0;

  return offset;
}


static const value_string h245_ME_repeatCount_vals[] = {
  {   0, "finite" },
  {   1, "untilClosingFlag" },
  { 0, NULL }
};

static const per_choice_t ME_repeatCount_choice[] = {
  {   0, &hf_h245_me_repeatCount_finite, ASN1_NO_EXTENSIONS     , dissect_h245_ME_finiteRepeatCount },
  {   1, &hf_h245_untilClosingFlag, ASN1_NO_EXTENSIONS     , dissect_h245_T_untilClosingFlag },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ME_repeatCount(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ME_repeatCount, ME_repeatCount_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MultiplexElement_sequence[] = {
  { &hf_h245_me_type        , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_Me_type },
  { &hf_h245_me_repeatCount , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_ME_repeatCount },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexElement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 83 "../../asn1/h245/h245.cnf"
  /*MultiplexElement*/
//  h223_mux_element* me = se_alloc(sizeof(h223_mux_element));
  //h223_me->next = me;
 // h223_me = me;
  h223_me->next = NULL;

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexElement, MultiplexElement_sequence);

  return offset;
}


static const per_sequence_t T_elementList_sequence_of[1] = {
  { &hf_h245_elementList_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexElement },
};

static int
dissect_h245_T_elementList(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 72 "../../asn1/h245/h245.cnf"
  /* create a h223_mux_element to hold onto the head of the list, since
   * h223_me will track the tail */
  h223_mux_element dummy_me;
  memset (&dummy_me, 0, sizeof (h223_mux_element));
  h223_me = &dummy_me;
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_T_elementList, T_elementList_sequence_of,
                                                  1, 256, FALSE);

  /* set h223_me to the head of the list for MEDescriptor to pick up */
  h223_me = dummy_me.next;


  return offset;
}


static const per_sequence_t MultiplexEntryDescriptor_sequence[] = {
  { &hf_h245_multiplexTableEntryNumber, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexTableEntryNumber },
  { &hf_h245_elementList    , ASN1_NO_EXTENSIONS     , ASN1_OPTIONAL    , dissect_h245_T_elementList },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexEntryDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 54 "../../asn1/h245/h245.cnf"
  /*MultiplexEntryDescriptor*/
  h223_me = NULL;
  h223_mc = 0;
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexEntryDescriptor, MultiplexEntryDescriptor_sequence);

  if(h223_set_mc_handle)
//    (*h223_set_mc_handle)(actx->pinfo, h223_mc, h223_me);
 /* stuff */


  return offset;
}


static const per_sequence_t SET_SIZE_1_15_OF_MultiplexEntryDescriptor_set_of[1] = {
  { &hf_h245_multiplexEntryDescriptors_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexEntryDescriptor },
};

static int
dissect_h245_SET_SIZE_1_15_OF_MultiplexEntryDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_15_OF_MultiplexEntryDescriptor, SET_SIZE_1_15_OF_MultiplexEntryDescriptor_set_of,
                                             1, 15, FALSE);

  return offset;
}


static const per_sequence_t MultiplexEntrySend_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_multiplexEntryDescriptors, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_15_OF_MultiplexEntryDescriptor },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexEntrySend(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexEntrySend, MultiplexEntrySend_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_15_OF_MultiplexTableEntryNumber_set_of[1] = {
  { &hf_h245_multiplexTableEntryNumbers_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexTableEntryNumber },
};

static int
dissect_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber, SET_SIZE_1_15_OF_MultiplexTableEntryNumber_set_of,
                                             1, 15, FALSE);

  return offset;
}


static const per_sequence_t RequestMultiplexEntry_sequence[] = {
  { &hf_h245_entryNumbers   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestMultiplexEntry(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestMultiplexEntry, RequestMultiplexEntry_sequence);

  return offset;
}


static const value_string h245_H261Resolution_vals[] = {
  {   0, "qcif" },
  {   1, "cif" },
  { 0, NULL }
};

static const per_choice_t H261Resolution_choice[] = {
  {   0, &hf_h245_qcif           , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_cif            , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_H261Resolution(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_H261Resolution, H261Resolution_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H261VideoMode_sequence[] = {
  { &hf_h245_h261_resolution, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_H261Resolution },
  { &hf_h245_bitRate_1_19200, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_19200 },
  { &hf_h245_stillImageTransmission, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H261VideoMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H261VideoMode, H261VideoMode_sequence);

  return offset;
}


static const value_string h245_T_profileAndLevel_vals[] = {
  {   0, "profileAndLevel-SPatML" },
  {   1, "profileAndLevel-MPatLL" },
  {   2, "profileAndLevel-MPatML" },
  {   3, "profileAndLevel-MPatH-14" },
  {   4, "profileAndLevel-MPatHL" },
  {   5, "profileAndLevel-SNRatLL" },
  {   6, "profileAndLevel-SNRatML" },
  {   7, "profileAndLevel-SpatialatH-14" },
  {   8, "profileAndLevel-HPatML" },
  {   9, "profileAndLevel-HPatH-14" },
  {  10, "profileAndLevel-HPatHL" },
  { 0, NULL }
};

static const per_choice_t T_profileAndLevel_choice[] = {
  {   0, &hf_h245_profileAndLevel_SPatMLMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_profileAndLevel_MPatLLMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_profileAndLevel_MPatMLMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_profileAndLevel_MPatH_14Mode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_profileAndLevel_MPatHLMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_profileAndLevel_SNRatLLMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_profileAndLevel_SNRatMLMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   7, &hf_h245_profileAndLevel_SpatialatH_14Mode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   8, &hf_h245_profileAndLevel_HPatMLMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   9, &hf_h245_profileAndLevel_HPatH_14Mode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {  10, &hf_h245_profileAndLevel_HPatHLMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_profileAndLevel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_profileAndLevel, T_profileAndLevel_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H262VideoMode_sequence[] = {
  { &hf_h245_profileAndLevel, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_profileAndLevel },
  { &hf_h245_videoBitRate   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_1073741823 },
  { &hf_h245_vbvBufferSize  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_262143 },
  { &hf_h245_samplesPerLine , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_16383 },
  { &hf_h245_linesPerFrame  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_16383 },
  { &hf_h245_framesPerSecond, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_15 },
  { &hf_h245_luminanceSampleRate, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_4294967295 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H262VideoMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H262VideoMode, H262VideoMode_sequence);

  return offset;
}


static const value_string h245_H263Resolution_vals[] = {
  {   0, "sqcif" },
  {   1, "qcif" },
  {   2, "cif" },
  {   3, "cif4" },
  {   4, "cif16" },
  {   5, "custom" },
  { 0, NULL }
};

static const per_choice_t H263Resolution_choice[] = {
  {   0, &hf_h245_sqcif          , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_qcif           , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_cif            , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_cif4           , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_cif16          , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_custom_res     , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_H263Resolution(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_H263Resolution, H263Resolution_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H263VideoMode_sequence[] = {
  { &hf_h245_h263_resolution, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_H263Resolution },
  { &hf_h245_bitRate_1_19200, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_19200 },
  { &hf_h245_unrestrictedVector, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_arithmeticCoding, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_advancedPrediction, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_pbFrames       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_errorCompensation, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_enhancementLayerInfo, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_EnhancementLayerInfo },
  { &hf_h245_h263Options    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_H263Options },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H263VideoMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H263VideoMode, H263VideoMode_sequence);

  return offset;
}


static const per_sequence_t IS11172VideoMode_sequence[] = {
  { &hf_h245_constrainedBitstream, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_videoBitRate   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_1073741823 },
  { &hf_h245_vbvBufferSize  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_262143 },
  { &hf_h245_samplesPerLine , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_16383 },
  { &hf_h245_linesPerFrame  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_16383 },
  { &hf_h245_pictureRate    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_15 },
  { &hf_h245_luminanceSampleRate, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_4294967295 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_IS11172VideoMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_IS11172VideoMode, IS11172VideoMode_sequence);

  return offset;
}


static const value_string h245_VideoMode_vals[] = {
  {   0, "nonStandard" },
  {   1, "h261VideoMode" },
  {   2, "h262VideoMode" },
  {   3, "h263VideoMode" },
  {   4, "is11172VideoMode" },
  {   5, "genericVideoMode" },
  { 0, NULL }
};

static const per_choice_t VideoMode_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_h261VideoMode  , ASN1_EXTENSION_ROOT    , dissect_h245_H261VideoMode },
  {   2, &hf_h245_h262VideoMode  , ASN1_EXTENSION_ROOT    , dissect_h245_H262VideoMode },
  {   3, &hf_h245_h263VideoMode  , ASN1_EXTENSION_ROOT    , dissect_h245_H263VideoMode },
  {   4, &hf_h245_is11172VideoMode, ASN1_EXTENSION_ROOT    , dissect_h245_IS11172VideoMode },
  {   5, &hf_h245_genericVideoMode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericCapability },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_VideoMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 517 "../../asn1/h245/h245.cnf"
  gint32 value;

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_VideoMode, VideoMode_choice,
                                 &value);

  codec_type = val_to_str(value, h245_VideoMode_vals, "<unknown>");


  return offset;
}


static const value_string h245_Mode_g7231_vals[] = {
  {   0, "noSilenceSuppressionLowRate" },
  {   1, "noSilenceSuppressionHighRate" },
  {   2, "silenceSuppressionLowRate" },
  {   3, "silenceSuppressionHighRate" },
  { 0, NULL }
};

static const per_choice_t Mode_g7231_choice[] = {
  {   0, &hf_h245_noSilenceSuppressionLowRate, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_noSilenceSuppressionHighRate, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   2, &hf_h245_silenceSuppressionLowRate, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   3, &hf_h245_silenceSuppressionHighRate, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Mode_g7231(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Mode_g7231, Mode_g7231_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_audioLayer_vals[] = {
  {   0, "audioLayer1" },
  {   1, "audioLayer2" },
  {   2, "audioLayer3" },
  { 0, NULL }
};

static const per_choice_t T_audioLayer_choice[] = {
  {   0, &hf_h245_audioLayer1Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_audioLayer2Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   2, &hf_h245_audioLayer3Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_audioLayer(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_audioLayer, T_audioLayer_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_audioSampling_vals[] = {
  {   0, "audioSampling32k" },
  {   1, "audioSampling44k1" },
  {   2, "audioSampling48k" },
  { 0, NULL }
};

static const per_choice_t T_audioSampling_choice[] = {
  {   0, &hf_h245_audioSampling32kMode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_audioSampling44k1Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   2, &hf_h245_audioSampling48kMode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_audioSampling(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_audioSampling, T_audioSampling_choice,
                                 NULL);

  return offset;
}


static const value_string h245_IS11172_multichannelType_vals[] = {
  {   0, "singleChannel" },
  {   1, "twoChannelStereo" },
  {   2, "twoChannelDual" },
  { 0, NULL }
};

static const per_choice_t IS11172_multichannelType_choice[] = {
  {   0, &hf_h245_singleChannelMode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_twoChannelStereo, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   2, &hf_h245_twoChannelDual , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_IS11172_multichannelType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_IS11172_multichannelType, IS11172_multichannelType_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t IS11172AudioMode_sequence[] = {
  { &hf_h245_audioLayer     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_audioLayer },
  { &hf_h245_audioSampling  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_audioSampling },
  { &hf_h245_is11172multichannelType, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_IS11172_multichannelType },
  { &hf_h245_bitRate_1_448  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_448 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_IS11172AudioMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_IS11172AudioMode, IS11172AudioMode_sequence);

  return offset;
}


static const value_string h245_IS13818AudioLayer_vals[] = {
  {   0, "audioLayer1" },
  {   1, "audioLayer2" },
  {   2, "audioLayer3" },
  { 0, NULL }
};

static const per_choice_t IS13818AudioLayer_choice[] = {
  {   0, &hf_h245_audioLayer1Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_audioLayer2Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   2, &hf_h245_audioLayer3Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_IS13818AudioLayer(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_IS13818AudioLayer, IS13818AudioLayer_choice,
                                 NULL);

  return offset;
}


static const value_string h245_IS13818AudioSampling_vals[] = {
  {   0, "audioSampling16k" },
  {   1, "audioSampling22k05" },
  {   2, "audioSampling24k" },
  {   3, "audioSampling32k" },
  {   4, "audioSampling44k1" },
  {   5, "audioSampling48k" },
  { 0, NULL }
};

static const per_choice_t IS13818AudioSampling_choice[] = {
  {   0, &hf_h245_audioSampling16kMode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_audioSampling22k05Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   2, &hf_h245_audioSampling24kMode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   3, &hf_h245_audioSampling32kMode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   4, &hf_h245_audioSampling44k1Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   5, &hf_h245_audioSampling48kMode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_IS13818AudioSampling(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_IS13818AudioSampling, IS13818AudioSampling_choice,
                                 NULL);

  return offset;
}


static const value_string h245_IS13818MultichannelType_vals[] = {
  {   0, "singleChannel" },
  {   1, "twoChannelStereo" },
  {   2, "twoChannelDual" },
  {   3, "threeChannels2-1" },
  {   4, "threeChannels3-0" },
  {   5, "fourChannels2-0-2-0" },
  {   6, "fourChannels2-2" },
  {   7, "fourChannels3-1" },
  {   8, "fiveChannels3-0-2-0" },
  {   9, "fiveChannels3-2" },
  { 0, NULL }
};

static const per_choice_t IS13818MultichannelType_choice[] = {
  {   0, &hf_h245_singleChannelMode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   1, &hf_h245_twoChannelStereo, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   2, &hf_h245_twoChannelDual , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   3, &hf_h245_threeChannels2_1Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   4, &hf_h245_threeChannels3_0Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   5, &hf_h245_fourChannels2_0_2_0Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   6, &hf_h245_fourChannels2_2Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   7, &hf_h245_fourChannels3_1Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   8, &hf_h245_fiveChannels3_0_2_0Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  {   9, &hf_h245_fiveChannels3_2Mode, ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_IS13818MultichannelType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_IS13818MultichannelType, IS13818MultichannelType_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t IS13818AudioMode_sequence[] = {
  { &hf_h245_audioLayerMode , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_IS13818AudioLayer },
  { &hf_h245_audioSamplingMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_IS13818AudioSampling },
  { &hf_h245_is13818MultichannelType, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_IS13818MultichannelType },
  { &hf_h245_lowFrequencyEnhancement, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_multilingual   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_bitRate2_1_1130, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_1130 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_IS13818AudioMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_IS13818AudioMode, IS13818AudioMode_sequence);

  return offset;
}


static const per_sequence_t G7231AnnexCMode_sequence[] = {
  { &hf_h245_maxAl_sduAudioFrames, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_256 },
  { &hf_h245_silenceSuppression, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_g723AnnexCAudioMode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_G723AnnexCAudioMode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_G7231AnnexCMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_G7231AnnexCMode, G7231AnnexCMode_sequence);

  return offset;
}


static const per_sequence_t VBDMode_sequence[] = {
  { &hf_h245_vbd_type       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_AudioMode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_VBDMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_VBDMode, VBDMode_sequence);

  return offset;
}


static const value_string h245_AudioMode_vals[] = {
  {   0, "nonStandard" },
  {   1, "g711Alaw64k" },
  {   2, "g711Alaw56k" },
  {   3, "g711Ulaw64k" },
  {   4, "g711Ulaw56k" },
  {   5, "g722-64k" },
  {   6, "g722-56k" },
  {   7, "g722-48k" },
  {   8, "g728" },
  {   9, "g729" },
  {  10, "g729AnnexA" },
  {  11, "g7231" },
  {  12, "is11172AudioMode" },
  {  13, "is13818AudioMode" },
  {  14, "g729wAnnexB" },
  {  15, "g729AnnexAwAnnexB" },
  {  16, "g7231AnnexCMode" },
  {  17, "gsmFullRate" },
  {  18, "gsmHalfRate" },
  {  19, "gsmEnhancedFullRate" },
  {  20, "genericAudioMode" },
  {  21, "g729Extensions" },
  {  22, "vbd" },
  { 0, NULL }
};

static const per_choice_t AudioMode_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_g711Alaw64k_mode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_g711Alaw56k_mode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_g711Ulaw64k_mode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_g711Ulaw56k_mode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_g722_64k_mode  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_g722_56k_mode  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   7, &hf_h245_g722_48k_mode  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   8, &hf_h245_g728_mode      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   9, &hf_h245_g729_mode      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {  10, &hf_h245_g729AnnexA_mode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {  11, &hf_h245_g7231_mode     , ASN1_EXTENSION_ROOT    , dissect_h245_Mode_g7231 },
  {  12, &hf_h245_is11172AudioMode, ASN1_EXTENSION_ROOT    , dissect_h245_IS11172AudioMode },
  {  13, &hf_h245_is13818AudioMode, ASN1_EXTENSION_ROOT    , dissect_h245_IS13818AudioMode },
  {  14, &hf_h245_g729wAnnexB    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_INTEGER_1_256 },
  {  15, &hf_h245_g729AnnexAwAnnexB, ASN1_NOT_EXTENSION_ROOT, dissect_h245_INTEGER_1_256 },
  {  16, &hf_h245_g7231AnnexCMode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_G7231AnnexCMode },
  {  17, &hf_h245_gsmFullRate    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_GSMAudioCapability },
  {  18, &hf_h245_gsmHalfRate    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_GSMAudioCapability },
  {  19, &hf_h245_gsmEnhancedFullRate, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GSMAudioCapability },
  {  20, &hf_h245_genericAudioMode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericCapability },
  {  21, &hf_h245_g729Extensions , ASN1_NOT_EXTENSION_ROOT, dissect_h245_G729Extensions },
  {  22, &hf_h245_vbd_mode       , ASN1_NOT_EXTENSION_ROOT, dissect_h245_VBDMode },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_AudioMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 510 "../../asn1/h245/h245.cnf"
  gint32 value;

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_AudioMode, AudioMode_choice,
                                 &value);

  codec_type = val_to_str(value, h245_AudioMode_vals, "<unknown>");


  return offset;
}


static const per_sequence_t T38faxApp_sequence[] = {
  { &hf_h245_t38FaxProtocol , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_DataProtocolCapability },
  { &hf_h245_t38FaxProfile  , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_T38FaxProfile },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T38faxApp(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T38faxApp, T38faxApp_sequence);

  return offset;
}


static const value_string h245_DataModeApplication_vals[] = {
  {   0, "nonStandard" },
  {   1, "t120" },
  {   2, "dsm-cc" },
  {   3, "userData" },
  {   4, "t84" },
  {   5, "t434" },
  {   6, "h224" },
  {   7, "nlpid" },
  {   8, "dsvdControl" },
  {   9, "h222DataPartitioning" },
  {  10, "t30fax" },
  {  11, "t140" },
  {  12, "t38fax" },
  {  13, "genericDataMode" },
  { 0, NULL }
};

static const per_choice_t DataModeApplication_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_t120           , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   2, &hf_h245_dsm_cc         , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   3, &hf_h245_userData       , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   4, &hf_h245_t84DataProtocolCapability, ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   5, &hf_h245_t434           , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   6, &hf_h245_h224           , ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {   7, &hf_h245_nlpid          , ASN1_EXTENSION_ROOT    , dissect_h245_Nlpid },
  {   8, &hf_h245_dsvdControl    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   9, &hf_h245_h222DataPartitioning, ASN1_EXTENSION_ROOT    , dissect_h245_DataProtocolCapability },
  {  10, &hf_h245_t30fax         , ASN1_NOT_EXTENSION_ROOT, dissect_h245_DataProtocolCapability },
  {  11, &hf_h245_t140           , ASN1_NOT_EXTENSION_ROOT, dissect_h245_DataProtocolCapability },
  {  12, &hf_h245_t38faxDataProtocolCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T38faxApp },
  {  13, &hf_h245_genericDataMode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericCapability },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_DataModeApplication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 524 "../../asn1/h245/h245.cnf"
  gint32 value;

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_DataModeApplication, DataModeApplication_choice,
                                 &value);

  codec_type = val_to_str(value, h245_DataModeApplication_vals, "<unknown>");


  return offset;
}


static const per_sequence_t DataMode_sequence[] = {
  { &hf_h245_datamodeapplication, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_DataModeApplication },
  { &hf_h245_bitRate_0_4294967295, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_4294967295 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_DataMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_DataMode, DataMode_sequence);

  return offset;
}


static const value_string h245_T_mediaMode_vals[] = {
  {   0, "nonStandard" },
  {   1, "videoMode" },
  {   2, "audioMode" },
  {   3, "dataMode" },
  { 0, NULL }
};

static const per_choice_t T_mediaMode_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_videoMode      , ASN1_EXTENSION_ROOT    , dissect_h245_VideoMode },
  {   2, &hf_h245_audioMode      , ASN1_EXTENSION_ROOT    , dissect_h245_AudioMode },
  {   3, &hf_h245_dataMode       , ASN1_EXTENSION_ROOT    , dissect_h245_DataMode },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_mediaMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_mediaMode, T_mediaMode_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H235Mode_sequence[] = {
  { &hf_h245_encryptionAuthenticationAndIntegrity, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_EncryptionAuthenticationAndIntegrity },
  { &hf_h245_mediaMode      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_mediaMode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H235Mode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H235Mode, H235Mode_sequence);

  return offset;
}


static const per_sequence_t FECMode_sequence[] = {
  { &hf_h245_protectedElement, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ModeElementType },
  { &hf_h245_fecScheme      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OBJECT_IDENTIFIER },
  { &hf_h245_rfc2733Format  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_Rfc2733Format },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_FECMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_FECMode, FECMode_sequence);

  return offset;
}


static const value_string h245_Re_type_vals[] = {
  {   0, "nonStandard" },
  {   1, "videoMode" },
  {   2, "audioMode" },
  {   3, "dataMode" },
  {   4, "encryptionMode" },
  {   5, "h235Mode" },
  {   6, "fecMode" },
  { 0, NULL }
};

static const per_choice_t Re_type_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_videoMode      , ASN1_EXTENSION_ROOT    , dissect_h245_VideoMode },
  {   2, &hf_h245_audioMode      , ASN1_EXTENSION_ROOT    , dissect_h245_AudioMode },
  {   3, &hf_h245_dataMode       , ASN1_EXTENSION_ROOT    , dissect_h245_DataMode },
  {   4, &hf_h245_encryptionMode , ASN1_EXTENSION_ROOT    , dissect_h245_EncryptionMode },
  {   5, &hf_h245_h235Mode       , ASN1_EXTENSION_ROOT    , dissect_h245_H235Mode },
  {   6, &hf_h245_fecMode        , ASN1_NOT_EXTENSION_ROOT, dissect_h245_FECMode },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Re_type(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Re_type, Re_type_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t RedundancyEncodingDTModeElement_sequence[] = {
  { &hf_h245_re_type        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Re_type },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RedundancyEncodingDTModeElement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RedundancyEncodingDTModeElement, RedundancyEncodingDTModeElement_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_RedundancyEncodingDTModeElement_sequence_of[1] = {
  { &hf_h245_secondaryDTM_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_RedundancyEncodingDTModeElement },
};

static int
dissect_h245_SEQUENCE_OF_RedundancyEncodingDTModeElement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_RedundancyEncodingDTModeElement, SEQUENCE_OF_RedundancyEncodingDTModeElement_sequence_of);

  return offset;
}


static const per_sequence_t RedundancyEncodingDTMode_sequence[] = {
  { &hf_h245_redundancyEncodingMethod, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_RedundancyEncodingMethod },
  { &hf_h245_prmary_dtmode  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_RedundancyEncodingDTModeElement },
  { &hf_h245_secondaryDTM   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SEQUENCE_OF_RedundancyEncodingDTModeElement },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RedundancyEncodingDTMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RedundancyEncodingDTMode, RedundancyEncodingDTMode_sequence);

  return offset;
}


static const per_sequence_t MultiplePayloadStreamElementMode_sequence[] = {
  { &hf_h245_type           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ModeElementType },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplePayloadStreamElementMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplePayloadStreamElementMode, MultiplePayloadStreamElementMode_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_MultiplePayloadStreamElementMode_sequence_of[1] = {
  { &hf_h245_mpsmElements_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MultiplePayloadStreamElementMode },
};

static int
dissect_h245_SEQUENCE_OF_MultiplePayloadStreamElementMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_MultiplePayloadStreamElementMode, SEQUENCE_OF_MultiplePayloadStreamElementMode_sequence_of);

  return offset;
}


static const per_sequence_t MultiplePayloadStreamMode_sequence[] = {
  { &hf_h245_mpsmElements   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SEQUENCE_OF_MultiplePayloadStreamElementMode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplePayloadStreamMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplePayloadStreamMode, MultiplePayloadStreamMode_sequence);

  return offset;
}


static const value_string h245_FEC_mode_vals[] = {
  {   0, "redundancyEncoding" },
  {   1, "separateStream" },
  { 0, NULL }
};

static const per_choice_t FEC_mode_choice[] = {
  {   0, &hf_h245_redundancyEncodingFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_separateStream , ASN1_EXTENSION_ROOT    , dissect_h245_DepSeparateStream },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_FEC_mode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_FEC_mode, FEC_mode_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_rfc2733Mode_sequence[] = {
  { &hf_h245_fec_mode       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_FEC_mode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_rfc2733Mode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_rfc2733Mode, T_rfc2733Mode_sequence);

  return offset;
}


static const value_string h245_DepFECMode_vals[] = {
  {   0, "rfc2733Mode" },
  { 0, NULL }
};

static const per_choice_t DepFECMode_choice[] = {
  {   0, &hf_h245_rfc2733Mode    , ASN1_EXTENSION_ROOT    , dissect_h245_T_rfc2733Mode },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_DepFECMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_DepFECMode, DepFECMode_choice,
                                 NULL);

  return offset;
}


static const value_string h245_ModeElementType_vals[] = {
  {   0, "nonStandard" },
  {   1, "videoMode" },
  {   2, "audioMode" },
  {   3, "dataMode" },
  {   4, "encryptionMode" },
  {   5, "h235Mode" },
  {   6, "multiplexedStreamMode" },
  {   7, "redundancyEncodingDTMode" },
  {   8, "multiplePayloadStreamMode" },
  {   9, "depFecMode" },
  {  10, "fecMode" },
  { 0, NULL }
};

static const per_choice_t ModeElementType_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_videoMode      , ASN1_EXTENSION_ROOT    , dissect_h245_VideoMode },
  {   2, &hf_h245_audioMode      , ASN1_EXTENSION_ROOT    , dissect_h245_AudioMode },
  {   3, &hf_h245_dataMode       , ASN1_EXTENSION_ROOT    , dissect_h245_DataMode },
  {   4, &hf_h245_encryptionMode , ASN1_EXTENSION_ROOT    , dissect_h245_EncryptionMode },
  {   5, &hf_h245_h235Mode       , ASN1_NOT_EXTENSION_ROOT, dissect_h245_H235Mode },
  {   6, &hf_h245_multiplexedStreamMode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultiplexedStreamParameter },
  {   7, &hf_h245_redundancyEncodingDTMode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_RedundancyEncodingDTMode },
  {   8, &hf_h245_multiplePayloadStreamMode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultiplePayloadStreamMode },
  {   9, &hf_h245_depFecMode     , ASN1_NOT_EXTENSION_ROOT, dissect_h245_DepFECMode },
  {  10, &hf_h245_fecMode        , ASN1_NOT_EXTENSION_ROOT, dissect_h245_FECMode },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ModeElementType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ModeElementType, ModeElementType_choice,
                                 NULL);

  return offset;
}


static const value_string h245_AdaptationLayerType_vals[] = {
  {   0, "nonStandard" },
  {   1, "al1Framed" },
  {   2, "al1NotFramed" },
  {   3, "al2WithoutSequenceNumbers" },
  {   4, "al2WithSequenceNumbers" },
  {   5, "al3" },
  {   6, "al1M" },
  {   7, "al2M" },
  {   8, "al3M" },
  { 0, NULL }
};

static const per_choice_t AdaptationLayerType_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_al1Framed      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_al1NotFramed   , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_al2WithoutSequenceNumbers, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_al2WithSequenceNumbers, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_al3            , ASN1_EXTENSION_ROOT    , dissect_h245_Al3 },
  {   6, &hf_h245_al1M           , ASN1_NOT_EXTENSION_ROOT, dissect_h245_H223AL1MParameters },
  {   7, &hf_h245_al2M           , ASN1_NOT_EXTENSION_ROOT, dissect_h245_H223AL2MParameters },
  {   8, &hf_h245_al3M           , ASN1_NOT_EXTENSION_ROOT, dissect_h245_H223AL3MParameters },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_AdaptationLayerType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_AdaptationLayerType, AdaptationLayerType_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H223ModeParameters_sequence[] = {
  { &hf_h245_adaptationLayer, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_AdaptationLayerType },
  { &hf_h245_segmentableFlag, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H223ModeParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H223ModeParameters, H223ModeParameters_sequence);

  return offset;
}


static const value_string h245_V76ModeParameters_vals[] = {
  {   0, "suspendResumewAddress" },
  {   1, "suspendResumewoAddress" },
  { 0, NULL }
};

static const per_choice_t V76ModeParameters_choice[] = {
  {   0, &hf_h245_suspendResumewAddress, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_suspendResumewoAddress, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_V76ModeParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_V76ModeParameters, V76ModeParameters_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_secondaryEncodingMode_vals[] = {
  {   0, "nonStandard" },
  {   1, "audioData" },
  { 0, NULL }
};

static const per_choice_t T_secondaryEncodingMode_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_audioMode      , ASN1_EXTENSION_ROOT    , dissect_h245_AudioMode },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_secondaryEncodingMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_secondaryEncodingMode, T_secondaryEncodingMode_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t RedundancyEncodingMode_sequence[] = {
  { &hf_h245_redundancyEncodingMethod, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_RedundancyEncodingMethod },
  { &hf_h245_secondaryEncodingMode, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_secondaryEncodingMode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RedundancyEncodingMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RedundancyEncodingMode, RedundancyEncodingMode_sequence);

  return offset;
}


static const per_sequence_t H2250ModeParameters_sequence[] = {
  { &hf_h245_redundancyEncodingMode, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_RedundancyEncodingMode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H2250ModeParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H2250ModeParameters, H2250ModeParameters_sequence);

  return offset;
}


static const per_sequence_t MultiplexedStreamModeParameters_sequence[] = {
  { &hf_h245_logicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexedStreamModeParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexedStreamModeParameters, MultiplexedStreamModeParameters_sequence);

  return offset;
}


static const per_sequence_t ModeElement_sequence[] = {
  { &hf_h245_type           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ModeElementType },
  { &hf_h245_h223ModeParameters, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_H223ModeParameters },
  { &hf_h245_v76ModeParameters, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_V76ModeParameters },
  { &hf_h245_h2250ModeParameters, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_H2250ModeParameters },
  { &hf_h245_genericModeParameters, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_GenericCapability },
  { &hf_h245_multiplexedStreamModeParameters, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_MultiplexedStreamModeParameters },
  { &hf_h245_logicalChannelNumber, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_ModeElement(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_ModeElement, ModeElement_sequence);

  return offset;
}


static const per_sequence_t ModeDescription_set_of[1] = {
  { &hf_h245_ModeDescription_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_ModeElement },
};

static int
dissect_h245_ModeDescription(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_ModeDescription, ModeDescription_set_of,
                                             1, 256, FALSE);

  return offset;
}


static const per_sequence_t SEQUENCE_SIZE_1_256_OF_ModeDescription_sequence_of[1] = {
  { &hf_h245_requestedModes_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_ModeDescription },
};

static int
dissect_h245_SEQUENCE_SIZE_1_256_OF_ModeDescription(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_SEQUENCE_SIZE_1_256_OF_ModeDescription, SEQUENCE_SIZE_1_256_OF_ModeDescription_sequence_of,
                                                  1, 256, FALSE);

  return offset;
}


static const per_sequence_t RequestMode_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_requestedModes , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SEQUENCE_SIZE_1_256_OF_ModeDescription },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestMode, RequestMode_sequence);

  return offset;
}


static const per_sequence_t RoundTripDelayRequest_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RoundTripDelayRequest(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RoundTripDelayRequest, RoundTripDelayRequest_sequence);

  return offset;
}


static const value_string h245_Mlr_type_vals[] = {
  {   0, "systemLoop" },
  {   1, "mediaLoop" },
  {   2, "logicalChannelLoop" },
  { 0, NULL }
};

static const per_choice_t Mlr_type_choice[] = {
  {   0, &hf_h245_systemLoop     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_mediaLoop      , ASN1_EXTENSION_ROOT    , dissect_h245_LogicalChannelNumber },
  {   2, &hf_h245_logicalChannelLoop, ASN1_EXTENSION_ROOT    , dissect_h245_LogicalChannelNumber },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Mlr_type(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Mlr_type, Mlr_type_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MaintenanceLoopRequest_sequence[] = {
  { &hf_h245_mlr_type       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Mlr_type },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MaintenanceLoopRequest(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MaintenanceLoopRequest, MaintenanceLoopRequest_sequence);

  return offset;
}


static const per_sequence_t CommunicationModeRequest_sequence[] = {
  { NULL, ASN1_EXTENSION_ROOT, 0, NULL }
};

static int
dissect_h245_CommunicationModeRequest(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CommunicationModeRequest, CommunicationModeRequest_sequence);

  return offset;
}


static const per_sequence_t Criteria_sequence[] = {
  { &hf_h245_field          , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OBJECT_IDENTIFIER },
  { &hf_h245_criteriaValue  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_1_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Criteria(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Criteria, Criteria_sequence);

  return offset;
}


static const per_sequence_t CertSelectionCriteria_sequence_of[1] = {
  { &hf_h245_CertSelectionCriteria_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_Criteria },
};

static int
dissect_h245_CertSelectionCriteria(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h245_CertSelectionCriteria, CertSelectionCriteria_sequence_of,
                                                  1, 16, FALSE);

  return offset;
}


static const per_sequence_t T_requestTerminalCertificate_sequence[] = {
  { &hf_h245_terminalLabel  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_TerminalLabel },
  { &hf_h245_certSelectionCriteria, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_CertSelectionCriteria },
  { &hf_h245_sRandom        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_4294967295 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_requestTerminalCertificate(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_requestTerminalCertificate, T_requestTerminalCertificate_sequence);

  return offset;
}


static const value_string h245_RemoteMCRequest_vals[] = {
  {   0, "masterActivate" },
  {   1, "slaveActivate" },
  {   2, "deActivate" },
  { 0, NULL }
};

static const per_choice_t RemoteMCRequest_choice[] = {
  {   0, &hf_h245_masterActivate , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_slaveActivate  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_deActivate     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_RemoteMCRequest(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_RemoteMCRequest, RemoteMCRequest_choice,
                                 NULL);

  return offset;
}


static const value_string h245_ConferenceRequest_vals[] = {
  {   0, "terminalListRequest" },
  {   1, "makeMeChair" },
  {   2, "cancelMakeMeChair" },
  {   3, "dropTerminal" },
  {   4, "requestTerminalID" },
  {   5, "enterH243Password" },
  {   6, "enterH243TerminalID" },
  {   7, "enterH243ConferenceID" },
  {   8, "enterExtensionAddress" },
  {   9, "requestChairTokenOwner" },
  {  10, "requestTerminalCertificate" },
  {  11, "broadcastMyLogicalChannel" },
  {  12, "makeTerminalBroadcaster" },
  {  13, "sendThisSource" },
  {  14, "requestAllTerminalIDs" },
  {  15, "remoteMCRequest" },
  { 0, NULL }
};

static const per_choice_t ConferenceRequest_choice[] = {
  {   0, &hf_h245_terminalListRequest, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_makeMeChair    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_cancelMakeMeChair, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_dropTerminal   , ASN1_EXTENSION_ROOT    , dissect_h245_TerminalLabel },
  {   4, &hf_h245_requestTerminalID, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalLabel },
  {   5, &hf_h245_enterH243Password, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_enterH243TerminalID, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   7, &hf_h245_enterH243ConferenceID, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   8, &hf_h245_enterExtensionAddress, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   9, &hf_h245_requestChairTokenOwner, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  10, &hf_h245_requestTerminalCertificate, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_requestTerminalCertificate },
  {  11, &hf_h245_broadcastMyLogicalChannel, ASN1_NOT_EXTENSION_ROOT, dissect_h245_LogicalChannelNumber },
  {  12, &hf_h245_makeTerminalBroadcaster, ASN1_NOT_EXTENSION_ROOT, dissect_h245_TerminalLabel },
  {  13, &hf_h245_sendThisSource , ASN1_NOT_EXTENSION_ROOT, dissect_h245_TerminalLabel },
  {  14, &hf_h245_requestAllTerminalIDs, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  15, &hf_h245_remoteMCRequest, ASN1_NOT_EXTENSION_ROOT, dissect_h245_RemoteMCRequest },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ConferenceRequest(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ConferenceRequest, ConferenceRequest_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t CallInformationReq_sequence[] = {
  { &hf_h245_maxNumberOfAdditionalConnections, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CallInformationReq(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CallInformationReq, CallInformationReq_sequence);

  return offset;
}



static int
dissect_h245_NumericString_SIZE_0_40(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_NumericString(tvb, offset, actx, hf_index,
                                          0, 40, FALSE);

  return offset;
}



static int
dissect_h245_IA5String_SIZE_1_40(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_IA5String(tvb, offset, actx, hf_index,
                                          1, 40, FALSE);

  return offset;
}


static const value_string h245_DialingInformationNetworkType_vals[] = {
  {   0, "nonStandard" },
  {   1, "n-isdn" },
  {   2, "gstn" },
  {   3, "mobile" },
  { 0, NULL }
};

static const per_choice_t DialingInformationNetworkType_choice[] = {
  {   0, &hf_h245_nonStandardMsg , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardMessage },
  {   1, &hf_h245_n_isdn         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_gstn           , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_mobile         , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_DialingInformationNetworkType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_DialingInformationNetworkType, DialingInformationNetworkType_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t SET_SIZE_1_255_OF_DialingInformationNetworkType_set_of[1] = {
  { &hf_h245_networkType_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_DialingInformationNetworkType },
};

static int
dissect_h245_SET_SIZE_1_255_OF_DialingInformationNetworkType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_255_OF_DialingInformationNetworkType, SET_SIZE_1_255_OF_DialingInformationNetworkType_set_of,
                                             1, 255, FALSE);

  return offset;
}


static const per_sequence_t DialingInformationNumber_sequence[] = {
  { &hf_h245_networkAddressNum, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_NumericString_SIZE_0_40 },
  { &hf_h245_subAddress     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_IA5String_SIZE_1_40 },
  { &hf_h245_networkType    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_255_OF_DialingInformationNetworkType },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_DialingInformationNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_DialingInformationNumber, DialingInformationNumber_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_65535_OF_DialingInformationNumber_set_of[1] = {
  { &hf_h245_differential_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_DialingInformationNumber },
};

static int
dissect_h245_SET_SIZE_1_65535_OF_DialingInformationNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_65535_OF_DialingInformationNumber, SET_SIZE_1_65535_OF_DialingInformationNumber_set_of,
                                             1, 65535, FALSE);

  return offset;
}


static const value_string h245_DialingInformation_vals[] = {
  {   0, "nonStandard" },
  {   1, "differential" },
  {   2, "infoNotAvailable" },
  { 0, NULL }
};

static const per_choice_t DialingInformation_choice[] = {
  {   0, &hf_h245_nonStandardMsg , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardMessage },
  {   1, &hf_h245_differential   , ASN1_EXTENSION_ROOT    , dissect_h245_SET_SIZE_1_65535_OF_DialingInformationNumber },
  {   2, &hf_h245_infoNotAvailable, ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_1_65535 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_DialingInformation(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_DialingInformation, DialingInformation_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t AddConnectionReq_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_dialingInformation, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_DialingInformation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_AddConnectionReq(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_AddConnectionReq, AddConnectionReq_sequence);

  return offset;
}


static const per_sequence_t ConnectionIdentifier_sequence[] = {
  { &hf_h245_channelTag     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_4294967295 },
  { &hf_h245_sequenceNum    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_4294967295 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_ConnectionIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_ConnectionIdentifier, ConnectionIdentifier_sequence);

  return offset;
}


static const per_sequence_t RemoveConnectionReq_sequence[] = {
  { &hf_h245_connectionIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ConnectionIdentifier },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RemoveConnectionReq(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RemoveConnectionReq, RemoveConnectionReq_sequence);

  return offset;
}


static const value_string h245_T_requestType_vals[] = {
  {   0, "currentIntervalInformation" },
  {   1, "requestedInterval" },
  { 0, NULL }
};

static const per_choice_t T_requestType_choice[] = {
  {   0, &hf_h245_currentIntervalInformation, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_requestedInterval, ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_0_65535 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_requestType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_requestType, T_requestType_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MaximumHeaderIntervalReq_sequence[] = {
  { &hf_h245_requestType    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_requestType },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MaximumHeaderIntervalReq(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MaximumHeaderIntervalReq, MaximumHeaderIntervalReq_sequence);

  return offset;
}


static const value_string h245_MultilinkRequest_vals[] = {
  {   0, "nonStandard" },
  {   1, "callInformation" },
  {   2, "addConnection" },
  {   3, "removeConnection" },
  {   4, "maximumHeaderInterval" },
  { 0, NULL }
};

static const per_choice_t MultilinkRequest_choice[] = {
  {   0, &hf_h245_nonStandardMsg , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardMessage },
  {   1, &hf_h245_callInformationReq, ASN1_EXTENSION_ROOT    , dissect_h245_CallInformationReq },
  {   2, &hf_h245_addConnectionReq, ASN1_EXTENSION_ROOT    , dissect_h245_AddConnectionReq },
  {   3, &hf_h245_removeConnectionReq, ASN1_EXTENSION_ROOT    , dissect_h245_RemoveConnectionReq },
  {   4, &hf_h245_maximumHeaderIntervalReq, ASN1_EXTENSION_ROOT    , dissect_h245_MaximumHeaderIntervalReq },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MultilinkRequest(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MultilinkRequest, MultilinkRequest_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_MaximumBitRate(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 4294967295U, NULL, FALSE);

  return offset;
}


static const per_sequence_t LogicalChannelRateRequest_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_logicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_maximumBitRate , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MaximumBitRate },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_LogicalChannelRateRequest(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_RequestMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_LogicalChannelRateRequest, LogicalChannelRateRequest_sequence);

  return offset;
}


static const per_choice_t RequestMessage_choice[] = {
  { RequestMessage_nonStandard, &hf_h245_nonStandardMsg , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardMessage },
  { RequestMessage_masterSlaveDetermination, &hf_h245_masterSlaveDetermination, ASN1_EXTENSION_ROOT    , dissect_h245_MasterSlaveDetermination },
  { RequestMessage_terminalCapabilitySet, &hf_h245_terminalCapabilitySet, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalCapabilitySet },
  { RequestMessage_openLogicalChannel, &hf_h245_openLogicalChannel, ASN1_EXTENSION_ROOT    , dissect_h245_OpenLogicalChannel },
  { RequestMessage_closeLogicalChannel, &hf_h245_closeLogicalChannel, ASN1_EXTENSION_ROOT    , dissect_h245_CloseLogicalChannel },
  { RequestMessage_requestChannelClose, &hf_h245_requestChannelClose, ASN1_EXTENSION_ROOT    , dissect_h245_RequestChannelClose },
  { RequestMessage_multiplexEntrySend, &hf_h245_multiplexEntrySend, ASN1_EXTENSION_ROOT    , dissect_h245_MultiplexEntrySend },
  { RequestMessage_requestMultiplexEntry, &hf_h245_requestMultiplexEntry, ASN1_EXTENSION_ROOT    , dissect_h245_RequestMultiplexEntry },
  { RequestMessage_requestMode, &hf_h245_requestMode    , ASN1_EXTENSION_ROOT    , dissect_h245_RequestMode },
  { RequestMessage_roundTripDelayRequest, &hf_h245_roundTripDelayRequest, ASN1_EXTENSION_ROOT    , dissect_h245_RoundTripDelayRequest },
  { RequestMessage_maintenanceLoopRequest, &hf_h245_maintenanceLoopRequest, ASN1_EXTENSION_ROOT    , dissect_h245_MaintenanceLoopRequest },
  { RequestMessage_communicationModeRequest, &hf_h245_communicationModeRequest, ASN1_NOT_EXTENSION_ROOT, dissect_h245_CommunicationModeRequest },
  { RequestMessage_conferenceRequest, &hf_h245_conferenceRequest, ASN1_NOT_EXTENSION_ROOT, dissect_h245_ConferenceRequest },
  { RequestMessage_multilinkRequest, &hf_h245_multilinkRequest, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultilinkRequest },
  { RequestMessage_logicalChannelRateRequest, &hf_h245_logicalChannelRateRequest, ASN1_NOT_EXTENSION_ROOT, dissect_h245_LogicalChannelRateRequest },
  { RequestMessage_genericRequest, &hf_h245_genericRequest , ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericMessage },
  { 0, NULL, 0, NULL }
};
static const value_string h245_MultimediaSystemControlMessage_vals[] = {
  {   0, "request" },
  {   1, "response" },
  {   2, "command" },
  {   3, "indication" },
  { 0, NULL }
};

static int
dissect_h245_RequestMessage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 368 "../../asn1/h245/h245.cnf"
  gint32 value;
  printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_MultimediaSystemControlMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s :", val_to_str(	h_245_message_value.msg_value, h245_MultimediaSystemControlMessage_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_RequestMessage, RequestMessage_choice,
                                 &value);

	if ( h245_shorttypes == TRUE )
	    {
	        	//col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, "%s ",
				printf("%s\n ",val_to_str(value, h245_RequestMessage_short_vals, "<unknown>"));
		}
		else
		{
	        	//col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, "%s ",
				//printf("%s\n ",val_to_str(value, h245_RequestMessage_vals, "<unknown>"));
		}

	if (( codec_type != NULL ) && ( value == RequestMessage_openLogicalChannel) ){
		//col_append_fstr(actx->pinfo->cinfo, COL_INFO, "(%s) ",
		printf("%s\n ",codec_type );
	}

       // col_set_fence(actx->pinfo->cinfo,COL_INFO);

    /* Add to packet info */
	if (h245_pi == NULL)
		return offset;

    if (strlen(h245_pi->frame_label) == 0)
    {
//      g_snprintf(h245_pi->frame_label, 50, "%s", val_to_str(value, h245_RequestMessage_short_vals, "UKN"));

      /* if it is OLC or RM*/
      if ((codec_type != NULL) && (( value == RequestMessage_openLogicalChannel) || ( value == RequestMessage_requestMode)))
      {
       // g_strlcat(h245_pi->frame_label, " (", 50);
       // g_strlcat(h245_pi->frame_label, codec_type, 50);
       // g_strlcat(h245_pi->frame_label, ")", 50);
      }
    }
   // g_strlcat(h245_pi->comment, val_to_str(value, h245_RequestMessage_vals, "<unknown>"), 50);


  return offset;
}



static const per_choice_t T_decision_choice[] = {
  {   0, &hf_h245_master         , ASN1_NO_EXTENSIONS     , dissect_h245_NULL_master  },
  {   1, &hf_h245_slave          , ASN1_NO_EXTENSIONS     , dissect_h245_NULL_slave },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_decision(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("decision:");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_decision, T_decision_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MasterSlaveDeterminationAck_sequence[] = {
  { &hf_h245_decision       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_decision },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MasterSlaveDeterminationAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MasterSlaveDeterminationAck, MasterSlaveDeterminationAck_sequence);

//#line 531 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_MastSlvDetAck;

  return offset;
}


static const value_string h245_MasterSlaveDeterminationRejectCause_vals[] = {
  {   0, "identicalNumbers" },
  { 0, NULL }
};

static const per_choice_t MasterSlaveDeterminationRejectCause_choice[] = {
  {   0, &hf_h245_identicalNumbers, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MasterSlaveDeterminationRejectCause(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MasterSlaveDeterminationRejectCause, MasterSlaveDeterminationRejectCause_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MasterSlaveDeterminationReject_sequence[] = {
  { &hf_h245_msd_rej_cause  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MasterSlaveDeterminationRejectCause },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MasterSlaveDeterminationReject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MasterSlaveDeterminationReject, MasterSlaveDeterminationReject_sequence);

//#line 537 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_MastSlvDetRjc;

  return offset;
}


static const per_sequence_t TerminalCapabilitySetAck_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_GenericInformation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_TerminalCapabilitySetAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_TerminalCapabilitySetAck, TerminalCapabilitySetAck_sequence);

//#line 567 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_TermCapSetAck;

  return offset;
}


static const value_string h245_T_tableEntryCapacityExceeded_vals[] = {
  {   0, "highestEntryNumberProcessed" },
  {   1, "noneProcessed" },
  { 0, NULL }
};

static const per_choice_t T_tableEntryCapacityExceeded_choice[] = {
  {   0, &hf_h245_highestEntryNumberProcessed, ASN1_NO_EXTENSIONS     , dissect_h245_CapabilityTableEntryNumber },
  {   1, &hf_h245_noneProcessed  , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_tableEntryCapacityExceeded(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_tableEntryCapacityExceeded, T_tableEntryCapacityExceeded_choice,
                                 NULL);

  return offset;
}


static const value_string h245_TerminalCapabilitySetRejectCause_vals[] = {
  {   0, "unspecified" },
  {   1, "undefinedTableEntryUsed" },
  {   2, "descriptorCapacityExceeded" },
  {   3, "tableEntryCapacityExceeded" },
  { 0, NULL }
};

static const per_choice_t TerminalCapabilitySetRejectCause_choice[] = {
  {   0, &hf_h245_unspecified    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_undefinedTableEntryUsed, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_descriptorCapacityExceeded, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_tableEntryCapacityExceeded, ASN1_EXTENSION_ROOT    , dissect_h245_T_tableEntryCapacityExceeded },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_TerminalCapabilitySetRejectCause(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_TerminalCapabilitySetRejectCause, TerminalCapabilitySetRejectCause_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t TerminalCapabilitySetReject_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_tcs_rej_cause  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalCapabilitySetRejectCause },
  { &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_GenericInformation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_TerminalCapabilitySetReject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_TerminalCapabilitySetReject, TerminalCapabilitySetReject_sequence);

//#line 579 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_TermCapSetRjc;

  return offset;
}



static int
dissect_h245_OLC_ack_fw_lcn(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("forwardLogicalChannelNumber:");
  offset = dissect_h245_LogicalChannelNumber(tvb, offset, actx, hf_index);

//#line 275 "../../asn1/h245/h245.cnf"
  if (upcoming_olc) upcoming_olc->fwd_lc_num = h245_lc_temp;
  h223_fw_lc_num = h245_lc_temp;

  return offset;
}



static int
dissect_h245_T_reverseLogicalChannelNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_h245_LogicalChannelNumber(tvb, offset, actx, hf_index);

//#line 289 "../../asn1/h245/h245.cnf"
  h223_rev_lc_num = h245_lc_temp;

  return offset;
}


static const value_string h245_T_olc_ack_multiplexParameters_vals[] = {
  {   0, "h222LogicalChannelParameters" },
  {   1, "h2250LogicalChannelParameters" },
  { 0, NULL }
};

static const per_choice_t T_olc_ack_multiplexParameters_choice[] = {
  {   0, &hf_h245_h222LogicalChannelParameters, ASN1_EXTENSION_ROOT    , dissect_h245_H222LogicalChannelParameters },
  {   1, &hf_h245_h2250LogicalChannelParameters, ASN1_NOT_EXTENSION_ROOT, dissect_h245_H2250LogicalChannelParameters },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_olc_ack_multiplexParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_olc_ack_multiplexParameters, T_olc_ack_multiplexParameters_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t OLC_ack_reverseLogicalChannelParameters_sequence[] = {
  { &hf_h245_reverseLogicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_reverseLogicalChannelNumber },
  { &hf_h245_portNumber     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_65535 },
  { &hf_h245_olc_ack_multiplexParameters, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_olc_ack_multiplexParameters },
  { &hf_h245_replacementFor , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_OLC_ack_reverseLogicalChannelParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_OLC_ack_reverseLogicalChannelParameters, OLC_ack_reverseLogicalChannelParameters_sequence);

  return offset;
}



static int
dissect_h245_Ack_mediaChannel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 891 "../../asn1/h245/h245.cnf"
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = &upcoming_channel->media_addr;
  printf("mediaChannel:");
  offset = dissect_h245_TransportAddress(tvb, offset, actx, hf_index);

//#line 895 "../../asn1/h245/h245.cnf"
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = NULL;

  return offset;
}



static int
dissect_h245_Ack_mediaControlChannel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 909 "../../asn1/h245/h245.cnf"
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = &upcoming_channel->media_control_addr;
   printf("mediaControlChannel:");
  offset = dissect_h245_TransportAddress(tvb, offset, actx, hf_index);

//#line 913 "../../asn1/h245/h245.cnf"
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = NULL;

  return offset;
}


static const per_sequence_t H2250LogicalChannelAckParameters_sequence[] = {
  { &hf_h245_nonStandardParams, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_NonStandardParameter },
  { &hf_h245_sessionID      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_255 },
  { &hf_h245_ack_mediaChannel, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_Ack_mediaChannel },
  { &hf_h245_ack_mediaControlChannel, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_Ack_mediaControlChannel },
  { &hf_h245_dynamicRTPPayloadType, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_96_127 },
  { &hf_h245_flowControlToZero, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN_flowControlToZero },
  { &hf_h245_portNumber     , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};
static const value_string h245_T_forwardMultiplexAckParameters_vals[] = {
  {   0, "h2250LogicalChannelAckParameters" },
  { 0, NULL }
};
static int
dissect_h245_H2250LogicalChannelAckParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_T_forwardMultiplexAckParameters_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_T_forwardMultiplexAckParameters_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H2250LogicalChannelAckParameters, H2250LogicalChannelAckParameters_sequence);

  return offset;
}




static const per_choice_t T_forwardMultiplexAckParameters_choice[] = {
  {   0, &hf_h245_h2250LogicalChannelAckParameters, ASN1_EXTENSION_ROOT    , dissect_h245_H2250LogicalChannelAckParameters },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_forwardMultiplexAckParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 280 "../../asn1/h245/h245.cnf"

  upcoming_channel = (upcoming_olc) ? &upcoming_olc->fwd_lc : NULL;
  printf("forwardMultiplexAckParameters:");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_forwardMultiplexAckParameters, T_forwardMultiplexAckParameters_choice,
                                 NULL);

	
  upcoming_channel = NULL;


  return offset;
}


static const per_sequence_t OpenLogicalChannelAck_sequence[] = {
  { &hf_h245_olc_ack_fw_lcn , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OLC_ack_fw_lcn },
  { &hf_h245_olc_ack_reverseLogicalChannelParameters, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OLC_ack_reverseLogicalChannelParameters },
  { &hf_h245_separateStack  , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_NetworkAccessParameters },
  { &hf_h245_forwardMultiplexAckParameters, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_T_forwardMultiplexAckParameters },
  { &hf_h245_encryptionSync , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_EncryptionSync },
  { &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_GenericInformation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_OpenLogicalChannelAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {

//#line 219 "../../asn1/h245/h245.cnf"
  guint32 temp;
  int p2p_dir;
  h223_pending_olc *pend;
  const gchar *olc_key;
  olc_info_t *olc_req;

//  upcoming_olc = (!actx->pinfo->fd->flags.visited) ? ep_alloc0(sizeof(olc_info_t)) : NULL;

  h223_fw_lc_num = 0;
  h223_rev_lc_num = 0;
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_OpenLogicalChannelAck, OpenLogicalChannelAck_sequence);


  temp = h223_fw_lc_num;
 // p2p_dir = actx->pinfo->p2p_dir;
  
 // if(actx->pinfo->p2p_dir == P2P_DIR_SENT)
	//actx->pinfo->p2p_dir = P2P_DIR_RECV;
 // else
	//actx->pinfo->p2p_dir = P2P_DIR_SENT;
 // pend = g_hash_table_lookup( h223_pending_olc_reqs[actx->pinfo->p2p_dir], GINT_TO_POINTER(temp) );
 // if (pend) {
	//DISSECTOR_ASSERT( ( h223_rev_lc_num &&  pend->rev_channel_params)
	//			   || (!h223_rev_lc_num && !pend->rev_channel_params) );
	//if(h223_add_lc_handle) {
	//  (*h223_add_lc_handle)( actx->pinfo, h223_fw_lc_num, pend->fw_channel_params );
	//  if(h223_rev_lc_num)
	//	(*h223_add_lc_handle)( actx->pinfo, h223_rev_lc_num, pend->rev_channel_params );
	//}
 // } else {
	///* we missed the OpenLogicalChannel packet */
 // }
 // actx->pinfo->p2p_dir = p2p_dir;

  //if (upcoming_olc) {
  //  olc_key = gen_olc_key(upcoming_olc->fwd_lc_num, &actx->pinfo->src, &actx->pinfo->dst);
  //  olc_req = g_hash_table_lookup(h245_pending_olc_reqs, olc_key);
  //  if (olc_req) {
  //    update_unicast_addr(&olc_req->fwd_lc.media_addr, &upcoming_olc->fwd_lc.media_addr);
  //    update_unicast_addr(&olc_req->fwd_lc.media_control_addr, &upcoming_olc->fwd_lc.media_control_addr);
  //    update_unicast_addr(&olc_req->rev_lc.media_addr, &upcoming_olc->rev_lc.media_addr);
  //    update_unicast_addr(&olc_req->rev_lc.media_control_addr, &upcoming_olc->rev_lc.media_control_addr);
  //    h245_setup_channels(actx->pinfo, &olc_req->fwd_lc);
  //    h245_setup_channels(actx->pinfo, &olc_req->rev_lc);
  //    g_hash_table_remove(h245_pending_olc_reqs, olc_key);
  //  } else {
  //    h245_setup_channels(actx->pinfo, &upcoming_olc->fwd_lc);
  //  }
  //}
  upcoming_olc = NULL;

  if (h245_pi != NULL)
	h245_pi->msg_type = H245_OpenLogChnAck;


  return offset;
}


static const value_string h245_OpenLogicalChannelRejectCause_vals[] = {
  {   0, "unspecified" },
  {   1, "unsuitableReverseParameters" },
  {   2, "dataTypeNotSupported" },
  {   3, "dataTypeNotAvailable" },
  {   4, "unknownDataType" },
  {   5, "dataTypeALCombinationNotSupported" },
  {   6, "multicastChannelNotAllowed" },
  {   7, "insufficientBandwidth" },
  {   8, "separateStackEstablishmentFailed" },
  {   9, "invalidSessionID" },
  {  10, "masterSlaveConflict" },
  {  11, "waitForCommunicationMode" },
  {  12, "invalidDependentChannel" },
  {  13, "replacementForRejected" },
  {  14, "securityDenied" },
  {  15, "qoSControlNotSupported" },
  { 0, NULL }
};

static const per_choice_t OpenLogicalChannelRejectCause_choice[] = {
  {   0, &hf_h245_unspecified    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_unsuitableReverseParameters, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_dataTypeNotSupported, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_dataTypeNotAvailable, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_unknownDataType, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_dataTypeALCombinationNotSupported, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_multicastChannelNotAllowed, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   7, &hf_h245_insufficientBandwidth, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   8, &hf_h245_separateStackEstablishmentFailed, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   9, &hf_h245_invalidSessionID, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  10, &hf_h245_masterSlaveConflict, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  11, &hf_h245_waitForCommunicationMode, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  12, &hf_h245_invalidDependentChannel, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  13, &hf_h245_replacementForRejected, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  14, &hf_h245_securityDenied , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  15, &hf_h245_qoSControlNotSupported, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_OpenLogicalChannelRejectCause(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_OpenLogicalChannelRejectCause, OpenLogicalChannelRejectCause_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t OpenLogicalChannelReject_sequence[] = {
  { &hf_h245_forwardLogicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_olc_rej_cause  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OpenLogicalChannelRejectCause },
  { &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_GenericInformation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_OpenLogicalChannelReject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_OpenLogicalChannelReject, OpenLogicalChannelReject_sequence);

//#line 543 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_OpenLogChnRjc;

  return offset;
}


static const per_sequence_t CloseLogicalChannelAck_sequence[] = {
  { &hf_h245_forwardLogicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CloseLogicalChannelAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CloseLogicalChannelAck, CloseLogicalChannelAck_sequence);

//#line 555 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_CloseLogChnAck;

  return offset;
}


static const per_sequence_t RequestChannelCloseAck_sequence[] = {
  { &hf_h245_forwardLogicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestChannelCloseAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestChannelCloseAck, RequestChannelCloseAck_sequence);

  return offset;
}


static const value_string h245_RequestChannelCloseRejectCause_vals[] = {
  {   0, "unspecified" },
  { 0, NULL }
};

static const per_choice_t RequestChannelCloseRejectCause_choice[] = {
  {   0, &hf_h245_unspecified    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_RequestChannelCloseRejectCause(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_RequestChannelCloseRejectCause, RequestChannelCloseRejectCause_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t RequestChannelCloseReject_sequence[] = {
  { &hf_h245_forwardLogicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_req_chan_clos_rej_cause, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_RequestChannelCloseRejectCause },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestChannelCloseReject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestChannelCloseReject, RequestChannelCloseReject_sequence);

  return offset;
}


static const per_sequence_t MultiplexEntrySendAck_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_multiplexTableEntryNumbers, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexEntrySendAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexEntrySendAck, MultiplexEntrySendAck_sequence);

  return offset;
}


static const value_string h245_MultiplexEntryRejectionDescriptionsCause_vals[] = {
  {   0, "unspecifiedCause" },
  {   1, "descriptorTooComplex" },
  { 0, NULL }
};

static const per_choice_t MultiplexEntryRejectionDescriptionsCause_choice[] = {
  {   0, &hf_h245_unspecifiedCause, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_descriptorTooComplex, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MultiplexEntryRejectionDescriptionsCause(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MultiplexEntryRejectionDescriptionsCause, MultiplexEntryRejectionDescriptionsCause_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MultiplexEntryRejectionDescriptions_sequence[] = {
  { &hf_h245_multiplexTableEntryNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexTableEntryNumber },
  { &hf_h245_mux_rej_cause  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexEntryRejectionDescriptionsCause },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexEntryRejectionDescriptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexEntryRejectionDescriptions, MultiplexEntryRejectionDescriptions_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions_set_of[1] = {
  { &hf_h245_sendRejectionDescriptions_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexEntryRejectionDescriptions },
};

static int
dissect_h245_SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions, SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions_set_of,
                                             1, 15, FALSE);

  return offset;
}


static const per_sequence_t MultiplexEntrySendReject_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_sendRejectionDescriptions, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_15_OF_MultiplexEntryRejectionDescriptions },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexEntrySendReject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexEntrySendReject, MultiplexEntrySendReject_sequence);

  return offset;
}


static const per_sequence_t RequestMultiplexEntryAck_sequence[] = {
  { &hf_h245_entryNumbers   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestMultiplexEntryAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestMultiplexEntryAck, RequestMultiplexEntryAck_sequence);

  return offset;
}


static const value_string h245_RequestMultiplexEntryRejectionDescriptionsCause_vals[] = {
  {   0, "unspecifiedCause" },
  { 0, NULL }
};

static const per_choice_t RequestMultiplexEntryRejectionDescriptionsCause_choice[] = {
  {   0, &hf_h245_unspecifiedCause, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_RequestMultiplexEntryRejectionDescriptionsCause(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_RequestMultiplexEntryRejectionDescriptionsCause, RequestMultiplexEntryRejectionDescriptionsCause_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t RequestMultiplexEntryRejectionDescriptions_sequence[] = {
  { &hf_h245_multiplexTableEntryNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MultiplexTableEntryNumber },
  { &hf_h245_req_mux_rej_cause, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_RequestMultiplexEntryRejectionDescriptionsCause },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestMultiplexEntryRejectionDescriptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestMultiplexEntryRejectionDescriptions, RequestMultiplexEntryRejectionDescriptions_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_15_OF_RequestMultiplexEntryRejectionDescriptions_set_of[1] = {
  { &hf_h245_rejectionDescriptions_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_RequestMultiplexEntryRejectionDescriptions },
};

static int
dissect_h245_SET_SIZE_1_15_OF_RequestMultiplexEntryRejectionDescriptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_15_OF_RequestMultiplexEntryRejectionDescriptions, SET_SIZE_1_15_OF_RequestMultiplexEntryRejectionDescriptions_set_of,
                                             1, 15, FALSE);

  return offset;
}


static const per_sequence_t RequestMultiplexEntryReject_sequence[] = {
  { &hf_h245_entryNumbers   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber },
  { &hf_h245_rejectionDescriptions, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_15_OF_RequestMultiplexEntryRejectionDescriptions },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestMultiplexEntryReject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestMultiplexEntryReject, RequestMultiplexEntryReject_sequence);

  return offset;
}


static const value_string h245_Req_mode_ack_response_vals[] = {
  {   0, "willTransmitMostPreferredMode" },
  {   1, "willTransmitLessPreferredMode" },
  { 0, NULL }
};

static const per_choice_t Req_mode_ack_response_choice[] = {
  {   0, &hf_h245_willTransmitMostPreferredMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_willTransmitLessPreferredMode, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Req_mode_ack_response(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Req_mode_ack_response, Req_mode_ack_response_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t RequestModeAck_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_req_mode_ack_response, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Req_mode_ack_response },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestModeAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestModeAck, RequestModeAck_sequence);

  return offset;
}


static const value_string h245_RequestModeRejectCause_vals[] = {
  {   0, "modeUnavailable" },
  {   1, "multipointConstraint" },
  {   2, "requestDenied" },
  { 0, NULL }
};

static const per_choice_t RequestModeRejectCause_choice[] = {
  {   0, &hf_h245_modeUnavailable, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_multipointConstraint, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_requestDenied  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_RequestModeRejectCause(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_RequestModeRejectCause, RequestModeRejectCause_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t RequestModeReject_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_req_rej_cause  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_RequestModeRejectCause },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestModeReject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestModeReject, RequestModeReject_sequence);

  return offset;
}


static const per_sequence_t RoundTripDelayResponse_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RoundTripDelayResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RoundTripDelayResponse, RoundTripDelayResponse_sequence);

  return offset;
}


static const value_string h245_Mla_type_vals[] = {
  {   0, "systemLoop" },
  {   1, "mediaLoop" },
  {   2, "logicalChannelLoop" },
  { 0, NULL }
};

static const per_choice_t Mla_type_choice[] = {
  {   0, &hf_h245_systemLoop     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_mediaLoop      , ASN1_EXTENSION_ROOT    , dissect_h245_LogicalChannelNumber },
  {   2, &hf_h245_logicalChannelLoop, ASN1_EXTENSION_ROOT    , dissect_h245_LogicalChannelNumber },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Mla_type(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Mla_type, Mla_type_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MaintenanceLoopAck_sequence[] = {
  { &hf_h245_mla_type       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Mla_type },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MaintenanceLoopAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MaintenanceLoopAck, MaintenanceLoopAck_sequence);

  return offset;
}


static const value_string h245_Mlrej_type_vals[] = {
  {   0, "systemLoop" },
  {   1, "mediaLoop" },
  {   2, "logicalChannelLoop" },
  { 0, NULL }
};

static const per_choice_t Mlrej_type_choice[] = {
  {   0, &hf_h245_systemLoop     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_mediaLoop      , ASN1_EXTENSION_ROOT    , dissect_h245_LogicalChannelNumber },
  {   2, &hf_h245_logicalChannelLoop, ASN1_EXTENSION_ROOT    , dissect_h245_LogicalChannelNumber },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Mlrej_type(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Mlrej_type, Mlrej_type_choice,
                                 NULL);

  return offset;
}


static const value_string h245_MaintenanceLoopRejectCause_vals[] = {
  {   0, "canNotPerformLoop" },
  { 0, NULL }
};

static const per_choice_t MaintenanceLoopRejectCause_choice[] = {
  {   0, &hf_h245_canNotPerformLoop, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MaintenanceLoopRejectCause(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MaintenanceLoopRejectCause, MaintenanceLoopRejectCause_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MaintenanceLoopReject_sequence[] = {
  { &hf_h245_mlrej_type     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Mlrej_type },
  { &hf_h245_maintloop_rej_cause, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MaintenanceLoopRejectCause },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MaintenanceLoopReject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MaintenanceLoopReject, MaintenanceLoopReject_sequence);

  return offset;
}

guint32
dissect_per_BMPString(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, int min_len, int max_len, gboolean has_extension )
{
	guint32 length;
	static char *str;

	/* xx.x if the length is 0 bytes there will be no encoding */
	if(max_len==0){
		return offset;
	}


	if (min_len == NO_BOUND) {
		min_len = 0;
	}


	/* xx.x */
	length=max_len;
	if(min_len!=max_len){
		offset=dissect_per_constrained_integer(tvb, offset, actx,
			 hf_per_octet_string_length, min_len, max_len,
			&length, FALSE);
		//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
	}


	/* align to byte boundary */
	//BYTE_ALIGN_OFFSET(offset);

	if(length>=1024){
		//PER_NOT_DECODED_YET("BMPString too long");
		length=1024;
	}

	//str = tvb_get_ephemeral_unicode_string(tvb, offset>>3, length*2, ENC_BIG_ENDIAN);

	//proto_tree_add_string( hf_index, tvb, offset>>3, length*2, str);

	offset+=(length<<3)*2;

	return offset;
}


static int
dissect_h245_BMPString_SIZE_1_128(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          1, 128, FALSE);

  return offset;
}


static const value_string h245_T_entryDataType_vals[] = {
  {   0, "videoData" },
  {   1, "audioData" },
  {   2, "data" },
  { 0, NULL }
};

static const per_choice_t T_entryDataType_choice[] = {
  {   0, &hf_h245_videoData      , ASN1_EXTENSION_ROOT    , dissect_h245_VideoCapability },
  {   1, &hf_h245_audioData      , ASN1_EXTENSION_ROOT    , dissect_h245_AudioCapability },
  {   2, &hf_h245_data           , ASN1_EXTENSION_ROOT    , dissect_h245_DataApplicationCapability },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_entryDataType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_entryDataType, T_entryDataType_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_Cm_mediaChannel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_h245_TransportAddress(tvb, offset, actx, hf_index);

  return offset;
}


static const per_sequence_t CommunicationModeTableEntry_sequence[] = {
  { &hf_h245_nonStandardParams, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_NonStandardParameter },
  { &hf_h245_sessionID      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { &hf_h245_associatedSessionID, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_255 },
  { &hf_h245_terminalLabel  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_TerminalLabel },
  { &hf_h245_sessionDescription, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BMPString_SIZE_1_128 },
  { &hf_h245_entryDataType  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_entryDataType },
  { &hf_h245_cm_mediaChannel, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_Cm_mediaChannel },
  { &hf_h245_mediaGuaranteedDelivery, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_BOOLEAN },
  { &hf_h245_cm_mediaControlChannel, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_TransportAddress },
  { &hf_h245_mediaControlGuaranteedDelivery, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_BOOLEAN },
  { &hf_h245_redundancyEncoding, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_RedundancyEncoding },
  { &hf_h245_sessionDependency, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_1_255 },
  { &hf_h245_destination    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_TerminalLabel },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CommunicationModeTableEntry(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CommunicationModeTableEntry, CommunicationModeTableEntry_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_256_OF_CommunicationModeTableEntry_set_of[1] = {
  { &hf_h245_communicationModeTable_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CommunicationModeTableEntry },
};

static int
dissect_h245_SET_SIZE_1_256_OF_CommunicationModeTableEntry(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_256_OF_CommunicationModeTableEntry, SET_SIZE_1_256_OF_CommunicationModeTableEntry_set_of,
                                             1, 256, FALSE);

  return offset;
}


static const value_string h245_CommunicationModeResponse_vals[] = {
  {   0, "communicationModeTable" },
  { 0, NULL }
};

static const per_choice_t CommunicationModeResponse_choice[] = {
  {   0, &hf_h245_communicationModeTable, ASN1_EXTENSION_ROOT    , dissect_h245_SET_SIZE_1_256_OF_CommunicationModeTableEntry },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_CommunicationModeResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_CommunicationModeResponse, CommunicationModeResponse_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_TerminalID(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 128, FALSE, NULL);

  return offset;
}


static const per_sequence_t T_mCTerminalIDResponse_sequence[] = {
  { &hf_h245_terminalLabel  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalLabel },
  { &hf_h245_terminalID     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalID },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_mCTerminalIDResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_mCTerminalIDResponse, T_mCTerminalIDResponse_sequence);

  return offset;
}


static const per_sequence_t T_terminalIDResponse_sequence[] = {
  { &hf_h245_terminalLabel  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalLabel },
  { &hf_h245_terminalID     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalID },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_terminalIDResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_terminalIDResponse, T_terminalIDResponse_sequence);

  return offset;
}



static int
dissect_h245_ConferenceID(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 32, FALSE, NULL);

  return offset;
}


static const per_sequence_t T_conferenceIDResponse_sequence[] = {
  { &hf_h245_terminalLabel  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalLabel },
  { &hf_h245_conferenceID   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ConferenceID },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_conferenceIDResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_conferenceIDResponse, T_conferenceIDResponse_sequence);

  return offset;
}



static int
dissect_h245_Password(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 32, FALSE, NULL);

  return offset;
}


static const per_sequence_t T_passwordResponse_sequence[] = {
  { &hf_h245_terminalLabel  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalLabel },
  { &hf_h245_password       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Password },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_passwordResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_passwordResponse, T_passwordResponse_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_256_OF_TerminalLabel_set_of[1] = {
  { &hf_h245_terminalListResponse_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_TerminalLabel },
};

static int
dissect_h245_SET_SIZE_1_256_OF_TerminalLabel(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_256_OF_TerminalLabel, SET_SIZE_1_256_OF_TerminalLabel_set_of,
                                             1, 256, FALSE);

  return offset;
}


static const value_string h245_T_makeMeChairResponse_vals[] = {
  {   0, "grantedChairToken" },
  {   1, "deniedChairToken" },
  { 0, NULL }
};

static const per_choice_t T_makeMeChairResponse_choice[] = {
  {   0, &hf_h245_grantedChairToken, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_deniedChairToken, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_makeMeChairResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_makeMeChairResponse, T_makeMeChairResponse_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_extensionAddressResponse_sequence[] = {
  { &hf_h245_extensionAddress, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalID },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_extensionAddressResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_extensionAddressResponse, T_extensionAddressResponse_sequence);

  return offset;
}


static const per_sequence_t T_chairTokenOwnerResponse_sequence[] = {
  { &hf_h245_terminalLabel  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalLabel },
  { &hf_h245_terminalID     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalID },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_chairTokenOwnerResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_chairTokenOwnerResponse, T_chairTokenOwnerResponse_sequence);

  return offset;
}


static const per_sequence_t T_terminalCertificateResponse_sequence[] = {
  { &hf_h245_terminalLabel  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_TerminalLabel },
  { &hf_h245_certificateResponse, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OCTET_STRING_SIZE_1_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_terminalCertificateResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_terminalCertificateResponse, T_terminalCertificateResponse_sequence);

  return offset;
}


static const value_string h245_T_broadcastMyLogicalChannelResponse_vals[] = {
  {   0, "grantedBroadcastMyLogicalChannel" },
  {   1, "deniedBroadcastMyLogicalChannel" },
  { 0, NULL }
};

static const per_choice_t T_broadcastMyLogicalChannelResponse_choice[] = {
  {   0, &hf_h245_grantedBroadcastMyLogicalChannel, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_deniedBroadcastMyLogicalChannel, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_broadcastMyLogicalChannelResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_broadcastMyLogicalChannelResponse, T_broadcastMyLogicalChannelResponse_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_makeTerminalBroadcasterResponse_vals[] = {
  {   0, "grantedMakeTerminalBroadcaster" },
  {   1, "deniedMakeTerminalBroadcaster" },
  { 0, NULL }
};

static const per_choice_t T_makeTerminalBroadcasterResponse_choice[] = {
  {   0, &hf_h245_grantedMakeTerminalBroadcaster, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_deniedMakeTerminalBroadcaster, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_makeTerminalBroadcasterResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_makeTerminalBroadcasterResponse, T_makeTerminalBroadcasterResponse_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_sendThisSourceResponse_vals[] = {
  {   0, "grantedSendThisSource" },
  {   1, "deniedSendThisSource" },
  { 0, NULL }
};

static const per_choice_t T_sendThisSourceResponse_choice[] = {
  {   0, &hf_h245_grantedSendThisSource, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_deniedSendThisSource, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_sendThisSourceResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_sendThisSourceResponse, T_sendThisSourceResponse_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t TerminalInformation_sequence[] = {
  { &hf_h245_terminalLabel  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalLabel },
  { &hf_h245_terminalID     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalID },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_TerminalInformation(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_TerminalInformation, TerminalInformation_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_TerminalInformation_sequence_of[1] = {
  { &hf_h245_terminalInformation_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_TerminalInformation },
};

static int
dissect_h245_SEQUENCE_OF_TerminalInformation(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_TerminalInformation, SEQUENCE_OF_TerminalInformation_sequence_of);

  return offset;
}


static const per_sequence_t RequestAllTerminalIDsResponse_sequence[] = {
  { &hf_h245_terminalInformation, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SEQUENCE_OF_TerminalInformation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestAllTerminalIDsResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestAllTerminalIDsResponse, RequestAllTerminalIDsResponse_sequence);

  return offset;
}


static const value_string h245_T_reject_vals[] = {
  {   0, "unspecified" },
  {   1, "functionNotSupported" },
  { 0, NULL }
};

static const per_choice_t T_reject_choice[] = {
  {   0, &hf_h245_unspecified    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_functionNotSupportedFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_reject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_reject, T_reject_choice,
                                 NULL);

  return offset;
}


static const value_string h245_RemoteMCResponse_vals[] = {
  {   0, "accept" },
  {   1, "reject" },
  { 0, NULL }
};

static const per_choice_t RemoteMCResponse_choice[] = {
  {   0, &hf_h245_accept         , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_reject         , ASN1_EXTENSION_ROOT    , dissect_h245_T_reject },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_RemoteMCResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_RemoteMCResponse, RemoteMCResponse_choice,
                                 NULL);

  return offset;
}


static const value_string h245_ConferenceResponse_vals[] = {
  {   0, "mCTerminalIDResponse" },
  {   1, "terminalIDResponse" },
  {   2, "conferenceIDResponse" },
  {   3, "passwordResponse" },
  {   4, "terminalListResponse" },
  {   5, "videoCommandReject" },
  {   6, "terminalDropReject" },
  {   7, "makeMeChairResponse" },
  {   8, "extensionAddressResponse" },
  {   9, "chairTokenOwnerResponse" },
  {  10, "terminalCertificateResponse" },
  {  11, "broadcastMyLogicalChannelResponse" },
  {  12, "makeTerminalBroadcasterResponse" },
  {  13, "sendThisSourceResponse" },
  {  14, "requestAllTerminalIDsResponse" },
  {  15, "remoteMCResponse" },
  { 0, NULL }
};

static const per_choice_t ConferenceResponse_choice[] = {
  {   0, &hf_h245_mCTerminalIDResponse, ASN1_EXTENSION_ROOT    , dissect_h245_T_mCTerminalIDResponse },
  {   1, &hf_h245_terminalIDResponse, ASN1_EXTENSION_ROOT    , dissect_h245_T_terminalIDResponse },
  {   2, &hf_h245_conferenceIDResponse, ASN1_EXTENSION_ROOT    , dissect_h245_T_conferenceIDResponse },
  {   3, &hf_h245_passwordResponse, ASN1_EXTENSION_ROOT    , dissect_h245_T_passwordResponse },
  {   4, &hf_h245_terminalListResponse, ASN1_EXTENSION_ROOT    , dissect_h245_SET_SIZE_1_256_OF_TerminalLabel },
  {   5, &hf_h245_videoCommandReject, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_terminalDropReject, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   7, &hf_h245_makeMeChairResponse, ASN1_EXTENSION_ROOT    , dissect_h245_T_makeMeChairResponse },
  {   8, &hf_h245_extensionAddressResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_extensionAddressResponse },
  {   9, &hf_h245_chairTokenOwnerResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_chairTokenOwnerResponse },
  {  10, &hf_h245_terminalCertificateResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_terminalCertificateResponse },
  {  11, &hf_h245_broadcastMyLogicalChannelResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_broadcastMyLogicalChannelResponse },
  {  12, &hf_h245_makeTerminalBroadcasterResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_makeTerminalBroadcasterResponse },
  {  13, &hf_h245_sendThisSourceResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_sendThisSourceResponse },
  {  14, &hf_h245_requestAllTerminalIDsResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_RequestAllTerminalIDsResponse },
  {  15, &hf_h245_remoteMCResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_RemoteMCResponse },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ConferenceResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ConferenceResponse, ConferenceResponse_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t CallInformationResp_sequence[] = {
  { &hf_h245_dialingInformation, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_DialingInformation },
  { &hf_h245_callAssociationNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_4294967295 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CallInformationResp(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CallInformationResp, CallInformationResp_sequence);

  return offset;
}


static const value_string h245_T_rejected_vals[] = {
  {   0, "connectionsNotAvailable" },
  {   1, "userRejected" },
  { 0, NULL }
};

static const per_choice_t T_rejected_choice[] = {
  {   0, &hf_h245_connectionsNotAvailable, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_userRejected   , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_rejected(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_rejected, T_rejected_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_responseCode_vals[] = {
  {   0, "accepted" },
  {   1, "rejected" },
  { 0, NULL }
};

static const per_choice_t T_responseCode_choice[] = {
  {   0, &hf_h245_accepted       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_rejected       , ASN1_EXTENSION_ROOT    , dissect_h245_T_rejected },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_responseCode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_responseCode, T_responseCode_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t AddConnectionResp_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_responseCode   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_responseCode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_AddConnectionResp(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_AddConnectionResp, AddConnectionResp_sequence);

  return offset;
}


static const per_sequence_t RemoveConnectionResp_sequence[] = {
  { &hf_h245_connectionIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ConnectionIdentifier },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RemoveConnectionResp(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RemoveConnectionResp, RemoveConnectionResp_sequence);

  return offset;
}


static const per_sequence_t MaximumHeaderIntervalResp_sequence[] = {
  { &hf_h245_currentInterval, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MaximumHeaderIntervalResp(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MaximumHeaderIntervalResp, MaximumHeaderIntervalResp_sequence);

  return offset;
}


static const value_string h245_MultilinkResponse_vals[] = {
  {   0, "nonStandard" },
  {   1, "callInformation" },
  {   2, "addConnection" },
  {   3, "removeConnection" },
  {   4, "maximumHeaderInterval" },
  { 0, NULL }
};

static const per_choice_t MultilinkResponse_choice[] = {
  {   0, &hf_h245_nonStandardMsg , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardMessage },
  {   1, &hf_h245_callInformationResp, ASN1_EXTENSION_ROOT    , dissect_h245_CallInformationResp },
  {   2, &hf_h245_addConnectionResp, ASN1_EXTENSION_ROOT    , dissect_h245_AddConnectionResp },
  {   3, &hf_h245_removeConnectionResp, ASN1_EXTENSION_ROOT    , dissect_h245_RemoveConnectionResp },
  {   4, &hf_h245_maximumHeaderIntervalResp, ASN1_EXTENSION_ROOT    , dissect_h245_MaximumHeaderIntervalResp },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MultilinkResponse(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MultilinkResponse, MultilinkResponse_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t LogicalChannelRateAcknowledge_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_logicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_maximumBitRate , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_MaximumBitRate },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_LogicalChannelRateAcknowledge(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_LogicalChannelRateAcknowledge, LogicalChannelRateAcknowledge_sequence);

  return offset;
}


static const value_string h245_LogicalChannelRateRejectReason_vals[] = {
  {   0, "undefinedReason" },
  {   1, "insufficientResources" },
  { 0, NULL }
};

static const per_choice_t LogicalChannelRateRejectReason_choice[] = {
  {   0, &hf_h245_undefinedReason, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_insufficientResources, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_LogicalChannelRateRejectReason(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_LogicalChannelRateRejectReason, LogicalChannelRateRejectReason_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t LogicalChannelRateReject_sequence[] = {
  { &hf_h245_sequenceNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_logicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_rejectReason   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelRateRejectReason },
  { &hf_h245_currentMaximumBitRate, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_MaximumBitRate },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_LogicalChannelRateReject(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s\n", val_to_str(	h_245_message_value.msg_value, h245_ResponseMessage_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_LogicalChannelRateReject, LogicalChannelRateReject_sequence);

  return offset;
}



static const per_choice_t ResponseMessage_choice[] = {
  { ResponseMessage_nonStandard, &hf_h245_nonStandardMsg , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardMessage },
  { ResponseMessage_masterSlaveDeterminationAck, &hf_h245_masterSlaveDeterminationAck, ASN1_EXTENSION_ROOT    , dissect_h245_MasterSlaveDeterminationAck },
  { ResponseMessage_masterSlaveDeterminationReject, &hf_h245_masterSlaveDeterminationReject, ASN1_EXTENSION_ROOT    , dissect_h245_MasterSlaveDeterminationReject },
  { ResponseMessage_terminalCapabilitySetAck, &hf_h245_terminalCapabilitySetAck, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalCapabilitySetAck },
  { ResponseMessage_terminalCapabilitySetReject, &hf_h245_terminalCapabilitySetReject, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalCapabilitySetReject },
  { ResponseMessage_openLogicalChannelAck, &hf_h245_openLogicalChannelAck, ASN1_EXTENSION_ROOT    , dissect_h245_OpenLogicalChannelAck },
  { ResponseMessage_openLogicalChannelReject, &hf_h245_openLogicalChannelReject, ASN1_EXTENSION_ROOT    , dissect_h245_OpenLogicalChannelReject },
  { ResponseMessage_closeLogicalChannelAck, &hf_h245_closeLogicalChannelAck, ASN1_EXTENSION_ROOT    , dissect_h245_CloseLogicalChannelAck },
  { ResponseMessage_requestChannelCloseAck, &hf_h245_requestChannelCloseAck, ASN1_EXTENSION_ROOT    , dissect_h245_RequestChannelCloseAck },
  { ResponseMessage_requestChannelCloseReject, &hf_h245_requestChannelCloseReject, ASN1_EXTENSION_ROOT    , dissect_h245_RequestChannelCloseReject },
  { ResponseMessage_multiplexEntrySendAck, &hf_h245_multiplexEntrySendAck, ASN1_EXTENSION_ROOT    , dissect_h245_MultiplexEntrySendAck },
  { ResponseMessage_multiplexEntrySendReject, &hf_h245_multiplexEntrySendReject, ASN1_EXTENSION_ROOT    , dissect_h245_MultiplexEntrySendReject },
  { ResponseMessage_requestMultiplexEntryAck, &hf_h245_requestMultiplexEntryAck, ASN1_EXTENSION_ROOT    , dissect_h245_RequestMultiplexEntryAck },
  { ResponseMessage_requestMultiplexEntryReject, &hf_h245_requestMultiplexEntryReject, ASN1_EXTENSION_ROOT    , dissect_h245_RequestMultiplexEntryReject },
  { ResponseMessage_requestModeAck, &hf_h245_requestModeAck , ASN1_EXTENSION_ROOT    , dissect_h245_RequestModeAck },
  { ResponseMessage_requestModeReject, &hf_h245_requestModeReject, ASN1_EXTENSION_ROOT    , dissect_h245_RequestModeReject },
  { ResponseMessage_roundTripDelayResponse, &hf_h245_roundTripDelayResponse, ASN1_EXTENSION_ROOT    , dissect_h245_RoundTripDelayResponse },
  { ResponseMessage_maintenanceLoopAck, &hf_h245_maintenanceLoopAck, ASN1_EXTENSION_ROOT    , dissect_h245_MaintenanceLoopAck },
  { ResponseMessage_maintenanceLoopReject, &hf_h245_maintenanceLoopReject, ASN1_EXTENSION_ROOT    , dissect_h245_MaintenanceLoopReject },
  { ResponseMessage_communicationModeResponse, &hf_h245_communicationModeResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_CommunicationModeResponse },
  { ResponseMessage_conferenceResponse, &hf_h245_conferenceResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_ConferenceResponse },
  { ResponseMessage_multilinkResponse, &hf_h245_multilinkResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultilinkResponse },
  { ResponseMessage_logicalChannelRateAcknowledge, &hf_h245_logicalChannelRateAcknowledge, ASN1_NOT_EXTENSION_ROOT, dissect_h245_LogicalChannelRateAcknowledge },
  { ResponseMessage_logicalChannelRateReject, &hf_h245_logicalChannelRateReject, ASN1_NOT_EXTENSION_ROOT, dissect_h245_LogicalChannelRateReject },
  { ResponseMessage_genericResponse, &hf_h245_genericResponse, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericMessage },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ResponseMessage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 408 "../../asn1/h245/h245.cnf"
  gint32 value;
   printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_MultimediaSystemControlMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s :", val_to_str(	h_245_message_value.msg_value, h245_MultimediaSystemControlMessage_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ResponseMessage, ResponseMessage_choice,
                                 &value);

	    if ( h245_shorttypes == TRUE )
	        {
	        	//col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, "%s ",
			printf("%s\n ",	val_to_str(value, h245_ResponseMessage_short_vals, "<unknown>"));
		}
		else
		{
	        	//col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, "%s ",
		//	printf("%s\n ",	val_to_str(value, h245_ResponseMessage_vals, "<unknown>"));
		}

	//col_set_fence(actx->pinfo->cinfo,COL_INFO);

	if (h245_pi != NULL){
		/* Add to packet info */
		if ( strlen(h245_pi->frame_label) == 0 ){
//		   g_snprintf(h245_pi->frame_label, 50, "%s", val_to_str(value, h245_ResponseMessage_short_vals, "UKN"));
		}
		//g_strlcat(h245_pi->comment, val_to_str(value, h245_ResponseMessage_vals, "<unknown>"), 50);
	}



  return offset;
}


static const per_sequence_t MaintenanceLoopOffCommand_sequence[] = {
  { NULL, ASN1_EXTENSION_ROOT, 0, NULL }
};

static int
dissect_h245_MaintenanceLoopOffCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MaintenanceLoopOffCommand, MaintenanceLoopOffCommand_sequence);

  return offset;
}


static const per_sequence_t SET_SIZE_1_65535_OF_CapabilityTableEntryNumber_set_of[1] = {
  { &hf_h245_capabilityTableEntryNumbers_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityTableEntryNumber },
};

static int
dissect_h245_SET_SIZE_1_65535_OF_CapabilityTableEntryNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_65535_OF_CapabilityTableEntryNumber, SET_SIZE_1_65535_OF_CapabilityTableEntryNumber_set_of,
                                             1, 65535, FALSE);

  return offset;
}


static const per_sequence_t SET_SIZE_1_256_OF_CapabilityDescriptorNumber_set_of[1] = {
  { &hf_h245_capabilityDescriptorNumbers_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_CapabilityDescriptorNumber },
};

static int
dissect_h245_SET_SIZE_1_256_OF_CapabilityDescriptorNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_set_of(tvb, offset, actx, hf_index,
                                             ett_h245_SET_SIZE_1_256_OF_CapabilityDescriptorNumber, SET_SIZE_1_256_OF_CapabilityDescriptorNumber_set_of,
                                             1, 256, FALSE);

  return offset;
}


static const per_sequence_t T_specificRequest_sequence[] = {
  { &hf_h245_multiplexCapabilityBool, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_capabilityTableEntryNumbers, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_65535_OF_CapabilityTableEntryNumber },
  { &hf_h245_capabilityDescriptorNumbers, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_SET_SIZE_1_256_OF_CapabilityDescriptorNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_specificRequest(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_specificRequest, T_specificRequest_sequence);

  return offset;
}


static const value_string h245_SendTerminalCapabilitySet_vals[] = {
  {   0, "specificRequest" },
  {   1, "genericRequest" },
  { 0, NULL }
};

static const per_choice_t SendTerminalCapabilitySet_choice[] = {
  {   0, &hf_h245_specificRequest, ASN1_EXTENSION_ROOT    , dissect_h245_T_specificRequest },
  {   1, &hf_h245_genericRequestFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_SendTerminalCapabilitySet(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_SendTerminalCapabilitySet, SendTerminalCapabilitySet_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_encryptionAlgorithmID_sequence[] = {
  { &hf_h245_h233AlgorithmIdentifier, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_SequenceNumber },
  { &hf_h245_associatedAlgorithm, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_NonStandardParameter },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_encryptionAlgorithmID(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_encryptionAlgorithmID, T_encryptionAlgorithmID_sequence);

  return offset;
}


static const value_string h245_EncryptionCommand_vals[] = {
  {   0, "encryptionSE" },
  {   1, "encryptionIVRequest" },
  {   2, "encryptionAlgorithmID" },
  { 0, NULL }
};

static const per_choice_t EncryptionCommand_choice[] = {
  {   0, &hf_h245_encryptionSE   , ASN1_EXTENSION_ROOT    , dissect_h245_OCTET_STRING },
  {   1, &hf_h245_encryptionIVRequest, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_encryptionAlgorithmID, ASN1_EXTENSION_ROOT    , dissect_h245_T_encryptionAlgorithmID },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_EncryptionCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_EncryptionCommand, EncryptionCommand_choice,
                                 NULL);

  return offset;
}


static const value_string h245_Scope_vals[] = {
  {   0, "logicalChannelNumber" },
  {   1, "resourceID" },
  {   2, "wholeMultiplex" },
  { 0, NULL }
};

static const per_choice_t Scope_choice[] = {
  {   0, &hf_h245_logicalChannelNumber, ASN1_NO_EXTENSIONS     , dissect_h245_LogicalChannelNumber },
  {   1, &hf_h245_resourceID     , ASN1_NO_EXTENSIONS     , dissect_h245_INTEGER_0_65535 },
  {   2, &hf_h245_wholeMultiplex , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Scope(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Scope, Scope_choice,
                                 NULL);

  return offset;
}


static const value_string h245_Restriction_vals[] = {
  {   0, "maximumBitRate" },
  {   1, "noRestriction" },
  { 0, NULL }
};

static const per_choice_t Restriction_choice[] = {
  {   0, &hf_h245_res_maximumBitRate, ASN1_NO_EXTENSIONS     , dissect_h245_INTEGER_0_16777215 },
  {   1, &hf_h245_noRestriction  , ASN1_NO_EXTENSIONS     , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Restriction(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Restriction, Restriction_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t FlowControlCommand_sequence[] = {
  { &hf_h245_scope          , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Scope },
  { &hf_h245_restriction    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Restriction },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_FlowControlCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_FlowControlCommand, FlowControlCommand_sequence);

  return offset;
}


static const value_string h245_T_gstnOptions_vals[] = {
  {   0, "telephonyMode" },
  {   1, "v8bis" },
  {   2, "v34DSVD" },
  {   3, "v34DuplexFAX" },
  {   4, "v34H324" },
  { 0, NULL }
};

static const per_choice_t T_gstnOptions_choice[] = {
  {   0, &hf_h245_telephonyMode  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_v8bis          , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_v34DSVD        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_v34DuplexFAX   , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_v34H324        , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_gstnOptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_gstnOptions, T_gstnOptions_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_isdnOptions_vals[] = {
  {   0, "telephonyMode" },
  {   1, "v140" },
  {   2, "terminalOnHold" },
  { 0, NULL }
};

static const per_choice_t T_isdnOptions_choice[] = {
  {   0, &hf_h245_telephonyMode  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_v140           , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_terminalOnHold , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_isdnOptions(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_isdnOptions, T_isdnOptions_choice,
                                 NULL);

  return offset;
}


static const value_string h245_EndSessionCommand_vals[] = {
  {   0, "nonStandard" },
  {   1, "disconnect" },
  {   2, "gstnOptions" },
  {   3, "isdnOptions" },
  {   4, "genericInformation" },
  { 0, NULL }
};

static const per_choice_t EndSessionCommand_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_disconnect     , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_gstnOptions    , ASN1_EXTENSION_ROOT    , dissect_h245_T_gstnOptions },
  {   3, &hf_h245_isdnOptions    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_isdnOptions },
  {   4, &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, dissect_h245_SEQUENCE_OF_GenericInformation },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_EndSessionCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_EndSessionCommand, EndSessionCommand_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_INTEGER_0_17(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 17U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_18(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 18U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_videoFastUpdateGOB_sequence[] = {
  { &hf_h245_firstGOB       , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_17 },
  { &hf_h245_numberOfGOBs   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_18 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_videoFastUpdateGOB(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_videoFastUpdateGOB, T_videoFastUpdateGOB_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_0_31(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 31U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_1_8192(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 8192U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_videoFastUpdateMB_sequence[] = {
  { &hf_h245_firstGOB_0_255 , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_255 },
  { &hf_h245_firstMB_1_8192 , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_8192 },
  { &hf_h245_numberOfMBs    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_8192 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_videoFastUpdateMB(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_videoFastUpdateMB, T_videoFastUpdateMB_sequence);

  return offset;
}


static const per_sequence_t KeyProtectionMethod_sequence[] = {
  { &hf_h245_secureChannel  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_sharedSecret   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_certProtectedKey, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_KeyProtectionMethod(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_KeyProtectionMethod, KeyProtectionMethod_sequence);

  return offset;
}


static const per_sequence_t EncryptionUpdateRequest_sequence[] = {
  { &hf_h245_keyProtectionMethod, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_KeyProtectionMethod },
  { &hf_h245_synchFlag      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_INTEGER_0_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_EncryptionUpdateRequest(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_EncryptionUpdateRequest, EncryptionUpdateRequest_sequence);

  return offset;
}


static const value_string h245_T_repeatCount_vals[] = {
  {   0, "doOneProgression" },
  {   1, "doContinuousProgressions" },
  {   2, "doOneIndependentProgression" },
  {   3, "doContinuousIndependentProgressions" },
  { 0, NULL }
};

static const per_choice_t T_repeatCount_choice[] = {
  {   0, &hf_h245_doOneProgression, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_doContinuousProgressions, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_doOneIndependentProgression, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_doContinuousIndependentProgressions, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_repeatCount(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_repeatCount, T_repeatCount_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_progressiveRefinementStart_sequence[] = {
  { &hf_h245_repeatCount    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_repeatCount },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_progressiveRefinementStart(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_progressiveRefinementStart, T_progressiveRefinementStart_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_1_9216(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 9216U, NULL, FALSE);

  return offset;
}


static const per_sequence_t T_videoBadMBs_sequence[] = {
  { &hf_h245_firstMB        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_9216 },
  { &hf_h245_numberOfMBs1_1_9216, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_9216 },
  { &hf_h245_temporalReference, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_1023 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_videoBadMBs(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_videoBadMBs, T_videoBadMBs_sequence);

  return offset;
}


static const value_string h245_PictureReference_vals[] = {
  {   0, "pictureNumber" },
  {   1, "longTermPictureIndex" },
  { 0, NULL }
};

static const per_choice_t PictureReference_choice[] = {
  {   0, &hf_h245_pictureNumber  , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_0_1023 },
  {   1, &hf_h245_longTermPictureIndex, ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_0_255 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_PictureReference(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_PictureReference, PictureReference_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_PictureReference_sequence_of[1] = {
  { &hf_h245_lostPicture_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h245_PictureReference },
};

static int
dissect_h245_SEQUENCE_OF_PictureReference(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h245_SEQUENCE_OF_PictureReference, SEQUENCE_OF_PictureReference_sequence_of);

  return offset;
}


static const per_sequence_t T_lostPartialPicture_sequence[] = {
  { &hf_h245_pictureReference, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_PictureReference },
  { &hf_h245_firstMB        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_9216 },
  { &hf_h245_numberOfMBs1_1_9216, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_9216 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_lostPartialPicture(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_lostPartialPicture, T_lostPartialPicture_sequence);

  return offset;
}


static const per_sequence_t T_encryptionUpdateCommand_sequence[] = {
  { &hf_h245_encryptionSync , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_EncryptionSync },
  { &hf_h245_multiplePayloadStream, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_MultiplePayloadStream },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_encryptionUpdateCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_encryptionUpdateCommand, T_encryptionUpdateCommand_sequence);

  return offset;
}


static const per_sequence_t T_encryptionUpdateAck_sequence[] = {
  { &hf_h245_synchFlag      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_encryptionUpdateAck(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_encryptionUpdateAck, T_encryptionUpdateAck_sequence);

  return offset;
}


static const value_string h245_Mc_type_vals[] = {
  {   0, "equaliseDelay" },
  {   1, "zeroDelay" },
  {   2, "multipointModeCommand" },
  {   3, "cancelMultipointModeCommand" },
  {   4, "videoFreezePicture" },
  {   5, "videoFastUpdatePicture" },
  {   6, "videoFastUpdateGOB" },
  {   7, "videoTemporalSpatialTradeOff" },
  {   8, "videoSendSyncEveryGOB" },
  {   9, "videoSendSyncEveryGOBCancel" },
  {  10, "videoFastUpdateMB" },
  {  11, "maxH223MUXPDUsize" },
  {  12, "encryptionUpdate" },
  {  13, "encryptionUpdateRequest" },
  {  14, "switchReceiveMediaOff" },
  {  15, "switchReceiveMediaOn" },
  {  16, "progressiveRefinementStart" },
  {  17, "progressiveRefinementAbortOne" },
  {  18, "progressiveRefinementAbortContinuous" },
  {  19, "videoBadMBs" },
  {  20, "lostPicture" },
  {  21, "lostPartialPicture" },
  {  22, "recoveryReferencePicture" },
  {  23, "encryptionUpdateCommand" },
  {  24, "encryptionUpdateAck" },
  { 0, NULL }
};

static const per_choice_t Mc_type_choice[] = {
  {   0, &hf_h245_equaliseDelay  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_zeroDelay      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_multipointModeCommand, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_cancelMultipointModeCommand, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_videoFreezePicture, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_videoFastUpdatePicture, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_videoFastUpdateGOB, ASN1_EXTENSION_ROOT    , dissect_h245_T_videoFastUpdateGOB },
  {   7, &hf_h245_videoTemporalSpatialTradeOff, ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_0_31 },
  {   8, &hf_h245_videoSendSyncEveryGOB, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   9, &hf_h245_videoSendSyncEveryGOBCancel, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {  10, &hf_h245_videoFastUpdateMB, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_videoFastUpdateMB },
  {  11, &hf_h245_maxH223MUXPDUsize, ASN1_NOT_EXTENSION_ROOT, dissect_h245_INTEGER_1_65535 },
  {  12, &hf_h245_encryptionUpdate, ASN1_NOT_EXTENSION_ROOT, dissect_h245_EncryptionSync },
  {  13, &hf_h245_encryptionUpdateRequest, ASN1_NOT_EXTENSION_ROOT, dissect_h245_EncryptionUpdateRequest },
  {  14, &hf_h245_switchReceiveMediaOff, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  15, &hf_h245_switchReceiveMediaOn, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  16, &hf_h245_progressiveRefinementStart, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_progressiveRefinementStart },
  {  17, &hf_h245_progressiveRefinementAbortOne, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  18, &hf_h245_progressiveRefinementAbortContinuous, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  19, &hf_h245_videoBadMBs    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_videoBadMBs },
  {  20, &hf_h245_lostPicture    , ASN1_NOT_EXTENSION_ROOT, dissect_h245_SEQUENCE_OF_PictureReference },
  {  21, &hf_h245_lostPartialPicture, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_lostPartialPicture },
  {  22, &hf_h245_recoveryReferencePicture, ASN1_NOT_EXTENSION_ROOT, dissect_h245_SEQUENCE_OF_PictureReference },
  {  23, &hf_h245_encryptionUpdateCommand, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_encryptionUpdateCommand },
  {  24, &hf_h245_encryptionUpdateAck, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_encryptionUpdateAck },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Mc_type(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Mc_type, Mc_type_choice,
                                 NULL);

  return offset;
}


static const value_string h245_EncryptionUpdateDirection_vals[] = {
  {   0, "masterToSlave" },
  {   1, "slaveToMaster" },
  { 0, NULL }
};

static const per_choice_t EncryptionUpdateDirection_choice[] = {
  {   0, &hf_h245_masterToSlave  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_slaveToMaster  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_EncryptionUpdateDirection(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_EncryptionUpdateDirection, EncryptionUpdateDirection_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MiscellaneousCommand_sequence[] = {
  { &hf_h245_logicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_mc_type        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Mc_type },
  { &hf_h245_direction      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_EncryptionUpdateDirection },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MiscellaneousCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MiscellaneousCommand, MiscellaneousCommand_sequence);

  return offset;
}


static const per_sequence_t CommunicationModeCommand_sequence[] = {
  { &hf_h245_communicationModeTable, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_256_OF_CommunicationModeTableEntry },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_CommunicationModeCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_CommunicationModeCommand, CommunicationModeCommand_sequence);

  return offset;
}


static const per_sequence_t SubstituteConferenceIDCommand_sequence[] = {
  { &hf_h245_conferenceIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING_SIZE_16 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_SubstituteConferenceIDCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_SubstituteConferenceIDCommand, SubstituteConferenceIDCommand_sequence);

  return offset;
}


static const value_string h245_ConferenceCommand_vals[] = {
  {   0, "broadcastMyLogicalChannel" },
  {   1, "cancelBroadcastMyLogicalChannel" },
  {   2, "makeTerminalBroadcaster" },
  {   3, "cancelMakeTerminalBroadcaster" },
  {   4, "sendThisSource" },
  {   5, "cancelSendThisSource" },
  {   6, "dropConference" },
  {   7, "substituteConferenceIDCommand" },
  { 0, NULL }
};

static const per_choice_t ConferenceCommand_choice[] = {
  {   0, &hf_h245_broadcastMyLogicalChannel, ASN1_EXTENSION_ROOT    , dissect_h245_LogicalChannelNumber },
  {   1, &hf_h245_cancelBroadcastMyLogicalChannel, ASN1_EXTENSION_ROOT    , dissect_h245_LogicalChannelNumber },
  {   2, &hf_h245_makeTerminalBroadcaster, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalLabel },
  {   3, &hf_h245_cancelMakeTerminalBroadcaster, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_sendThisSource , ASN1_EXTENSION_ROOT    , dissect_h245_TerminalLabel },
  {   5, &hf_h245_cancelSendThisSource, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_dropConference , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   7, &hf_h245_substituteConferenceIDCommand, ASN1_NOT_EXTENSION_ROOT, dissect_h245_SubstituteConferenceIDCommand },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ConferenceCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ConferenceCommand, ConferenceCommand_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_h223ModeChange_vals[] = {
  {   0, "toLevel0" },
  {   1, "toLevel1" },
  {   2, "toLevel2" },
  {   3, "toLevel2withOptionalHeader" },
  { 0, NULL }
};

static const per_choice_t T_h223ModeChange_choice[] = {
  {   0, &hf_h245_toLevel0       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_toLevel1       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_toLevel2       , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_toLevel2withOptionalHeader, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_h223ModeChange(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_h223ModeChange, T_h223ModeChange_choice,
                                 NULL);

  return offset;
}


static const value_string h245_T_h223AnnexADoubleFlag_vals[] = {
  {   0, "start" },
  {   1, "stop" },
  { 0, NULL }
};

static const per_choice_t T_h223AnnexADoubleFlag_choice[] = {
  {   0, &hf_h245_start          , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_stop           , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_h223AnnexADoubleFlag(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_h223AnnexADoubleFlag, T_h223AnnexADoubleFlag_choice,
                                 NULL);

  return offset;
}


static const value_string h245_H223MultiplexReconfiguration_vals[] = {
  {   0, "h223ModeChange" },
  {   1, "h223AnnexADoubleFlag" },
  { 0, NULL }
};

static const per_choice_t H223MultiplexReconfiguration_choice[] = {
  {   0, &hf_h245_h223ModeChange , ASN1_EXTENSION_ROOT    , dissect_h245_T_h223ModeChange },
  {   1, &hf_h245_h223AnnexADoubleFlag, ASN1_EXTENSION_ROOT    , dissect_h245_T_h223AnnexADoubleFlag },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_H223MultiplexReconfiguration(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_H223MultiplexReconfiguration, H223MultiplexReconfiguration_choice,
                                 NULL);

  return offset;
}


static const value_string h245_Cmd_clockRecovery_vals[] = {
  {   0, "nullClockRecovery" },
  {   1, "srtsClockRecovery" },
  {   2, "adaptiveClockRecovery" },
  { 0, NULL }
};

static const per_choice_t Cmd_clockRecovery_choice[] = {
  {   0, &hf_h245_nullClockRecoveryflag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_srtsClockRecovery, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_adaptiveClockRecoveryFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Cmd_clockRecovery(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Cmd_clockRecovery, Cmd_clockRecovery_choice,
                                 NULL);

  return offset;
}


static const value_string h245_Cmd_errorCorrection_vals[] = {
  {   0, "nullErrorCorrection" },
  {   1, "longInterleaver" },
  {   2, "shortInterleaver" },
  {   3, "errorCorrectionOnly" },
  { 0, NULL }
};

static const per_choice_t Cmd_errorCorrection_choice[] = {
  {   0, &hf_h245_nullErrorCorrectionFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_longInterleaverFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_shortInterleaverFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_errorCorrectionOnlyFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Cmd_errorCorrection(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Cmd_errorCorrection, Cmd_errorCorrection_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t Cmd_aal1_sequence[] = {
  { &hf_h245_cmd_clockRecovery, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Cmd_clockRecovery },
  { &hf_h245_cmd_errorCorrection, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Cmd_errorCorrection },
  { &hf_h245_structuredDataTransfer, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_partiallyFilledCells, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Cmd_aal1(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Cmd_aal1, Cmd_aal1_sequence);

  return offset;
}


static const per_sequence_t Cmd_aal5_sequence[] = {
  { &hf_h245_forwardMaximumSDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_backwardMaximumSDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Cmd_aal5(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Cmd_aal5, Cmd_aal5_sequence);

  return offset;
}


static const value_string h245_Cmd_aal_vals[] = {
  {   0, "aal1" },
  {   1, "aal5" },
  { 0, NULL }
};

static const per_choice_t Cmd_aal_choice[] = {
  {   0, &hf_h245_cmd_aal1       , ASN1_EXTENSION_ROOT    , dissect_h245_Cmd_aal1 },
  {   1, &hf_h245_cmd_aal5       , ASN1_EXTENSION_ROOT    , dissect_h245_Cmd_aal5 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Cmd_aal(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Cmd_aal, Cmd_aal_choice,
                                 NULL);

  return offset;
}


static const value_string h245_Cmd_multiplex_vals[] = {
  {   0, "noMultiplex" },
  {   1, "transportStream" },
  {   2, "programStream" },
  { 0, NULL }
};

static const per_choice_t Cmd_multiplex_choice[] = {
  {   0, &hf_h245_noMultiplex    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_transportStream, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_programStreamFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Cmd_multiplex(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Cmd_multiplex, Cmd_multiplex_choice,
                                 NULL);

  return offset;
}


static const value_string h245_CmdR_multiplex_vals[] = {
  {   0, "noMultiplex" },
  {   1, "transportStream" },
  {   2, "programStream" },
  { 0, NULL }
};

static const per_choice_t CmdR_multiplex_choice[] = {
  {   0, &hf_h245_noMultiplex    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_transportStream, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_programStreamFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_CmdR_multiplex(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_CmdR_multiplex, CmdR_multiplex_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t Cmd_reverseParameters_sequence[] = {
  { &hf_h245_bitRate        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65535 },
  { &hf_h245_bitRateLockedToPCRClock, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_bitRateLockedToNetworkClock, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_cmdr_multiplex , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_CmdR_multiplex },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Cmd_reverseParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Cmd_reverseParameters, Cmd_reverseParameters_sequence);

  return offset;
}


static const per_sequence_t NewATMVCCommand_sequence[] = {
  { &hf_h245_resourceID     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_bitRate        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65535 },
  { &hf_h245_bitRateLockedToPCRClock, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_bitRateLockedToNetworkClock, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_cmd_aal        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Cmd_aal },
  { &hf_h245_cmd_multiplex  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Cmd_multiplex },
  { &hf_h245_cmd_reverseParameters, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Cmd_reverseParameters },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_NewATMVCCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_NewATMVCCommand, NewATMVCCommand_sequence);

  return offset;
}


static const value_string h245_T_status_vals[] = {
  {   0, "synchronized" },
  {   1, "reconfiguration" },
  { 0, NULL }
};

static const per_choice_t T_status_choice[] = {
  {   0, &hf_h245_synchronized   , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_reconfiguration, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_status(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_status, T_status_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MobileMultilinkReconfigurationCommand_sequence[] = {
  { &hf_h245_sampleSize     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { &hf_h245_samplesPerFrame, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { &hf_h245_status         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_status },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MobileMultilinkReconfigurationCommand(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MobileMultilinkReconfigurationCommand, MobileMultilinkReconfigurationCommand_sequence);

  return offset;
}


static const value_string h245_CommandMessage_vals[] = {
  { CommandMessage_nonStandard, "nonStandard" },
  { CommandMessage_maintenanceLoopOffCommand, "maintenanceLoopOffCommand" },
  { CommandMessage_sendTerminalCapabilitySet, "sendTerminalCapabilitySet" },
  { CommandMessage_encryptionCommand, "encryptionCommand" },
  { CommandMessage_flowControlCommand, "flowControlCommand" },
  { CommandMessage_endSessionCommand, "endSessionCommand" },
  { CommandMessage_miscellaneousCommand, "miscellaneousCommand" },
  { CommandMessage_communicationModeCommand, "communicationModeCommand" },
  { CommandMessage_conferenceCommand, "conferenceCommand" },
  { CommandMessage_h223MultiplexReconfiguration, "h223MultiplexReconfiguration" },
  { CommandMessage_newATMVCCommand, "newATMVCCommand" },
  { CommandMessage_mobileMultilinkReconfigurationCommand, "mobileMultilinkReconfigurationCommand" },
  { CommandMessage_genericCommand, "genericCommand" },
  { 0, NULL }
};

static const per_choice_t CommandMessage_choice[] = {
  { CommandMessage_nonStandard, &hf_h245_nonStandardMsg , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardMessage },
  { CommandMessage_maintenanceLoopOffCommand, &hf_h245_maintenanceLoopOffCommand, ASN1_EXTENSION_ROOT    , dissect_h245_MaintenanceLoopOffCommand },
  { CommandMessage_sendTerminalCapabilitySet, &hf_h245_sendTerminalCapabilitySet, ASN1_EXTENSION_ROOT    , dissect_h245_SendTerminalCapabilitySet },
  { CommandMessage_encryptionCommand, &hf_h245_encryptionCommand, ASN1_EXTENSION_ROOT    , dissect_h245_EncryptionCommand },
  { CommandMessage_flowControlCommand, &hf_h245_flowControlCommand, ASN1_EXTENSION_ROOT    , dissect_h245_FlowControlCommand },
  { CommandMessage_endSessionCommand, &hf_h245_endSessionCommand, ASN1_EXTENSION_ROOT    , dissect_h245_EndSessionCommand },
  { CommandMessage_miscellaneousCommand, &hf_h245_miscellaneousCommand, ASN1_EXTENSION_ROOT    , dissect_h245_MiscellaneousCommand },
  { CommandMessage_communicationModeCommand, &hf_h245_communicationModeCommand, ASN1_NOT_EXTENSION_ROOT, dissect_h245_CommunicationModeCommand },
  { CommandMessage_conferenceCommand, &hf_h245_conferenceCommand, ASN1_NOT_EXTENSION_ROOT, dissect_h245_ConferenceCommand },
  { CommandMessage_h223MultiplexReconfiguration, &hf_h245_h223MultiplexReconfiguration, ASN1_NOT_EXTENSION_ROOT, dissect_h245_H223MultiplexReconfiguration },
  { CommandMessage_newATMVCCommand, &hf_h245_newATMVCCommand, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NewATMVCCommand },
  { CommandMessage_mobileMultilinkReconfigurationCommand, &hf_h245_mobileMultilinkReconfigurationCommand, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MobileMultilinkReconfigurationCommand },
  { CommandMessage_genericCommand, &hf_h245_genericCommand , ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericMessage },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_CommandMessage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 462 "../../asn1/h245/h245.cnf"
  gint32 value;
   printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_MultimediaSystemControlMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s :", val_to_str(	h_245_message_value.msg_value, h245_MultimediaSystemControlMessage_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_CommandMessage, CommandMessage_choice,
                                 &value);

	   if ( h245_shorttypes == TRUE )
	        {
	        	
				//col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, 
				printf("%s\n ",
				val_to_str(value, h245_CommandMessage_short_vals, "<unknown>"));
		}
		else
		{
	        	//col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, "%s ",
			printf("%s\n ",	val_to_str(value, h245_CommandMessage_vals, "<unknown>"));
		}

	//col_set_fence(actx->pinfo->cinfo,COL_INFO);
    /* Add to packet info */
    if (h245_pi != NULL){
      if ( strlen(h245_pi->frame_label) == 0 ){
//        g_snprintf(h245_pi->frame_label, 50, "%s", val_to_str(value, h245_CommandMessage_short_vals, "UKN"));
      }
	//  g_strlcat(h245_pi->comment, val_to_str(value, h245_CommandMessage_vals, "<unknown>"), 50);
    }



  return offset;
}


static const value_string h245_FunctionNotUnderstood_vals[] = {
  {   0, "request" },
  {   1, "response" },
  {   2, "command" },
  { 0, NULL }
};

static const per_choice_t FunctionNotUnderstood_choice[] = {
  {   0, &hf_h245_request        , ASN1_NO_EXTENSIONS     , dissect_h245_RequestMessage },
  {   1, &hf_h245_response       , ASN1_NO_EXTENSIONS     , dissect_h245_ResponseMessage },
  {   2, &hf_h245_command        , ASN1_NO_EXTENSIONS     , dissect_h245_CommandMessage },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_FunctionNotUnderstood(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_FunctionNotUnderstood, FunctionNotUnderstood_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MasterSlaveDeterminationRelease_sequence[] = {
  { NULL, ASN1_EXTENSION_ROOT, 0, NULL }
};

static int
dissect_h245_MasterSlaveDeterminationRelease(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MasterSlaveDeterminationRelease, MasterSlaveDeterminationRelease_sequence);

//#line 585 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_MastSlvDetRls;

  return offset;
}


static const per_sequence_t TerminalCapabilitySetRelease_sequence[] = {
  { &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_GenericInformation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_TerminalCapabilitySetRelease(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_TerminalCapabilitySetRelease, TerminalCapabilitySetRelease_sequence);

//#line 597 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_TermCapSetRls;

  return offset;
}


static const per_sequence_t OpenLogicalChannelConfirm_sequence[] = {
  { &hf_h245_forwardLogicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_SEQUENCE_OF_GenericInformation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_OpenLogicalChannelConfirm(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_OpenLogicalChannelConfirm, OpenLogicalChannelConfirm_sequence);

//#line 561 "../../asn1/h245/h245.cnf"

if (h245_pi != NULL)
  h245_pi->msg_type = H245_OpenLogChnCnf;

  return offset;
}


static const per_sequence_t RequestChannelCloseRelease_sequence[] = {
  { &hf_h245_forwardLogicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestChannelCloseRelease(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestChannelCloseRelease, RequestChannelCloseRelease_sequence);

  return offset;
}


static const per_sequence_t MultiplexEntrySendRelease_sequence[] = {
  { &hf_h245_multiplexTableEntryNumbers, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MultiplexEntrySendRelease(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MultiplexEntrySendRelease, MultiplexEntrySendRelease_sequence);

  return offset;
}


static const per_sequence_t RequestMultiplexEntryRelease_sequence[] = {
  { &hf_h245_entryNumbers   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_RequestMultiplexEntryRelease(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestMultiplexEntryRelease, RequestMultiplexEntryRelease_sequence);

  return offset;
}


static const per_sequence_t RequestModeRelease_sequence[] = {
  { NULL, ASN1_EXTENSION_ROOT, 0, NULL }
};

static int
dissect_h245_RequestModeRelease(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_RequestModeRelease, RequestModeRelease_sequence);

  return offset;
}


static const per_sequence_t T_videoNotDecodedMBs_sequence[] = {
  { &hf_h245_firstMB_1_8192 , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_8192 },
  { &hf_h245_numberOfMBs    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_8192 },
  { &hf_h245_temporalReference_0_255, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_videoNotDecodedMBs(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_videoNotDecodedMBs, T_videoNotDecodedMBs_sequence);

  return offset;
}


static const value_string h245_Mi_type_vals[] = {
  {   0, "logicalChannelActive" },
  {   1, "logicalChannelInactive" },
  {   2, "multipointConference" },
  {   3, "cancelMultipointConference" },
  {   4, "multipointZeroComm" },
  {   5, "cancelMultipointZeroComm" },
  {   6, "multipointSecondaryStatus" },
  {   7, "cancelMultipointSecondaryStatus" },
  {   8, "videoIndicateReadyToActivate" },
  {   9, "videoTemporalSpatialTradeOff" },
  {  10, "videoNotDecodedMBs" },
  {  11, "transportCapability" },
  { 0, NULL }
};

static const per_choice_t Mi_type_choice[] = {
  {   0, &hf_h245_logicalChannelActive, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_logicalChannelInactive, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_multipointConference, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_cancelMultipointConference, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_multipointZeroComm, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_cancelMultipointZeroComm, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_multipointSecondaryStatus, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   7, &hf_h245_cancelMultipointSecondaryStatus, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   8, &hf_h245_videoIndicateReadyToActivate, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   9, &hf_h245_videoTemporalSpatialTradeOff, ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_0_31 },
  {  10, &hf_h245_videoNotDecodedMBs, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_videoNotDecodedMBs },
  {  11, &hf_h245_transportCapability, ASN1_NOT_EXTENSION_ROOT, dissect_h245_TransportCapability },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Mi_type(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Mi_type, Mi_type_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t MiscellaneousIndication_sequence[] = {
  { &hf_h245_logicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_mi_type        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Mi_type },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MiscellaneousIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MiscellaneousIndication, MiscellaneousIndication_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_0_3(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 3U, NULL, FALSE);

  return offset;
}



static int
dissect_h245_INTEGER_0_7(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 7U, NULL, FALSE);

  return offset;
}


static const per_sequence_t JitterIndication_sequence[] = {
  { &hf_h245_scope          , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Scope },
  { &hf_h245_estimatedReceivedJitterMantissa, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_3 },
  { &hf_h245_estimatedReceivedJitterExponent, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_7 },
  { &hf_h245_skippedFrameCount, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_15 },
  { &hf_h245_additionalDecoderBuffer, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_262143 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_JitterIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_JitterIndication, JitterIndication_sequence);

  return offset;
}


static const per_sequence_t H223SkewIndication_sequence[] = {
  { &hf_h245_logicalChannelNumber1, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_logicalChannelNumber2, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_skew           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_4095 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H223SkewIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H223SkewIndication, H223SkewIndication_sequence);

  return offset;
}


static const value_string h245_Ind_clockRecovery_vals[] = {
  {   0, "nullClockRecovery" },
  {   1, "srtsClockRecovery" },
  {   2, "adaptiveClockRecovery" },
  { 0, NULL }
};

static const per_choice_t Ind_clockRecovery_choice[] = {
  {   0, &hf_h245_nullClockRecoveryflag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_srtsClockRecovery, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_adaptiveClockRecoveryFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Ind_clockRecovery(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Ind_clockRecovery, Ind_clockRecovery_choice,
                                 NULL);

  return offset;
}


static const value_string h245_Ind_errorCorrection_vals[] = {
  {   0, "nullErrorCorrection" },
  {   1, "longInterleaver" },
  {   2, "shortInterleaver" },
  {   3, "errorCorrectionOnly" },
  { 0, NULL }
};

static const per_choice_t Ind_errorCorrection_choice[] = {
  {   0, &hf_h245_nullErrorCorrectionFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_longInterleaverFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_shortInterleaverFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_errorCorrectionOnlyFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Ind_errorCorrection(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Ind_errorCorrection, Ind_errorCorrection_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t Ind_aal1_sequence[] = {
  { &hf_h245_ind_clockRecovery, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Ind_clockRecovery },
  { &hf_h245_ind_errorCorrection, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Ind_errorCorrection },
  { &hf_h245_structuredDataTransfer, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_partiallyFilledCells, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Ind_aal1(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Ind_aal1, Ind_aal1_sequence);

  return offset;
}


static const per_sequence_t Ind_aal5_sequence[] = {
  { &hf_h245_forwardMaximumSDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_backwardMaximumSDUSize, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Ind_aal5(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Ind_aal5, Ind_aal5_sequence);

  return offset;
}


static const value_string h245_Ind_aal_vals[] = {
  {   0, "aal1" },
  {   1, "aal5" },
  { 0, NULL }
};

static const per_choice_t Ind_aal_choice[] = {
  {   0, &hf_h245_ind_aal1       , ASN1_EXTENSION_ROOT    , dissect_h245_Ind_aal1 },
  {   1, &hf_h245_ind_aal5       , ASN1_EXTENSION_ROOT    , dissect_h245_Ind_aal5 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Ind_aal(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Ind_aal, Ind_aal_choice,
                                 NULL);

  return offset;
}


static const value_string h245_Ind_multiplex_vals[] = {
  {   0, "noMultiplex" },
  {   1, "transportStream" },
  {   2, "programStream" },
  { 0, NULL }
};

static const per_choice_t Ind_multiplex_choice[] = {
  {   0, &hf_h245_noMultiplex    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_transportStream, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_programStreamFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_Ind_multiplex(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_Ind_multiplex, Ind_multiplex_choice,
                                 NULL);

  return offset;
}


static const value_string h245_IndR_multiplex_vals[] = {
  {   0, "noMultiplex" },
  {   1, "transportStream" },
  {   2, "programStream" },
  { 0, NULL }
};

static const per_choice_t IndR_multiplex_choice[] = {
  {   0, &hf_h245_noMultiplex    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_transportStream, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_programStreamFlag, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_IndR_multiplex(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_IndR_multiplex, IndR_multiplex_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t Ind_reverseParameters_sequence[] = {
  { &hf_h245_bitRate        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65535 },
  { &hf_h245_bitRateLockedToPCRClock, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_bitRateLockedToNetworkClock, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_indr_multiplex , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_IndR_multiplex },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Ind_reverseParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Ind_reverseParameters, Ind_reverseParameters_sequence);

  return offset;
}


static const per_sequence_t NewATMVCIndication_sequence[] = {
  { &hf_h245_resourceID     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_65535 },
  { &hf_h245_bitRate        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65535 },
  { &hf_h245_bitRateLockedToPCRClock, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_bitRateLockedToNetworkClock, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_BOOLEAN },
  { &hf_h245_ind_aal        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Ind_aal },
  { &hf_h245_ind_multiplex  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Ind_multiplex },
  { &hf_h245_ind_reverseParameters, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_Ind_reverseParameters },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_NewATMVCIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_NewATMVCIndication, NewATMVCIndication_sequence);

  return offset;
}


static const value_string h245_T_userInputSupportIndication_vals[] = {
  {   0, "nonStandard" },
  {   1, "basicString" },
  {   2, "iA5String" },
  {   3, "generalString" },
  {   4, "encryptedBasicString" },
  {   5, "encryptedIA5String" },
  {   6, "encryptedGeneralString" },
  { 0, NULL }
};

static const per_choice_t T_userInputSupportIndication_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_basicString    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_iA5String      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   3, &hf_h245_generalString  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   4, &hf_h245_encryptedBasicString, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   5, &hf_h245_encryptedIA5String, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {   6, &hf_h245_encryptedGeneralString, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_T_userInputSupportIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_T_userInputSupportIndication, T_userInputSupportIndication_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_T_signalType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_restricted_character_string(tvb, offset, actx, hf_index,
                                                      1, 1, FALSE, "0123456789#*ABCD!", 17,
                                                      NULL);

  return offset;
}


static const per_sequence_t T_rtp_sequence[] = {
  { &hf_h245_timestamp      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_4294967295 },
  { &hf_h245_expirationTime , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_0_4294967295 },
  { &hf_h245_logicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_rtp(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_rtp, T_rtp_sequence);

  return offset;
}



static int
dissect_h245_IV8(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       8, 8, FALSE, NULL);

  return offset;
}



static int
dissect_h245_IV16(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       16, 16, FALSE, NULL);

  return offset;
}


static const per_sequence_t Params_sequence[] = {
  { &hf_h245_iv8            , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_IV8 },
  { &hf_h245_iv16           , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_IV16 },
  { &hf_h245_iv             , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OCTET_STRING },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Params(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Params, Params_sequence);

  return offset;
}



static int
dissect_h245_OCTET_STRING_SIZE_1(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 1, FALSE, NULL);

  return offset;
}


static const per_sequence_t T_signal_sequence[] = {
  { &hf_h245_signalType     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T_signalType },
  { &hf_h245_duration       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_INTEGER_1_65535 },
  { &hf_h245_rtp            , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_rtp },
  { &hf_h245_rtpPayloadIndication, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_NULL },
  { &hf_h245_paramS         , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_Params },
  { &hf_h245_encryptedSignalType, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_OCTET_STRING_SIZE_1 },
  { &hf_h245_algorithmOID   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_OBJECT_IDENTIFIER },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_signal(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_signal, T_signal_sequence);

  return offset;
}


static const per_sequence_t Si_rtp_sequence[] = {
  { &hf_h245_logicalChannelNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_Si_rtp(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_Si_rtp, Si_rtp_sequence);

  return offset;
}


static const per_sequence_t T_signalUpdate_sequence[] = {
  { &hf_h245_duration       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_65535 },
  { &hf_h245_si_rtp         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_Si_rtp },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_signalUpdate(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_signalUpdate, T_signalUpdate_sequence);

  return offset;
}


static const per_sequence_t EncryptedAlphanumeric_sequence[] = {
  { &hf_h245_algorithmOID   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OBJECT_IDENTIFIER },
  { &hf_h245_paramS         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_Params },
  { &hf_h245_encrypted      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_OCTET_STRING },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_EncryptedAlphanumeric(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_EncryptedAlphanumeric, EncryptedAlphanumeric_sequence);

  return offset;
}


static const per_sequence_t T_extendedAlphanumeric_sequence[] = {
  { &hf_h245_alphanumeric   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_GeneralString },
  { &hf_h245_rtpPayloadIndication, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_NULL },
  { &hf_h245_encryptedAlphanumeric, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h245_EncryptedAlphanumeric },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_extendedAlphanumeric(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_extendedAlphanumeric, T_extendedAlphanumeric_sequence);

  return offset;
}


static const value_string h245_UserInputIndication_vals[] = {
  {   0, "nonStandard" },
  {   1, "alphanumeric" },
  {   2, "userInputSupportIndication" },
  {   3, "signal" },
  {   4, "signalUpdate" },
  {   5, "extendedAlphanumeric" },
  {   6, "encryptedAlphanumeric" },
  {   7, "genericInformation" },
  { 0, NULL }
};

static const per_choice_t UserInputIndication_choice[] = {
  {   0, &hf_h245_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardParameter },
  {   1, &hf_h245_alphanumeric   , ASN1_EXTENSION_ROOT    , dissect_h245_GeneralString },
  {   2, &hf_h245_userInputSupportIndication, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_userInputSupportIndication },
  {   3, &hf_h245_signal         , ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_signal },
  {   4, &hf_h245_signalUpdate   , ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_signalUpdate },
  {   5, &hf_h245_extendedAlphanumeric, ASN1_NOT_EXTENSION_ROOT, dissect_h245_T_extendedAlphanumeric },
  {   6, &hf_h245_encryptedAlphanumeric, ASN1_NOT_EXTENSION_ROOT, dissect_h245_EncryptedAlphanumeric },
  {   7, &hf_h245_genericInformation, ASN1_NOT_EXTENSION_ROOT, dissect_h245_SEQUENCE_OF_GenericInformation },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_UserInputIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_UserInputIndication, UserInputIndication_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t H2250MaximumSkewIndication_sequence[] = {
  { &hf_h245_logicalChannelNumber1, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_logicalChannelNumber2, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_LogicalChannelNumber },
  { &hf_h245_maximumSkew    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_4095 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_H2250MaximumSkewIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_H2250MaximumSkewIndication, H2250MaximumSkewIndication_sequence);

  return offset;
}


static const per_sequence_t MCLocationIndication_sequence[] = {
  { &hf_h245_signalAddress  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TransportAddress },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MCLocationIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MCLocationIndication, MCLocationIndication_sequence);

  return offset;
}



static int
dissect_h245_INTEGER_0_9(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 9U, NULL, FALSE);

  return offset;
}


static const per_sequence_t TerminalYouAreSeeingInSubPictureNumber_sequence[] = {
  { &hf_h245_terminalNumber , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_TerminalNumber },
  { &hf_h245_subPictureNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
  { &hf_h245_mcuNumber      , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h245_McuNumber },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_TerminalYouAreSeeingInSubPictureNumber(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_TerminalYouAreSeeingInSubPictureNumber, TerminalYouAreSeeingInSubPictureNumber_sequence);

  return offset;
}


static const per_sequence_t VideoIndicateCompose_sequence[] = {
  { &hf_h245_compositionNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_0_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_VideoIndicateCompose(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_VideoIndicateCompose, VideoIndicateCompose_sequence);

  return offset;
}


static const value_string h245_ConferenceIndication_vals[] = {
  {   0, "sbeNumber" },
  {   1, "terminalNumberAssign" },
  {   2, "terminalJoinedConference" },
  {   3, "terminalLeftConference" },
  {   4, "seenByAtLeastOneOther" },
  {   5, "cancelSeenByAtLeastOneOther" },
  {   6, "seenByAll" },
  {   7, "cancelSeenByAll" },
  {   8, "terminalYouAreSeeing" },
  {   9, "requestForFloor" },
  {  10, "withdrawChairToken" },
  {  11, "floorRequested" },
  {  12, "terminalYouAreSeeingInSubPictureNumber" },
  {  13, "videoIndicateCompose" },
  {  14, "masterMCU" },
  {  15, "cancelMasterMCU" },
  { 0, NULL }
};

static const per_choice_t ConferenceIndication_choice[] = {
  {   0, &hf_h245_sbeNumber      , ASN1_EXTENSION_ROOT    , dissect_h245_INTEGER_0_9 },
  {   1, &hf_h245_terminalNumberAssign, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalLabel },
  {   2, &hf_h245_terminalJoinedConference, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalLabel },
  {   3, &hf_h245_terminalLeftConference, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalLabel },
  {   4, &hf_h245_seenByAtLeastOneOther, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   5, &hf_h245_cancelSeenByAtLeastOneOther, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   6, &hf_h245_seenByAll      , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   7, &hf_h245_cancelSeenByAll, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   8, &hf_h245_terminalYouAreSeeing, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalLabel },
  {   9, &hf_h245_requestForFloor, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {  10, &hf_h245_withdrawChairToken, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  11, &hf_h245_floorRequested , ASN1_NOT_EXTENSION_ROOT, dissect_h245_TerminalLabel },
  {  12, &hf_h245_terminalYouAreSeeingInSubPictureNumber, ASN1_NOT_EXTENSION_ROOT, dissect_h245_TerminalYouAreSeeingInSubPictureNumber },
  {  13, &hf_h245_videoIndicateCompose, ASN1_NOT_EXTENSION_ROOT, dissect_h245_VideoIndicateCompose },
  {  14, &hf_h245_masterMCU      , ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  {  15, &hf_h245_cancelMasterMCU, ASN1_NOT_EXTENSION_ROOT, dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_ConferenceIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_ConferenceIndication, ConferenceIndication_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_OCTET_STRING_SIZE_1_256(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 256, FALSE, NULL);

  return offset;
}


static const per_sequence_t VendorIdentification_sequence[] = {
  { &hf_h245_vendor         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_NonStandardIdentifier },
  { &hf_h245_productNumber  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OCTET_STRING_SIZE_1_256 },
  { &hf_h245_versionNumber  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_OCTET_STRING_SIZE_1_256 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_VendorIdentification(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_VendorIdentification, VendorIdentification_sequence);

  return offset;
}


static const value_string h245_FunctionNotSupportedCause_vals[] = {
  {   0, "syntaxError" },
  {   1, "semanticError" },
  {   2, "unknownFunction" },
  { 0, NULL }
};

static const per_choice_t FunctionNotSupportedCause_choice[] = {
  {   0, &hf_h245_syntaxError    , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   1, &hf_h245_semanticError  , ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  {   2, &hf_h245_unknownFunction, ASN1_EXTENSION_ROOT    , dissect_h245_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_FunctionNotSupportedCause(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_FunctionNotSupportedCause, FunctionNotSupportedCause_choice,
                                 NULL);

  return offset;
}



static int
dissect_h245_T_returnedFunction(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 994 "../../asn1/h245/h245.cnf"
  tvbuff_t *next_tvb = NULL;
  proto_item *item;
 // proto_tree *subtree;
  h245_packet_info *saved_h245_pi;

  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, &next_tvb);


 if (next_tvb && tvb_length(next_tvb)) {
	saved_h245_pi = h245_pi;
	h245_pi = NULL;
	/*item = proto_tree_add_text(tree, next_tvb, 0, -1,"The returned function");
	subtree = proto_item_add_subtree(item, ett_h245_returnedFunction);
	PROTO_ITEM_SET_GENERATED(item);*/
	dissect_h245_MultimediaSystemControlMessage(next_tvb, 0, actx,  hf_h245_pdu_type);
	h245_pi = saved_h245_pi;
 }



  return offset;
}


static const per_sequence_t FunctionNotSupported_sequence[] = {
  { &hf_h245_fns_cause      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_FunctionNotSupportedCause },
  { &hf_h245_returnedFunction, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h245_T_returnedFunction },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_FunctionNotSupported(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_FunctionNotSupported, FunctionNotSupported_sequence);

  return offset;
}


static const per_sequence_t T_crcDesired_sequence[] = {
  { NULL, ASN1_EXTENSION_ROOT, 0, NULL }
};

static int
dissect_h245_T_crcDesired(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_crcDesired, T_crcDesired_sequence);

  return offset;
}


static const per_sequence_t T_excessiveError_sequence[] = {
  { &hf_h245_connectionIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_ConnectionIdentifier },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_T_excessiveError(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_T_excessiveError, T_excessiveError_sequence);

  return offset;
}


static const value_string h245_MultilinkIndication_vals[] = {
  {   0, "nonStandard" },
  {   1, "crcDesired" },
  {   2, "excessiveError" },
  { 0, NULL }
};

static const per_choice_t MultilinkIndication_choice[] = {
  {   0, &hf_h245_nonStandardMsg , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardMessage },
  {   1, &hf_h245_crcDesired     , ASN1_EXTENSION_ROOT    , dissect_h245_T_crcDesired },
  {   2, &hf_h245_excessiveError , ASN1_EXTENSION_ROOT    , dissect_h245_T_excessiveError },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MultilinkIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MultilinkIndication, MultilinkIndication_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t LogicalChannelRateRelease_sequence[] = {
  { NULL, ASN1_EXTENSION_ROOT, 0, NULL }
};

static int
dissect_h245_LogicalChannelRateRelease(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_LogicalChannelRateRelease, LogicalChannelRateRelease_sequence);

  return offset;
}


static const per_sequence_t FlowControlIndication_sequence[] = {
  { &hf_h245_scope          , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Scope },
  { &hf_h245_restriction    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_Restriction },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_FlowControlIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_FlowControlIndication, FlowControlIndication_sequence);

  return offset;
}


static const per_sequence_t MobileMultilinkReconfigurationIndication_sequence[] = {
  { &hf_h245_sampleSize     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { &hf_h245_samplesPerFrame, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_INTEGER_1_255 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h245_MobileMultilinkReconfigurationIndication(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h245_MobileMultilinkReconfigurationIndication, MobileMultilinkReconfigurationIndication_sequence);

  return offset;
}


static const value_string h245_IndicationMessage_vals[] = {
  { IndicationMessage_nonStandard, "nonStandard" },
  { IndicationMessage_functionNotUnderstood, "functionNotUnderstood" },
  { IndicationMessage_masterSlaveDeterminationRelease, "masterSlaveDeterminationRelease" },
  { IndicationMessage_terminalCapabilitySetRelease, "terminalCapabilitySetRelease" },
  { IndicationMessage_openLogicalChannelConfirm, "openLogicalChannelConfirm" },
  { IndicationMessage_requestChannelCloseRelease, "requestChannelCloseRelease" },
  { IndicationMessage_multiplexEntrySendRelease, "multiplexEntrySendRelease" },
  { IndicationMessage_requestMultiplexEntryRelease, "requestMultiplexEntryRelease" },
  { IndicationMessage_requestModeRelease, "requestModeRelease" },
  { IndicationMessage_miscellaneousIndication, "miscellaneousIndication" },
  { IndicationMessage_jitterIndication, "jitterIndication" },
  { IndicationMessage_h223SkewIndication, "h223SkewIndication" },
  { IndicationMessage_newATMVCIndication, "newATMVCIndication" },
  { IndicationMessage_userInput, "userInput" },
  { IndicationMessage_h2250MaximumSkewIndication, "h2250MaximumSkewIndication" },
  { IndicationMessage_mcLocationIndication, "mcLocationIndication" },
  { IndicationMessage_conferenceIndication, "conferenceIndication" },
  { IndicationMessage_vendorIdentification, "vendorIdentification" },
  { IndicationMessage_functionNotSupported, "functionNotSupported" },
  { IndicationMessage_multilinkIndication, "multilinkIndication" },
  { IndicationMessage_logicalChannelRateRelease, "logicalChannelRateRelease" },
  { IndicationMessage_flowControlIndication, "flowControlIndication" },
  { IndicationMessage_mobileMultilinkReconfigurationIndication, "mobileMultilinkReconfigurationIndication" },
  { IndicationMessage_genericIndication, "genericIndication" },
  { 0, NULL }
};

static const per_choice_t IndicationMessage_choice[] = {
  { IndicationMessage_nonStandard, &hf_h245_nonStandardMsg , ASN1_EXTENSION_ROOT    , dissect_h245_NonStandardMessage },
  { IndicationMessage_functionNotUnderstood, &hf_h245_functionNotUnderstood, ASN1_EXTENSION_ROOT    , dissect_h245_FunctionNotUnderstood },
  { IndicationMessage_masterSlaveDeterminationRelease, &hf_h245_masterSlaveDeterminationRelease, ASN1_EXTENSION_ROOT    , dissect_h245_MasterSlaveDeterminationRelease },
  { IndicationMessage_terminalCapabilitySetRelease, &hf_h245_terminalCapabilitySetRelease, ASN1_EXTENSION_ROOT    , dissect_h245_TerminalCapabilitySetRelease },
  { IndicationMessage_openLogicalChannelConfirm, &hf_h245_openLogicalChannelConfirm, ASN1_EXTENSION_ROOT    , dissect_h245_OpenLogicalChannelConfirm },
  { IndicationMessage_requestChannelCloseRelease, &hf_h245_requestChannelCloseRelease, ASN1_EXTENSION_ROOT    , dissect_h245_RequestChannelCloseRelease },
  { IndicationMessage_multiplexEntrySendRelease, &hf_h245_multiplexEntrySendRelease, ASN1_EXTENSION_ROOT    , dissect_h245_MultiplexEntrySendRelease },
  { IndicationMessage_requestMultiplexEntryRelease, &hf_h245_requestMultiplexEntryRelease, ASN1_EXTENSION_ROOT    , dissect_h245_RequestMultiplexEntryRelease },
  { IndicationMessage_requestModeRelease, &hf_h245_requestModeRelease, ASN1_EXTENSION_ROOT    , dissect_h245_RequestModeRelease },
  { IndicationMessage_miscellaneousIndication, &hf_h245_miscellaneousIndication, ASN1_EXTENSION_ROOT    , dissect_h245_MiscellaneousIndication },
  { IndicationMessage_jitterIndication, &hf_h245_jitterIndication, ASN1_EXTENSION_ROOT    , dissect_h245_JitterIndication },
  { IndicationMessage_h223SkewIndication, &hf_h245_h223SkewIndication, ASN1_EXTENSION_ROOT    , dissect_h245_H223SkewIndication },
  { IndicationMessage_newATMVCIndication, &hf_h245_newATMVCIndication, ASN1_EXTENSION_ROOT    , dissect_h245_NewATMVCIndication },
  { IndicationMessage_userInput, &hf_h245_userInput      , ASN1_EXTENSION_ROOT    , dissect_h245_UserInputIndication },
  { IndicationMessage_h2250MaximumSkewIndication, &hf_h245_h2250MaximumSkewIndication, ASN1_NOT_EXTENSION_ROOT, dissect_h245_H2250MaximumSkewIndication },
  { IndicationMessage_mcLocationIndication, &hf_h245_mcLocationIndication, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MCLocationIndication },
  { IndicationMessage_conferenceIndication, &hf_h245_conferenceIndication, ASN1_NOT_EXTENSION_ROOT, dissect_h245_ConferenceIndication },
  { IndicationMessage_vendorIdentification, &hf_h245_vendorIdentification, ASN1_NOT_EXTENSION_ROOT, dissect_h245_VendorIdentification },
  { IndicationMessage_functionNotSupported, &hf_h245_functionNotSupported, ASN1_NOT_EXTENSION_ROOT, dissect_h245_FunctionNotSupported },
  { IndicationMessage_multilinkIndication, &hf_h245_multilinkIndication, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MultilinkIndication },
  { IndicationMessage_logicalChannelRateRelease, &hf_h245_logicalChannelRateRelease, ASN1_NOT_EXTENSION_ROOT, dissect_h245_LogicalChannelRateRelease },
  { IndicationMessage_flowControlIndication, &hf_h245_flowControlIndication, ASN1_NOT_EXTENSION_ROOT, dissect_h245_FlowControlIndication },
  { IndicationMessage_mobileMultilinkReconfigurationIndication, &hf_h245_mobileMultilinkReconfigurationIndication, ASN1_NOT_EXTENSION_ROOT, dissect_h245_MobileMultilinkReconfigurationIndication },
  { IndicationMessage_genericIndication, &hf_h245_genericIndication, ASN1_NOT_EXTENSION_ROOT, dissect_h245_GenericMessage },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_IndicationMessage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
//#line 435 "../../asn1/h245/h245.cnf"
  gint32 value;
   printf(" %s (%d)\n", val_to_str(	h_245_message_value.msg_value, h245_MultimediaSystemControlMessage_vals, "<unknown>"),	h_245_message_value.msg_value);
   printf(" %s :", val_to_str(	h_245_message_value.msg_value, h245_MultimediaSystemControlMessage_vals, "<unknown>"));
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_IndicationMessage, IndicationMessage_choice,
                                 &value);

        if ( h245_shorttypes == TRUE )
	        {
	        	//col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, 
					printf("%s\n ",
				val_to_str(value, h245_IndicationMessage_short_vals, "<unknown>"));
		}
		else
		{
	        	//col_prepend_fstr(actx->pinfo->cinfo, COL_INFO, 
			printf("%s\n ",
				val_to_str(value, h245_IndicationMessage_vals, "<unknown>"));
		}

	//col_set_fence(actx->pinfo->cinfo,COL_INFO);
    /* Add to packet info */
    if (h245_pi  !=NULL){
      if ( strlen(h245_pi->frame_label) == 0 ){
//	    g_snprintf(h245_pi->frame_label, 50, "%s", val_to_str(value, h245_IndicationMessage_short_vals, "UKN"));
	  }
   //   g_strlcat(h245_pi->comment, val_to_str(value, h245_IndicationMessage_vals, "<unknown>"), 50);

    }



  return offset;
}



static const per_choice_t MultimediaSystemControlMessage_choice[] = {
  {   0, &hf_h245_request        , ASN1_EXTENSION_ROOT    , dissect_h245_RequestMessage },
  {   1, &hf_h245_response       , ASN1_EXTENSION_ROOT    , dissect_h245_ResponseMessage },
  {   2, &hf_h245_command        , ASN1_EXTENSION_ROOT    , dissect_h245_CommandMessage },
  {   3, &hf_h245_indication     , ASN1_EXTENSION_ROOT    , dissect_h245_IndicationMessage },
  { 0, NULL, 0, NULL }
};

static int
dissect_h245_MultimediaSystemControlMessage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("PDU Type:");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h245_MultimediaSystemControlMessage, MultimediaSystemControlMessage_choice,
                                 NULL);
  /*h323_values->message_type=NULL;*/

  return offset;
}

/*--- PDUs ---*/

static void dissect_OpenLogicalChannel_PDU(tvbuff_t *tvb , packet_info *pinfo) {
  asn1_ctx_t asn1_ctx;
  asn1_ctx_init(&asn1_ctx, ASN1_ENC_PER, TRUE, pinfo);
  dissect_h245_OpenLogicalChannel(tvb, 0, &asn1_ctx, hf_h245_OpenLogicalChannel_PDU);
}

void asn1_ctx_init(asn1_ctx_t *actx, asn1_enc_e encoding, gboolean aligned, packet_info *pinfo) {
  memset(actx, '\0', sizeof(*actx));
  actx->signature = ASN1_CTX_SIGNATURE;
  actx->encoding = encoding;
  actx->aligned = aligned;
 // actx->pinfo = pinfo;
}
static void
dissect_h245_h245(tvbuff_t *tvb, packet_info *pinfo)
{
	proto_item *it;
	//proto_tree *tr;
	guint32 offset=0;
	asn1_ctx_t asn1_ctx;

	fast_start = FALSE;
	/* Clean up from any previous packet dissection */
	upcoming_olc = NULL;
	upcoming_channel = NULL;
	codec_type = NULL;

	//col_set_str(pinfo->cinfo, COL_PROTOCOL, 
	printf("%s\n",PSNAME);

	//it=proto_tree_add_protocol_format(parent_tree, proto_h245, tvb, 0, tvb_length(tvb), PSNAME);
	//tr=proto_item_add_subtree(it, ett_h245);

	/* assume that whilst there is more tvb data, there are more h245 commands */
	while ( tvb_length_remaining( tvb, offset>>3 )>0 ){
		//CLEANUP_PUSH(reset_h245_pi, NULL);
		h245_pi=(h245_packet_info *)malloc(sizeof(h245_packet_info));
		init_h245_packet_info(h245_pi);
		asn1_ctx_init(&asn1_ctx, ASN1_ENC_PER, TRUE, pinfo);
		offset = dissect_h245_MultimediaSystemControlMessage(tvb, offset, &asn1_ctx, hf_h245_pdu_type);
		//tap_queue_packet(h245dg_tap, pinfo, h245_pi);
		offset = (offset+0x07) & 0xfffffff8;
		//CLEANUP_CALL_AND_POP;
	}
}

void
dissect_h245_FastStart_OLC(tvbuff_t *tvb, packet_info *pinfo , char *codec_str) {

  fast_start = TRUE;
  /* Clean up from any previous packet dissection */
  upcoming_olc = NULL;
  upcoming_channel = NULL;
  codec_type = NULL;

  dissect_OpenLogicalChannel_PDU(tvb, pinfo);

  if (h245_pi != NULL)
	  h245_pi->msg_type = H245_OpenLogChn;

  if (codec_str && codec_type){
      //  g_strlcpy(codec_str, codec_type, 50);
  }

}

static void init_h245_packet_info(h245_packet_info *pi)
{
        if(pi == NULL) {
                return;
        }

        pi->msg_type = H245_OTHER;
		pi->frame_label[0] = '\0';
		//g_snprintf(pi->comment, sizeof(pi->comment), "H245 ");
}


    


                          //H.225 PROTOCOL
static int hf_h225_H323_UserInformation_PDU = -1;  /* H323_UserInformation */
static int hf_h225_h225_ExtendedAliasAddress_PDU = -1;  /* ExtendedAliasAddress */
static int hf_h225_RasMessage_PDU = -1;           /* RasMessage */
static int hf_h225_h323_uu_pdu = -1;              /* H323_UU_PDU */
static int hf_h225_user_data = -1;                /* T_user_data */
static int hf_h225_protocol_discriminator = -1;   /* INTEGER_0_255 */
static int hf_h225_user_information = -1;         /* OCTET_STRING_SIZE_1_131 */
static int hf_h225_h323_message_body = -1;        /* T_h323_message_body */
static int hf_h225_setup = -1;                    /* Setup_UUIE */
static int hf_h225_callProceeding = -1;           /* CallProceeding_UUIE */
static int hf_h225_connect = -1;                  /* Connect_UUIE */
static int hf_h225_alerting = -1;                 /* Alerting_UUIE */
static int hf_h225_information = -1;              /* Information_UUIE */
static int hf_h225_releaseComplete = -1;          /* ReleaseComplete_UUIE */
static int hf_h225_facility = -1;                 /* Facility_UUIE */
static int hf_h225_progress = -1;                 /* Progress_UUIE */
static int hf_h225_empty_flg = -1;                /* T_empty_flg */
static int hf_h225_status = -1;                   /* Status_UUIE */
static int hf_h225_statusInquiry = -1;            /* StatusInquiry_UUIE */
static int hf_h225_setupAcknowledge = -1;         /* SetupAcknowledge_UUIE */
static int hf_h225_notify = -1;                   /* Notify_UUIE */
static int hf_h225_nonStandardData = -1;          /* NonStandardParameter */
static int hf_h225_h4501SupplementaryService = -1;  /* T_h4501SupplementaryService */
static int hf_h225_h4501SupplementaryService_item = -1;  /* T_h4501SupplementaryService_item */
static int hf_h225_h245Tunnelling = -1;           /* T_h245Tunnelling */
static int hf_h225_H245Control_item = -1;         /* H245Control_item */
static int hf_h225_h245Control = -1;              /* H245Control */
static int hf_h225_nonStandardControl = -1;       /* SEQUENCE_OF_NonStandardParameter */
static int hf_h225_nonStandardControl_item = -1;  /* NonStandardParameter */
static int hf_h225_callLinkage = -1;              /* CallLinkage */
static int hf_h225_tunnelledSignallingMessage = -1;  /* T_tunnelledSignallingMessage */
static int hf_h225_tunnelledProtocolID = -1;      /* TunnelledProtocol */
static int hf_h225_messageContent = -1;           /* T_messageContent */
static int hf_h225_messageContent_item = -1;      /* T_messageContent_item */
static int hf_h225_tunnellingRequired = -1;       /* NULL */
static int hf_h225_provisionalRespToH245Tunnelling = -1;  /* NULL */
static int hf_h225_stimulusControl = -1;          /* StimulusControl */
static int hf_h225_genericData = -1;              /* SEQUENCE_OF_GenericData */
static int hf_h225_genericData_item = -1;         /* GenericData */
static int hf_h225_nonStandard = -1;              /* NonStandardParameter */
static int hf_h225_isText = -1;                   /* NULL */
static int hf_h225_h248Message = -1;              /* OCTET_STRING */
static int hf_h225_protocolIdentifier = -1;       /* ProtocolIdentifier */
static int hf_h225_uUIE_destinationInfo = -1;     /* EndpointType */
static int hf_h225_h245Address = -1;              /* H245TransportAddress */
static int hf_h225_callIdentifier = -1;           /* CallIdentifier */
static int hf_h225_h245SecurityMode = -1;         /* H245Security */
static int hf_h225_tokens = -1;                   /* SEQUENCE_OF_ClearToken */
static int hf_h225_tokens_item = -1;              /* ClearToken */
static int hf_h225_cryptoTokens = -1;             /* SEQUENCE_OF_CryptoH323Token */
static int hf_h225_cryptoTokens_item = -1;        /* CryptoH323Token */
static int hf_h225_fastStart = -1;                /* FastStart */
static int hf_h225_multipleCalls = -1;            /* BOOLEAN */
static int hf_h225_maintainConnection = -1;       /* BOOLEAN */
static int hf_h225_alertingAddress = -1;          /* SEQUENCE_OF_AliasAddress */
static int hf_h225_alertingAddress_item = -1;     /* AliasAddress */
static int hf_h225_presentationIndicator = -1;    /* PresentationIndicator */
static int hf_h225_screeningIndicator = -1;       /* ScreeningIndicator */
static int hf_h225_fastConnectRefused = -1;       /* NULL */
static int hf_h225_serviceControl = -1;           /* SEQUENCE_OF_ServiceControlSession */
static int hf_h225_serviceControl_item = -1;      /* ServiceControlSession */
static int hf_h225_capacity = -1;                 /* CallCapacity */
static int hf_h225_featureSet = -1;               /* FeatureSet */
static int hf_h225_displayName = -1;              /* SEQUENCE_OF_DisplayName */
static int hf_h225_displayName_item = -1;         /* DisplayName */
static int hf_h225_conferenceID = -1;             /* ConferenceIdentifier */
static int hf_h225_language = -1;                 /* Language */
static int hf_h225_connectedAddress = -1;         /* SEQUENCE_OF_AliasAddress */
static int hf_h225_connectedAddress_item = -1;    /* AliasAddress */
static int hf_h225_circuitInfo = -1;              /* CircuitInfo */
static int hf_h225_releaseCompleteReason = -1;    /* ReleaseCompleteReason */
static int hf_h225_busyAddress = -1;              /* SEQUENCE_OF_AliasAddress */
static int hf_h225_busyAddress_item = -1;         /* AliasAddress */
static int hf_h225_destinationInfo = -1;          /* EndpointType */
static int hf_h225_noBandwidth = -1;              /* NULL */
static int hf_h225_gatekeeperResources = -1;      /* NULL */
static int hf_h225_unreachableDestination = -1;   /* NULL */
static int hf_h225_destinationRejection = -1;     /* NULL */
static int hf_h225_invalidRevision = -1;          /* NULL */
static int hf_h225_noPermission = -1;             /* NULL */
static int hf_h225_unreachableGatekeeper = -1;    /* NULL */
static int hf_h225_gatewayResources = -1;         /* NULL */
static int hf_h225_badFormatAddress = -1;         /* NULL */
static int hf_h225_adaptiveBusy = -1;             /* NULL */
static int hf_h225_inConf = -1;                   /* NULL */
static int hf_h225_undefinedReason = -1;          /* NULL */
static int hf_h225_facilityCallDeflection = -1;   /* NULL */
static int hf_h225_securityDenied = -1;           /* NULL */
static int hf_h225_calledPartyNotRegistered = -1;  /* NULL */
static int hf_h225_callerNotRegistered = -1;      /* NULL */
static int hf_h225_newConnectionNeeded = -1;      /* NULL */
static int hf_h225_nonStandardReason = -1;        /* NonStandardParameter */
static int hf_h225_replaceWithConferenceInvite = -1;  /* ConferenceIdentifier */
static int hf_h225_genericDataReason = -1;        /* NULL */
static int hf_h225_neededFeatureNotSupported = -1;  /* NULL */
static int hf_h225_tunnelledSignallingRejected = -1;  /* NULL */
static int hf_h225_invalidCID = -1;               /* NULL */
static int hf_h225_rLC_securityError = -1;        /* SecurityErrors */
static int hf_h225_hopCountExceeded = -1;         /* NULL */
static int hf_h225_sourceAddress = -1;            /* SEQUENCE_OF_AliasAddress */
static int hf_h225_sourceAddress_item = -1;       /* AliasAddress */
static int hf_h225_setup_UUIE_sourceInfo = -1;    /* EndpointType */
static int hf_h225_destinationAddress = -1;       /* SEQUENCE_OF_AliasAddress */
static int hf_h225_destinationAddress_item = -1;  /* AliasAddress */
static int hf_h225_destCallSignalAddress = -1;    /* TransportAddress */
static int hf_h225_destExtraCallInfo = -1;        /* SEQUENCE_OF_AliasAddress */
static int hf_h225_destExtraCallInfo_item = -1;   /* AliasAddress */
static int hf_h225_destExtraCRV = -1;             /* SEQUENCE_OF_CallReferenceValue */
static int hf_h225_destExtraCRV_item = -1;        /* CallReferenceValue */
static int hf_h225_activeMC = -1;                 /* BOOLEAN */
static int hf_h225_conferenceGoal = -1;           /* T_conferenceGoal */
static int hf_h225_create = -1;                   /* NULL */
static int hf_h225_join = -1;                     /* NULL */
static int hf_h225_invite = -1;                   /* NULL */
static int hf_h225_capability_negotiation = -1;   /* NULL */
static int hf_h225_callIndependentSupplementaryService = -1;  /* NULL */
static int hf_h225_callServices = -1;             /* QseriesOptions */
static int hf_h225_callType = -1;                 /* CallType */
static int hf_h225_sourceCallSignalAddress = -1;  /* TransportAddress */
static int hf_h225_uUIE_remoteExtensionAddress = -1;  /* AliasAddress */
static int hf_h225_h245SecurityCapability = -1;   /* SEQUENCE_OF_H245Security */
static int hf_h225_h245SecurityCapability_item = -1;  /* H245Security */
static int hf_h225_FastStart_item = -1;           /* FastStart_item */
static int hf_h225_mediaWaitForConnect = -1;      /* BOOLEAN */
static int hf_h225_canOverlapSend = -1;           /* BOOLEAN */
static int hf_h225_endpointIdentifier = -1;       /* EndpointIdentifier */
static int hf_h225_connectionParameters = -1;     /* T_connectionParameters */
static int hf_h225_connectionType = -1;           /* ScnConnectionType */
static int hf_h225_numberOfScnConnections = -1;   /* INTEGER_0_65535 */
static int hf_h225_connectionAggregation = -1;    /* ScnConnectionAggregation */
static int hf_h225_Language_item = -1;            /* IA5String_SIZE_1_32 */
static int hf_h225_symmetricOperationRequired = -1;  /* NULL */
static int hf_h225_desiredProtocols = -1;         /* SEQUENCE_OF_SupportedProtocols */
static int hf_h225_desiredProtocols_item = -1;    /* SupportedProtocols */
static int hf_h225_neededFeatures = -1;           /* SEQUENCE_OF_FeatureDescriptor */
static int hf_h225_neededFeatures_item = -1;      /* FeatureDescriptor */
static int hf_h225_desiredFeatures = -1;          /* SEQUENCE_OF_FeatureDescriptor */
static int hf_h225_desiredFeatures_item = -1;     /* FeatureDescriptor */
static int hf_h225_supportedFeatures = -1;        /* SEQUENCE_OF_FeatureDescriptor */
static int hf_h225_supportedFeatures_item = -1;   /* FeatureDescriptor */
static int hf_h225_ParallelH245Control_item = -1;  /* ParallelH245Control_item */
static int hf_h225_parallelH245Control = -1;      /* ParallelH245Control */
static int hf_h225_additionalSourceAddresses = -1;  /* SEQUENCE_OF_ExtendedAliasAddress */
static int hf_h225_additionalSourceAddresses_item = -1;  /* ExtendedAliasAddress */
static int hf_h225_hopCount_1_31 = -1;            /* INTEGER_1_31 */
static int hf_h225_unknown = -1;                  /* NULL */
static int hf_h225_bChannel = -1;                 /* NULL */
static int hf_h225_hybrid2x64 = -1;               /* NULL */
static int hf_h225_hybrid384 = -1;                /* NULL */
static int hf_h225_hybrid1536 = -1;               /* NULL */
static int hf_h225_hybrid1920 = -1;               /* NULL */
static int hf_h225_multirate = -1;                /* NULL */
static int hf_h225_auto = -1;                     /* NULL */
static int hf_h225_none = -1;                     /* NULL */
static int hf_h225_h221 = -1;                     /* NULL */
static int hf_h225_bonded_mode1 = -1;             /* NULL */
static int hf_h225_bonded_mode2 = -1;             /* NULL */
static int hf_h225_bonded_mode3 = -1;             /* NULL */
static int hf_h225_presentationAllowed = -1;      /* NULL */
static int hf_h225_presentationRestricted = -1;   /* NULL */
static int hf_h225_addressNotAvailable = -1;      /* NULL */
static int hf_h225_alternativeAddress = -1;       /* TransportAddress */
static int hf_h225_alternativeAliasAddress = -1;  /* SEQUENCE_OF_AliasAddress */
static int hf_h225_alternativeAliasAddress_item = -1;  /* AliasAddress */
static int hf_h225_facilityReason = -1;           /* FacilityReason */
static int hf_h225_conferences = -1;              /* SEQUENCE_OF_ConferenceList */
static int hf_h225_conferences_item = -1;         /* ConferenceList */
static int hf_h225_conferenceAlias = -1;          /* AliasAddress */
static int hf_h225_routeCallToGatekeeper = -1;    /* NULL */
static int hf_h225_callForwarded = -1;            /* NULL */
static int hf_h225_routeCallToMC = -1;            /* NULL */
static int hf_h225_conferenceListChoice = -1;     /* NULL */
static int hf_h225_startH245 = -1;                /* NULL */
static int hf_h225_noH245 = -1;                   /* NULL */
static int hf_h225_newTokens = -1;                /* NULL */
static int hf_h225_featureSetUpdate = -1;         /* NULL */
static int hf_h225_forwardedElements = -1;        /* NULL */
static int hf_h225_transportedInformation = -1;   /* NULL */
static int hf_h225_h245IpAddress = -1;            /* T_h245IpAddress */
static int hf_h225_h245Ip = -1;                   /* T_h245Ip */
static int hf_h225_h245IpPort = -1;               /* T_h245IpPort */
static int hf_h225_h245IpSourceRoute = -1;        /* T_h245IpSourceRoute */
static int hf_h225_ip = -1;                       /* OCTET_STRING_SIZE_4 */
static int hf_h225_port = -1;                     /* INTEGER_0_65535 */
static int hf_h225_h245Route = -1;                /* T_h245Route */
static int hf_h225_h245Route_item = -1;           /* OCTET_STRING_SIZE_4 */
static int hf_h225_h245Routing = -1;              /* T_h245Routing */
static int hf_h225_strict = -1;                   /* NULL */
static int hf_h225_loose = -1;                    /* NULL */
static int hf_h225_h245IpxAddress = -1;           /* T_h245IpxAddress */
static int hf_h225_node = -1;                     /* OCTET_STRING_SIZE_6 */
static int hf_h225_netnum = -1;                   /* OCTET_STRING_SIZE_4 */
static int hf_h225_h245IpxPort = -1;              /* OCTET_STRING_SIZE_2 */
static int hf_h225_h245Ip6Address = -1;           /* T_h245Ip6Address */
static int hf_h225_h245Ip6 = -1;                  /* OCTET_STRING_SIZE_16 */
static int hf_h225_netBios = -1;                  /* OCTET_STRING_SIZE_16 */
static int hf_h225_nsap = -1;                     /* OCTET_STRING_SIZE_1_20 */
static int hf_h225_nonStandardAddress = -1;       /* NonStandardParameter */
static int hf_h225_ipAddress = -1;                /* T_ipAddress */
static int hf_h225_ipV4 = -1;                     /* IpV4 */
static int hf_h225_ipV4_port = -1;                /* INTEGER_0_65535 */
static int hf_h225_ipSourceRoute = -1;            /* T_ipSourceRoute */
static int hf_h225_src_route_ipV4 = -1;           /* OCTET_STRING_SIZE_4 */
static int hf_h225_ipV4_src_port = -1;            /* INTEGER_0_65535 */
static int hf_h225_route = -1;                    /* T_route */
static int hf_h225_route_item = -1;               /* OCTET_STRING_SIZE_4 */
static int hf_h225_routing = -1;                  /* T_routing */
static int hf_h225_ipxAddress = -1;               /* T_ipxAddress */
static int hf_h225_ipx_port = -1;                 /* OCTET_STRING_SIZE_2 */
static int hf_h225_ip6Address = -1;               /* T_ip6Address */
static int hf_h225_ipV6 = -1;                     /* OCTET_STRING_SIZE_16 */
static int hf_h225_ipV6_port = -1;                /* INTEGER_0_65535 */
static int hf_h225_vendor = -1;                   /* VendorIdentifier */
static int hf_h225_gatekeeper = -1;               /* GatekeeperInfo */
static int hf_h225_gateway = -1;                  /* GatewayInfo */
static int hf_h225_mcu = -1;                      /* McuInfo */
static int hf_h225_terminal = -1;                 /* TerminalInfo */
static int hf_h225_mc = -1;                       /* BOOLEAN */
static int hf_h225_undefinedNode = -1;            /* BOOLEAN */
static int hf_h225_set = -1;                      /* BIT_STRING_SIZE_32 */
static int hf_h225_supportedTunnelledProtocols = -1;  /* SEQUENCE_OF_TunnelledProtocol */
static int hf_h225_supportedTunnelledProtocols_item = -1;  /* TunnelledProtocol */
static int hf_h225_protocol = -1;                 /* SEQUENCE_OF_SupportedProtocols */
static int hf_h225_protocol_item = -1;            /* SupportedProtocols */
static int hf_h225_h310 = -1;                     /* H310Caps */
static int hf_h225_h320 = -1;                     /* H320Caps */
static int hf_h225_h321 = -1;                     /* H321Caps */
static int hf_h225_h322 = -1;                     /* H322Caps */
static int hf_h225_h323 = -1;                     /* H323Caps */
static int hf_h225_h324 = -1;                     /* H324Caps */
static int hf_h225_voice = -1;                    /* VoiceCaps */
static int hf_h225_t120_only = -1;                /* T120OnlyCaps */
static int hf_h225_nonStandardProtocol = -1;      /* NonStandardProtocol */
static int hf_h225_t38FaxAnnexbOnly = -1;         /* T38FaxAnnexbOnlyCaps */
static int hf_h225_sip = -1;                      /* SIPCaps */
static int hf_h225_dataRatesSupported = -1;       /* SEQUENCE_OF_DataRate */
static int hf_h225_dataRatesSupported_item = -1;  /* DataRate */
static int hf_h225_supportedPrefixes = -1;        /* SEQUENCE_OF_SupportedPrefix */
static int hf_h225_supportedPrefixes_item = -1;   /* SupportedPrefix */
static int hf_h225_t38FaxProtocol = -1;           /* DataProtocolCapability */
static int hf_h225_t38FaxProfile = -1;            /* T38FaxProfile */
static int hf_h225_vendorIdentifier_vendor = -1;  /* H221NonStandard */
static int hf_h225_productId = -1;                /* OCTET_STRING_SIZE_1_256 */
static int hf_h225_versionId = -1;                /* OCTET_STRING_SIZE_1_256 */
static int hf_h225_enterpriseNumber = -1;         /* OBJECT_IDENTIFIER */
static int hf_h225_t35CountryCode = -1;           /* T_t35CountryCode */
static int hf_h225_t35Extension = -1;             /* T_t35Extension */
static int hf_h225_manufacturerCode = -1;         /* T_manufacturerCode */
static int hf_h225_tunnelledProtocol_id = -1;     /* TunnelledProtocol_id */
static int hf_h225_tunnelledProtocolObjectID = -1;  /* T_tunnelledProtocolObjectID */
static int hf_h225_tunnelledProtocolAlternateID = -1;  /* TunnelledProtocolAlternateIdentifier */
static int hf_h225_subIdentifier = -1;            /* IA5String_SIZE_1_64 */
static int hf_h225_protocolType = -1;             /* IA5String_SIZE_1_64 */
static int hf_h225_protocolVariant = -1;          /* IA5String_SIZE_1_64 */
static int hf_h225_nonStandardIdentifier = -1;    /* NonStandardIdentifier */
static int hf_h225_nsp_data = -1;                 /* T_nsp_data */
static int hf_h225_nsiOID = -1;                   /* T_nsiOID */
static int hf_h225_h221NonStandard = -1;          /* H221NonStandard */
static int hf_h225_dialledDigits = -1;            /* DialedDigits */
static int hf_h225_h323_ID = -1;                  /* BMPString_SIZE_1_256 */
static int hf_h225_url_ID = -1;                   /* IA5String_SIZE_1_512 */
static int hf_h225_transportID = -1;              /* TransportAddress */
static int hf_h225_email_ID = -1;                 /* IA5String_SIZE_1_512 */
static int hf_h225_partyNumber = -1;              /* PartyNumber */
static int hf_h225_mobileUIM = -1;                /* MobileUIM */
static int hf_h225_isupNumber = -1;               /* IsupNumber */
static int hf_h225_wildcard = -1;                 /* AliasAddress */
static int hf_h225_range = -1;                    /* T_range */
static int hf_h225_startOfRange = -1;             /* PartyNumber */
static int hf_h225_endOfRange = -1;               /* PartyNumber */
static int hf_h225_e164Number = -1;               /* PublicPartyNumber */
static int hf_h225_dataPartyNumber = -1;          /* NumberDigits */
static int hf_h225_telexPartyNumber = -1;         /* NumberDigits */
static int hf_h225_privateNumber = -1;            /* PrivatePartyNumber */
static int hf_h225_nationalStandardPartyNumber = -1;  /* NumberDigits */
static int hf_h225_publicTypeOfNumber = -1;       /* PublicTypeOfNumber */
static int hf_h225_publicNumberDigits = -1;       /* NumberDigits */
static int hf_h225_privateTypeOfNumber = -1;      /* PrivateTypeOfNumber */
static int hf_h225_privateNumberDigits = -1;      /* NumberDigits */
static int hf_h225_language_01 = -1;              /* IA5String */
static int hf_h225_name = -1;                     /* BMPString_SIZE_1_80 */
static int hf_h225_internationalNumber = -1;      /* NULL */
static int hf_h225_nationalNumber = -1;           /* NULL */
static int hf_h225_networkSpecificNumber = -1;    /* NULL */
static int hf_h225_subscriberNumber = -1;         /* NULL */
static int hf_h225_abbreviatedNumber = -1;        /* NULL */
static int hf_h225_level2RegionalNumber = -1;     /* NULL */
static int hf_h225_level1RegionalNumber = -1;     /* NULL */
static int hf_h225_pISNSpecificNumber = -1;       /* NULL */
static int hf_h225_localNumber = -1;              /* NULL */
static int hf_h225_ansi_41_uim = -1;              /* ANSI_41_UIM */
static int hf_h225_gsm_uim = -1;                  /* GSM_UIM */
static int hf_h225_imsi = -1;                     /* TBCD_STRING_SIZE_3_16 */
static int hf_h225_min = -1;                      /* TBCD_STRING_SIZE_3_16 */
static int hf_h225_mdn = -1;                      /* TBCD_STRING_SIZE_3_16 */
static int hf_h225_msisdn = -1;                   /* TBCD_STRING_SIZE_3_16 */
static int hf_h225_esn = -1;                      /* TBCD_STRING_SIZE_16 */
static int hf_h225_mscid = -1;                    /* TBCD_STRING_SIZE_3_16 */
static int hf_h225_system_id = -1;                /* T_system_id */
static int hf_h225_sid = -1;                      /* TBCD_STRING_SIZE_1_4 */
static int hf_h225_mid = -1;                      /* TBCD_STRING_SIZE_1_4 */
static int hf_h225_systemMyTypeCode = -1;         /* OCTET_STRING_SIZE_1 */
static int hf_h225_systemAccessType = -1;         /* OCTET_STRING_SIZE_1 */
static int hf_h225_qualificationInformationCode = -1;  /* OCTET_STRING_SIZE_1 */
static int hf_h225_sesn = -1;                     /* TBCD_STRING_SIZE_16 */
static int hf_h225_soc = -1;                      /* TBCD_STRING_SIZE_3_16 */
static int hf_h225_tmsi = -1;                     /* OCTET_STRING_SIZE_1_4 */
static int hf_h225_imei = -1;                     /* TBCD_STRING_SIZE_15_16 */
static int hf_h225_hplmn = -1;                    /* TBCD_STRING_SIZE_1_4 */
static int hf_h225_vplmn = -1;                    /* TBCD_STRING_SIZE_1_4 */
static int hf_h225_isupE164Number = -1;           /* IsupPublicPartyNumber */
static int hf_h225_isupDataPartyNumber = -1;      /* IsupDigits */
static int hf_h225_isupTelexPartyNumber = -1;     /* IsupDigits */
static int hf_h225_isupPrivateNumber = -1;        /* IsupPrivatePartyNumber */
static int hf_h225_isupNationalStandardPartyNumber = -1;  /* IsupDigits */
static int hf_h225_natureOfAddress = -1;          /* NatureOfAddress */
static int hf_h225_address = -1;                  /* IsupDigits */
static int hf_h225_routingNumberNationalFormat = -1;  /* NULL */
static int hf_h225_routingNumberNetworkSpecificFormat = -1;  /* NULL */
static int hf_h225_routingNumberWithCalledDirectoryNumber = -1;  /* NULL */
static int hf_h225_extAliasAddress = -1;          /* AliasAddress */
static int hf_h225_aliasAddress = -1;             /* SEQUENCE_OF_AliasAddress */
static int hf_h225_aliasAddress_item = -1;        /* AliasAddress */
static int hf_h225_callSignalAddress = -1;        /* SEQUENCE_OF_TransportAddress */
static int hf_h225_callSignalAddress_item = -1;   /* TransportAddress */
static int hf_h225_rasAddress = -1;               /* SEQUENCE_OF_TransportAddress */
static int hf_h225_rasAddress_item = -1;          /* TransportAddress */
static int hf_h225_endpointType = -1;             /* EndpointType */
static int hf_h225_priority = -1;                 /* INTEGER_0_127 */
static int hf_h225_remoteExtensionAddress = -1;   /* SEQUENCE_OF_AliasAddress */
static int hf_h225_remoteExtensionAddress_item = -1;  /* AliasAddress */
static int hf_h225_alternateTransportAddresses = -1;  /* AlternateTransportAddresses */
static int hf_h225_annexE = -1;                   /* SEQUENCE_OF_TransportAddress */
static int hf_h225_annexE_item = -1;              /* TransportAddress */
static int hf_h225_sctp = -1;                     /* SEQUENCE_OF_TransportAddress */
static int hf_h225_sctp_item = -1;                /* TransportAddress */
static int hf_h225_tcp = -1;                      /* NULL */
static int hf_h225_annexE_flg = -1;               /* NULL */
static int hf_h225_sctp_flg = -1;                 /* NULL */
static int hf_h225_alternateGK_rasAddress = -1;   /* TransportAddress */
static int hf_h225_gatekeeperIdentifier = -1;     /* GatekeeperIdentifier */
static int hf_h225_needToRegister = -1;           /* BOOLEAN */
static int hf_h225_alternateGatekeeper = -1;      /* SEQUENCE_OF_AlternateGK */
static int hf_h225_alternateGatekeeper_item = -1;  /* AlternateGK */
static int hf_h225_altGKisPermanent = -1;         /* BOOLEAN */
static int hf_h225_default = -1;                  /* NULL */
static int hf_h225_encryption = -1;               /* SecurityServiceMode */
static int hf_h225_authenticaton = -1;            /* SecurityServiceMode */
static int hf_h225_securityCapabilities_integrity = -1;  /* SecurityServiceMode */
static int hf_h225_securityWrongSyncTime = -1;    /* NULL */
static int hf_h225_securityReplay = -1;           /* NULL */
static int hf_h225_securityWrongGeneralID = -1;   /* NULL */
static int hf_h225_securityWrongSendersID = -1;   /* NULL */
static int hf_h225_securityIntegrityFailed = -1;  /* NULL */
static int hf_h225_securityWrongOID = -1;         /* NULL */
static int hf_h225_securityDHmismatch = -1;       /* NULL */
static int hf_h225_securityCertificateExpired = -1;  /* NULL */
static int hf_h225_securityCertificateDateInvalid = -1;  /* NULL */
static int hf_h225_securityCertificateRevoked = -1;  /* NULL */
static int hf_h225_securityCertificateNotReadable = -1;  /* NULL */
static int hf_h225_securityCertificateSignatureInvalid = -1;  /* NULL */
static int hf_h225_securityCertificateMissing = -1;  /* NULL */
static int hf_h225_securityCertificateIncomplete = -1;  /* NULL */
static int hf_h225_securityUnsupportedCertificateAlgOID = -1;  /* NULL */
static int hf_h225_securityUnknownCA = -1;        /* NULL */
static int hf_h225_noSecurity = -1;               /* NULL */
static int hf_h225_tls = -1;                      /* SecurityCapabilities */
static int hf_h225_ipsec = -1;                    /* SecurityCapabilities */
static int hf_h225_q932Full = -1;                 /* BOOLEAN */
static int hf_h225_q951Full = -1;                 /* BOOLEAN */
static int hf_h225_q952Full = -1;                 /* BOOLEAN */
static int hf_h225_q953Full = -1;                 /* BOOLEAN */
static int hf_h225_q955Full = -1;                 /* BOOLEAN */
static int hf_h225_q956Full = -1;                 /* BOOLEAN */
static int hf_h225_q957Full = -1;                 /* BOOLEAN */
static int hf_h225_q954Info = -1;                 /* Q954Details */
static int hf_h225_conferenceCalling = -1;        /* BOOLEAN */
static int hf_h225_threePartyService = -1;        /* BOOLEAN */
static int hf_h225_guid = -1;                     /* T_guid */
static int hf_h225_isoAlgorithm = -1;             /* OBJECT_IDENTIFIER */
static int hf_h225_hMAC_MD5 = -1;                 /* NULL */
static int hf_h225_hMAC_iso10118_2_s = -1;        /* EncryptIntAlg */
static int hf_h225_hMAC_iso10118_2_l = -1;        /* EncryptIntAlg */
static int hf_h225_hMAC_iso10118_3 = -1;          /* OBJECT_IDENTIFIER */
static int hf_h225_digSig = -1;                   /* NULL */
static int hf_h225_iso9797 = -1;                  /* OBJECT_IDENTIFIER */
static int hf_h225_nonIsoIM = -1;                 /* NonIsoIntegrityMechanism */
static int hf_h225_algorithmOID = -1;             /* OBJECT_IDENTIFIER */
static int hf_h225_icv = -1;                      /* BIT_STRING */
static int hf_h225_cryptoEPPwdHash = -1;          /* T_cryptoEPPwdHash */
static int hf_h225_alias = -1;                    /* AliasAddress */
static int hf_h225_timeStamp = -1;                /* TimeStamp */
static int hf_h225_token = -1;                    /* HASHED */
static int hf_h225_cryptoGKPwdHash = -1;          /* T_cryptoGKPwdHash */
static int hf_h225_gatekeeperId = -1;             /* GatekeeperIdentifier */
static int hf_h225_cryptoEPPwdEncr = -1;          /* ENCRYPTED */
static int hf_h225_cryptoGKPwdEncr = -1;          /* ENCRYPTED */
static int hf_h225_cryptoEPCert = -1;             /* SIGNED */
static int hf_h225_cryptoGKCert = -1;             /* SIGNED */
static int hf_h225_cryptoFastStart = -1;          /* SIGNED */
static int hf_h225_nestedcryptoToken = -1;        /* CryptoToken */
static int hf_h225_channelRate = -1;              /* BandWidth */
static int hf_h225_channelMultiplier = -1;        /* INTEGER_1_256 */
static int hf_h225_globalCallId = -1;             /* GloballyUniqueID */
static int hf_h225_threadId = -1;                 /* GloballyUniqueID */
static int hf_h225_prefix = -1;                   /* AliasAddress */
static int hf_h225_canReportCallCapacity = -1;    /* BOOLEAN */
static int hf_h225_capacityReportingSpecification_when = -1;  /* CapacityReportingSpecification_when */
static int hf_h225_callStart = -1;                /* NULL */
static int hf_h225_callEnd = -1;                  /* NULL */
static int hf_h225_maximumCallCapacity = -1;      /* CallCapacityInfo */
static int hf_h225_currentCallCapacity = -1;      /* CallCapacityInfo */
static int hf_h225_voiceGwCallsAvailable = -1;    /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_voiceGwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_h310GwCallsAvailable = -1;     /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_h310GwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_h320GwCallsAvailable = -1;     /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_h320GwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_h321GwCallsAvailable = -1;     /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_h321GwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_h322GwCallsAvailable = -1;     /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_h322GwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_h323GwCallsAvailable = -1;     /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_h323GwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_h324GwCallsAvailable = -1;     /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_h324GwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_t120OnlyGwCallsAvailable = -1;  /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_t120OnlyGwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_t38FaxAnnexbOnlyGwCallsAvailable = -1;  /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_t38FaxAnnexbOnlyGwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_terminalCallsAvailable = -1;   /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_terminalCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_mcuCallsAvailable = -1;        /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_mcuCallsAvailable_item = -1;   /* CallsAvailable */
static int hf_h225_sipGwCallsAvailable = -1;      /* SEQUENCE_OF_CallsAvailable */
static int hf_h225_sipGwCallsAvailable_item = -1;  /* CallsAvailable */
static int hf_h225_calls = -1;                    /* INTEGER_0_4294967295 */
static int hf_h225_group_IA5String = -1;          /* IA5String_SIZE_1_128 */
static int hf_h225_carrier = -1;                  /* CarrierInfo */
static int hf_h225_sourceCircuitID = -1;          /* CircuitIdentifier */
static int hf_h225_destinationCircuitID = -1;     /* CircuitIdentifier */
static int hf_h225_cic = -1;                      /* CicInfo */
static int hf_h225_group = -1;                    /* GroupID */
static int hf_h225_cic_2_4 = -1;                  /* T_cic_2_4 */
static int hf_h225_cic_2_4_item = -1;             /* OCTET_STRING_SIZE_2_4 */
static int hf_h225_pointCode = -1;                /* OCTET_STRING_SIZE_2_5 */
static int hf_h225_member = -1;                   /* T_member */
static int hf_h225_member_item = -1;              /* INTEGER_0_65535 */
static int hf_h225_carrierIdentificationCode = -1;  /* OCTET_STRING_SIZE_3_4 */
static int hf_h225_carrierName = -1;              /* IA5String_SIZE_1_128 */
static int hf_h225_url = -1;                      /* IA5String_SIZE_0_512 */
static int hf_h225_signal = -1;                   /* H248SignalsDescriptor */
static int hf_h225_callCreditServiceControl = -1;  /* CallCreditServiceControl */
static int hf_h225_sessionId_0_255 = -1;          /* INTEGER_0_255 */
static int hf_h225_contents = -1;                 /* ServiceControlDescriptor */
static int hf_h225_reason = -1;                   /* ServiceControlSession_reason */
static int hf_h225_open = -1;                     /* NULL */
static int hf_h225_refresh = -1;                  /* NULL */
static int hf_h225_close = -1;                    /* NULL */
static int hf_h225_nonStandardUsageTypes = -1;    /* SEQUENCE_OF_NonStandardParameter */
static int hf_h225_nonStandardUsageTypes_item = -1;  /* NonStandardParameter */
static int hf_h225_startTime = -1;                /* NULL */
static int hf_h225_endTime_flg = -1;              /* NULL */
static int hf_h225_terminationCause_flg = -1;     /* NULL */
static int hf_h225_when = -1;                     /* RasUsageSpecification_when */
static int hf_h225_start = -1;                    /* NULL */
static int hf_h225_end = -1;                      /* NULL */
static int hf_h225_inIrr = -1;                    /* NULL */
static int hf_h225_ras_callStartingPoint = -1;    /* RasUsageSpecificationcallStartingPoint */
static int hf_h225_alerting_flg = -1;             /* NULL */
static int hf_h225_connect_flg = -1;              /* NULL */
static int hf_h225_required = -1;                 /* RasUsageInfoTypes */
static int hf_h225_nonStandardUsageFields = -1;   /* SEQUENCE_OF_NonStandardParameter */
static int hf_h225_nonStandardUsageFields_item = -1;  /* NonStandardParameter */
static int hf_h225_alertingTime = -1;             /* TimeStamp */
static int hf_h225_connectTime = -1;              /* TimeStamp */
static int hf_h225_endTime = -1;                  /* TimeStamp */
static int hf_h225_releaseCompleteCauseIE = -1;   /* OCTET_STRING_SIZE_2_32 */
static int hf_h225_sender = -1;                   /* BOOLEAN */
static int hf_h225_multicast = -1;                /* BOOLEAN */
static int hf_h225_bandwidth = -1;                /* BandWidth */
static int hf_h225_rtcpAddresses = -1;            /* TransportChannelInfo */
static int hf_h225_canDisplayAmountString = -1;   /* BOOLEAN */
static int hf_h225_canEnforceDurationLimit = -1;  /* BOOLEAN */
static int hf_h225_amountString = -1;             /* BMPString_SIZE_1_512 */
static int hf_h225_billingMode = -1;              /* T_billingMode */
static int hf_h225_credit = -1;                   /* NULL */
static int hf_h225_debit = -1;                    /* NULL */
static int hf_h225_callDurationLimit = -1;        /* INTEGER_1_4294967295 */
static int hf_h225_enforceCallDurationLimit = -1;  /* BOOLEAN */
static int hf_h225_callStartingPoint = -1;        /* CallCreditServiceControl_callStartingPoint */
static int hf_h225_id = -1;                       /* GenericIdentifier */
static int hf_h225_parameters = -1;               /* T_parameters */
static int hf_h225_parameters_item = -1;          /* T_parameters_item */
static int hf_h225_standard = -1;                 /* T_standard */
static int hf_h225_oid = -1;                      /* T_oid */
static int hf_h225_genericIdentifier_nonStandard = -1;  /* GloballyUniqueID */
static int hf_h225_content = -1;                  /* Content */
static int hf_h225_raw = -1;                      /* OCTET_STRING */
static int hf_h225_text = -1;                     /* IA5String */
static int hf_h225_unicode = -1;                  /* BMPString */
static int hf_h225_bool = -1;                     /* BOOLEAN */
static int hf_h225_number8 = -1;                  /* INTEGER_0_255 */
static int hf_h225_number16 = -1;                 /* INTEGER_0_65535 */
static int hf_h225_number32 = -1;                 /* INTEGER_0_4294967295 */
static int hf_h225_transport = -1;                /* TransportAddress */
static int hf_h225_compound = -1;                 /* SEQUENCE_SIZE_1_512_OF_EnumeratedParameter */
static int hf_h225_compound_item = -1;            /* EnumeratedParameter */
static int hf_h225_nested = -1;                   /* SEQUENCE_SIZE_1_16_OF_GenericData */
static int hf_h225_nested_item = -1;              /* GenericData */
static int hf_h225_replacementFeatureSet = -1;    /* BOOLEAN */
static int hf_h225_sendAddress = -1;              /* TransportAddress */
static int hf_h225_recvAddress = -1;              /* TransportAddress */
static int hf_h225_rtpAddress = -1;               /* TransportChannelInfo */
static int hf_h225_rtcpAddress = -1;              /* TransportChannelInfo */
static int hf_h225_cname = -1;                    /* PrintableString */
static int hf_h225_ssrc = -1;                     /* INTEGER_1_4294967295 */
static int hf_h225_sessionId = -1;                /* INTEGER_1_255 */
static int hf_h225_associatedSessionIds = -1;     /* T_associatedSessionIds */
static int hf_h225_associatedSessionIds_item = -1;  /* INTEGER_1_255 */
static int hf_h225_multicast_flg = -1;            /* NULL */
static int hf_h225_gatekeeperBased = -1;          /* NULL */
static int hf_h225_endpointBased = -1;            /* NULL */
static int hf_h225_gatekeeperRequest = -1;        /* GatekeeperRequest */
static int hf_h225_gatekeeperConfirm = -1;        /* GatekeeperConfirm */
static int hf_h225_gatekeeperReject = -1;         /* GatekeeperReject */
static int hf_h225_registrationRequest = -1;      /* RegistrationRequest */
static int hf_h225_registrationConfirm = -1;      /* RegistrationConfirm */
static int hf_h225_registrationReject = -1;       /* RegistrationReject */
static int hf_h225_unregistrationRequest = -1;    /* UnregistrationRequest */
static int hf_h225_unregistrationConfirm = -1;    /* UnregistrationConfirm */
static int hf_h225_unregistrationReject = -1;     /* UnregistrationReject */
static int hf_h225_admissionRequest = -1;         /* AdmissionRequest */
static int hf_h225_admissionConfirm = -1;         /* AdmissionConfirm */
static int hf_h225_admissionReject = -1;          /* AdmissionReject */
static int hf_h225_bandwidthRequest = -1;         /* BandwidthRequest */
static int hf_h225_bandwidthConfirm = -1;         /* BandwidthConfirm */
static int hf_h225_bandwidthReject = -1;          /* BandwidthReject */
static int hf_h225_disengageRequest = -1;         /* DisengageRequest */
static int hf_h225_disengageConfirm = -1;         /* DisengageConfirm */
static int hf_h225_disengageReject = -1;          /* DisengageReject */
static int hf_h225_locationRequest = -1;          /* LocationRequest */
static int hf_h225_locationConfirm = -1;          /* LocationConfirm */
static int hf_h225_locationReject = -1;           /* LocationReject */
static int hf_h225_infoRequest = -1;              /* InfoRequest */
static int hf_h225_infoRequestResponse = -1;      /* InfoRequestResponse */
static int hf_h225_nonStandardMessage = -1;       /* NonStandardMessage */
static int hf_h225_unknownMessageResponse = -1;   /* UnknownMessageResponse */
static int hf_h225_requestInProgress = -1;        /* RequestInProgress */
static int hf_h225_resourcesAvailableIndicate = -1;  /* ResourcesAvailableIndicate */
static int hf_h225_resourcesAvailableConfirm = -1;  /* ResourcesAvailableConfirm */
static int hf_h225_infoRequestAck = -1;           /* InfoRequestAck */
static int hf_h225_infoRequestNak = -1;           /* InfoRequestNak */
static int hf_h225_serviceControlIndication = -1;  /* ServiceControlIndication */
static int hf_h225_serviceControlResponse = -1;   /* ServiceControlResponse */
static int hf_h225_admissionConfirmSequence = -1;  /* SEQUENCE_OF_AdmissionConfirm */
static int hf_h225_admissionConfirmSequence_item = -1;  /* AdmissionConfirm */
static int hf_h225_requestSeqNum = -1;            /* RequestSeqNum */
static int hf_h225_gatekeeperRequest_rasAddress = -1;  /* TransportAddress */
static int hf_h225_endpointAlias = -1;            /* SEQUENCE_OF_AliasAddress */
static int hf_h225_endpointAlias_item = -1;       /* AliasAddress */
static int hf_h225_alternateEndpoints = -1;       /* SEQUENCE_OF_Endpoint */
static int hf_h225_alternateEndpoints_item = -1;  /* Endpoint */
static int hf_h225_authenticationCapability = -1;  /* SEQUENCE_OF_AuthenticationMechanism */
static int hf_h225_authenticationCapability_item = -1;  /* AuthenticationMechanism */
static int hf_h225_algorithmOIDs = -1;            /* T_algorithmOIDs */
static int hf_h225_algorithmOIDs_item = -1;       /* OBJECT_IDENTIFIER */
static int hf_h225_integrity = -1;                /* SEQUENCE_OF_IntegrityMechanism */
static int hf_h225_integrity_item = -1;           /* IntegrityMechanism */
static int hf_h225_integrityCheckValue = -1;      /* ICV */
static int hf_h225_supportsAltGK = -1;            /* NULL */
static int hf_h225_supportsAssignedGK = -1;       /* BOOLEAN */
static int hf_h225_assignedGatekeeper = -1;       /* AlternateGK */
static int hf_h225_gatekeeperConfirm_rasAddress = -1;  /* TransportAddress */
static int hf_h225_authenticationMode = -1;       /* AuthenticationMechanism */
static int hf_h225_rehomingModel = -1;            /* RehomingModel */
static int hf_h225_gatekeeperRejectReason = -1;   /* GatekeeperRejectReason */
static int hf_h225_altGKInfo = -1;                /* AltGKInfo */
static int hf_h225_resourceUnavailable = -1;      /* NULL */
static int hf_h225_terminalExcluded = -1;         /* NULL */
static int hf_h225_securityDenial = -1;           /* NULL */
static int hf_h225_gkRej_securityError = -1;      /* SecurityErrors */
static int hf_h225_discoveryComplete = -1;        /* BOOLEAN */
static int hf_h225_terminalType = -1;             /* EndpointType */
static int hf_h225_terminalAlias = -1;            /* SEQUENCE_OF_AliasAddress */
static int hf_h225_terminalAlias_item = -1;       /* AliasAddress */
static int hf_h225_endpointVendor = -1;           /* VendorIdentifier */
static int hf_h225_timeToLive = -1;               /* TimeToLive */
static int hf_h225_keepAlive = -1;                /* BOOLEAN */
static int hf_h225_willSupplyUUIEs = -1;          /* BOOLEAN */
static int hf_h225_additiveRegistration = -1;     /* NULL */
static int hf_h225_terminalAliasPattern = -1;     /* SEQUENCE_OF_AddressPattern */
static int hf_h225_terminalAliasPattern_item = -1;  /* AddressPattern */
static int hf_h225_usageReportingCapability = -1;  /* RasUsageInfoTypes */
static int hf_h225_supportedH248Packages = -1;    /* SEQUENCE_OF_H248PackagesDescriptor */
static int hf_h225_supportedH248Packages_item = -1;  /* H248PackagesDescriptor */
static int hf_h225_callCreditCapability = -1;     /* CallCreditCapability */
static int hf_h225_capacityReportingCapability = -1;  /* CapacityReportingCapability */
static int hf_h225_restart = -1;                  /* NULL */
static int hf_h225_supportsACFSequences = -1;     /* NULL */
static int hf_h225_transportQOS = -1;             /* TransportQOS */
static int hf_h225_willRespondToIRR = -1;         /* BOOLEAN */
static int hf_h225_preGrantedARQ = -1;            /* T_preGrantedARQ */
static int hf_h225_makeCall = -1;                 /* BOOLEAN */
static int hf_h225_useGKCallSignalAddressToMakeCall = -1;  /* BOOLEAN */
static int hf_h225_answerCall = -1;               /* BOOLEAN */
static int hf_h225_useGKCallSignalAddressToAnswer = -1;  /* BOOLEAN */
static int hf_h225_irrFrequencyInCall = -1;       /* INTEGER_1_65535 */
static int hf_h225_totalBandwidthRestriction = -1;  /* BandWidth */
static int hf_h225_useSpecifiedTransport = -1;    /* UseSpecifiedTransport */
static int hf_h225_supportsAdditiveRegistration = -1;  /* NULL */
static int hf_h225_usageSpec = -1;                /* SEQUENCE_OF_RasUsageSpecification */
static int hf_h225_usageSpec_item = -1;           /* RasUsageSpecification */
static int hf_h225_featureServerAlias = -1;       /* AliasAddress */
static int hf_h225_capacityReportingSpec = -1;    /* CapacityReportingSpecification */
static int hf_h225_registrationRejectReason = -1;  /* RegistrationRejectReason */
static int hf_h225_discoveryRequired = -1;        /* NULL */
static int hf_h225_invalidCallSignalAddress = -1;  /* NULL */
static int hf_h225_invalidRASAddress = -1;        /* NULL */
static int hf_h225_duplicateAlias = -1;           /* SEQUENCE_OF_AliasAddress */
static int hf_h225_duplicateAlias_item = -1;      /* AliasAddress */
static int hf_h225_invalidTerminalType = -1;      /* NULL */
static int hf_h225_transportNotSupported = -1;    /* NULL */
static int hf_h225_transportQOSNotSupported = -1;  /* NULL */
static int hf_h225_invalidAlias = -1;             /* NULL */
static int hf_h225_fullRegistrationRequired = -1;  /* NULL */
static int hf_h225_additiveRegistrationNotSupported = -1;  /* NULL */
static int hf_h225_invalidTerminalAliases = -1;   /* T_invalidTerminalAliases */
static int hf_h225_reg_securityError = -1;        /* SecurityErrors */
static int hf_h225_registerWithAssignedGK = -1;   /* NULL */
static int hf_h225_unregRequestReason = -1;       /* UnregRequestReason */
static int hf_h225_endpointAliasPattern = -1;     /* SEQUENCE_OF_AddressPattern */
static int hf_h225_endpointAliasPattern_item = -1;  /* AddressPattern */
static int hf_h225_reregistrationRequired = -1;   /* NULL */
static int hf_h225_ttlExpired = -1;               /* NULL */
static int hf_h225_maintenance = -1;              /* NULL */
static int hf_h225_securityError = -1;            /* SecurityErrors2 */
static int hf_h225_unregRejectReason = -1;        /* UnregRejectReason */
static int hf_h225_notCurrentlyRegistered = -1;   /* NULL */
static int hf_h225_callInProgress = -1;           /* NULL */
static int hf_h225_permissionDenied = -1;         /* NULL */
static int hf_h225_callModel = -1;                /* CallModel */
static int hf_h225_DestinationInfo_item = -1;     /* DestinationInfo_item */
static int hf_h225_destinationInfo_01 = -1;       /* DestinationInfo */
static int hf_h225_srcInfo = -1;                  /* SEQUENCE_OF_AliasAddress */
static int hf_h225_srcInfo_item = -1;             /* AliasAddress */
static int hf_h225_srcCallSignalAddress = -1;     /* TransportAddress */
static int hf_h225_bandWidth = -1;                /* BandWidth */
static int hf_h225_callReferenceValue = -1;       /* CallReferenceValue */
static int hf_h225_canMapAlias = -1;              /* BOOLEAN */
static int hf_h225_srcAlternatives = -1;          /* SEQUENCE_OF_Endpoint */
static int hf_h225_srcAlternatives_item = -1;     /* Endpoint */
static int hf_h225_destAlternatives = -1;         /* SEQUENCE_OF_Endpoint */
static int hf_h225_destAlternatives_item = -1;    /* Endpoint */
static int hf_h225_gatewayDataRate = -1;          /* DataRate */
static int hf_h225_desiredTunnelledProtocol = -1;  /* TunnelledProtocol */
static int hf_h225_canMapSrcAlias = -1;           /* BOOLEAN */
static int hf_h225_pointToPoint = -1;             /* NULL */
static int hf_h225_oneToN = -1;                   /* NULL */
static int hf_h225_nToOne = -1;                   /* NULL */
static int hf_h225_nToN = -1;                     /* NULL */
static int hf_h225_direct = -1;                   /* NULL */
static int hf_h225_gatekeeperRouted = -1;         /* NULL */
static int hf_h225_endpointControlled = -1;       /* NULL */
static int hf_h225_gatekeeperControlled = -1;     /* NULL */
static int hf_h225_noControl = -1;                /* NULL */
static int hf_h225_qOSCapabilities = -1;          /* SEQUENCE_SIZE_1_256_OF_QOSCapability */
static int hf_h225_qOSCapabilities_item = -1;     /* QOSCapability */
static int hf_h225_irrFrequency = -1;             /* INTEGER_1_65535 */
static int hf_h225_destinationType = -1;          /* EndpointType */
static int hf_h225_uuiesRequested = -1;           /* UUIEsRequested */
static int hf_h225_supportedProtocols = -1;       /* SEQUENCE_OF_SupportedProtocols */
static int hf_h225_supportedProtocols_item = -1;  /* SupportedProtocols */
static int hf_h225_modifiedSrcInfo = -1;          /* SEQUENCE_OF_AliasAddress */
static int hf_h225_modifiedSrcInfo_item = -1;     /* AliasAddress */
static int hf_h225_setup_bool = -1;               /* BOOLEAN */
static int hf_h225_callProceeding_flg = -1;       /* BOOLEAN */
static int hf_h225_connect_bool = -1;             /* BOOLEAN */
static int hf_h225_alerting_bool = -1;            /* BOOLEAN */
static int hf_h225_information_bool = -1;         /* BOOLEAN */
static int hf_h225_releaseComplete_bool = -1;     /* BOOLEAN */
static int hf_h225_facility_bool = -1;            /* BOOLEAN */
static int hf_h225_progress_bool = -1;            /* BOOLEAN */
static int hf_h225_empty = -1;                    /* BOOLEAN */
static int hf_h225_status_bool = -1;              /* BOOLEAN */
static int hf_h225_statusInquiry_bool = -1;       /* BOOLEAN */
static int hf_h225_setupAcknowledge_bool = -1;    /* BOOLEAN */
static int hf_h225_notify_bool = -1;              /* BOOLEAN */
static int hf_h225_rejectReason = -1;             /* AdmissionRejectReason */
static int hf_h225_invalidPermission = -1;        /* NULL */
static int hf_h225_requestDenied = -1;            /* NULL */
static int hf_h225_invalidEndpointIdentifier = -1;  /* NULL */
static int hf_h225_qosControlNotSupported = -1;   /* NULL */
static int hf_h225_incompleteAddress = -1;        /* NULL */
static int hf_h225_aliasesInconsistent = -1;      /* NULL */
static int hf_h225_routeCallToSCN = -1;           /* SEQUENCE_OF_PartyNumber */
static int hf_h225_routeCallToSCN_item = -1;      /* PartyNumber */
static int hf_h225_exceedsCallCapacity = -1;      /* NULL */
static int hf_h225_collectDestination = -1;       /* NULL */
static int hf_h225_collectPIN = -1;               /* NULL */
static int hf_h225_noRouteToDestination = -1;     /* NULL */
static int hf_h225_unallocatedNumber = -1;        /* NULL */
static int hf_h225_answeredCall = -1;             /* BOOLEAN */
static int hf_h225_usageInformation = -1;         /* RasUsageInformation */
static int hf_h225_bandwidthDetails = -1;         /* SEQUENCE_OF_BandwidthDetails */
static int hf_h225_bandwidthDetails_item = -1;    /* BandwidthDetails */
static int hf_h225_bandRejectReason = -1;         /* BandRejectReason */
static int hf_h225_allowedBandWidth = -1;         /* BandWidth */
static int hf_h225_notBound = -1;                 /* NULL */
static int hf_h225_invalidConferenceID = -1;      /* NULL */
static int hf_h225_insufficientResources = -1;    /* NULL */
static int hf_h225_replyAddress = -1;             /* TransportAddress */
static int hf_h225_sourceInfo = -1;               /* SEQUENCE_OF_AliasAddress */
static int hf_h225_sourceInfo_item = -1;          /* AliasAddress */
static int hf_h225_hopCount = -1;                 /* INTEGER_1_255 */
static int hf_h225_sourceEndpointInfo = -1;       /* SEQUENCE_OF_AliasAddress */
static int hf_h225_sourceEndpointInfo_item = -1;  /* AliasAddress */
static int hf_h225_locationConfirm_callSignalAddress = -1;  /* TransportAddress */
static int hf_h225_locationConfirm_rasAddress = -1;  /* TransportAddress */
static int hf_h225_locationRejectReason = -1;     /* LocationRejectReason */
static int hf_h225_notRegistered = -1;            /* NULL */
static int hf_h225_routeCalltoSCN = -1;           /* SEQUENCE_OF_PartyNumber */
static int hf_h225_routeCalltoSCN_item = -1;      /* PartyNumber */
static int hf_h225_disengageReason = -1;          /* DisengageReason */
static int hf_h225_terminationCause = -1;         /* CallTerminationCause */
static int hf_h225_forcedDrop = -1;               /* NULL */
static int hf_h225_normalDrop = -1;               /* NULL */
static int hf_h225_disengageRejectReason = -1;    /* DisengageRejectReason */
static int hf_h225_requestToDropOther = -1;       /* NULL */
static int hf_h225_usageInfoRequested = -1;       /* RasUsageInfoTypes */
static int hf_h225_segmentedResponseSupported = -1;  /* NULL */
static int hf_h225_nextSegmentRequested = -1;     /* INTEGER_0_65535 */
static int hf_h225_capacityInfoRequested = -1;    /* NULL */
static int hf_h225_infoRequestResponse_rasAddress = -1;  /* TransportAddress */
static int hf_h225_perCallInfo = -1;              /* T_perCallInfo */
static int hf_h225_perCallInfo_item = -1;         /* T_perCallInfo_item */
static int hf_h225_originator = -1;               /* BOOLEAN */
static int hf_h225_audio = -1;                    /* SEQUENCE_OF_RTPSession */
static int hf_h225_audio_item = -1;               /* RTPSession */
static int hf_h225_video = -1;                    /* SEQUENCE_OF_RTPSession */
static int hf_h225_video_item = -1;               /* RTPSession */
static int hf_h225_data = -1;                     /* SEQUENCE_OF_TransportChannelInfo */
static int hf_h225_data_item = -1;                /* TransportChannelInfo */
static int hf_h225_h245 = -1;                     /* TransportChannelInfo */
static int hf_h225_callSignalling = -1;           /* TransportChannelInfo */
static int hf_h225_substituteConfIDs = -1;        /* SEQUENCE_OF_ConferenceIdentifier */
static int hf_h225_substituteConfIDs_item = -1;   /* ConferenceIdentifier */
static int hf_h225_pdu = -1;                      /* T_pdu */
static int hf_h225_pdu_item = -1;                 /* T_pdu_item */
static int hf_h225_h323pdu = -1;                  /* H323_UU_PDU */
static int hf_h225_sent = -1;                     /* BOOLEAN */
static int hf_h225_needResponse = -1;             /* BOOLEAN */
static int hf_h225_irrStatus = -1;                /* InfoRequestResponseStatus */
static int hf_h225_unsolicited = -1;              /* BOOLEAN */
static int hf_h225_complete = -1;                 /* NULL */
static int hf_h225_incomplete = -1;               /* NULL */
static int hf_h225_segment = -1;                  /* INTEGER_0_65535 */
static int hf_h225_invalidCall = -1;              /* NULL */
static int hf_h225_nakReason = -1;                /* InfoRequestNakReason */
static int hf_h225_messageNotUnderstood = -1;     /* OCTET_STRING */
static int hf_h225_delay = -1;                    /* INTEGER_1_65535 */
static int hf_h225_protocols = -1;                /* SEQUENCE_OF_SupportedProtocols */
static int hf_h225_protocols_item = -1;           /* SupportedProtocols */
static int hf_h225_almostOutOfResources = -1;     /* BOOLEAN */
static int hf_h225_callSpecific = -1;             /* T_callSpecific */
static int hf_h225_result = -1;                   /* T_result */
static int hf_h225_started = -1;                  /* NULL */
static int hf_h225_failed = -1;                   /* NULL */
static int hf_h225_stopped = -1;                  /* NULL */
static int hf_h225_notAvailable = -1;             /* NULL */


/* Initialize the subtree pointers */
static gint ett_h225 = -1;

/*--- Included file: packet-h225-ett.c ---*/

static gint ett_h225_H323_UserInformation = -1;
static gint ett_h225_T_user_data = -1;
static gint ett_h225_H323_UU_PDU = -1;
static gint ett_h225_T_h323_message_body = -1;
static gint ett_h225_T_h4501SupplementaryService = -1;
static gint ett_h225_H245Control = -1;
static gint ett_h225_SEQUENCE_OF_NonStandardParameter = -1;
static gint ett_h225_T_tunnelledSignallingMessage = -1;
static gint ett_h225_T_messageContent = -1;
static gint ett_h225_SEQUENCE_OF_GenericData = -1;
static gint ett_h225_StimulusControl = -1;
static gint ett_h225_Alerting_UUIE = -1;
static gint ett_h225_SEQUENCE_OF_ClearToken = -1;
static gint ett_h225_SEQUENCE_OF_CryptoH323Token = -1;
static gint ett_h225_SEQUENCE_OF_AliasAddress = -1;
static gint ett_h225_SEQUENCE_OF_ServiceControlSession = -1;
static gint ett_h225_SEQUENCE_OF_DisplayName = -1;
static gint ett_h225_CallProceeding_UUIE = -1;
static gint ett_h225_Connect_UUIE = -1;
static gint ett_h225_Information_UUIE = -1;
static gint ett_h225_ReleaseComplete_UUIE = -1;
static gint ett_h225_ReleaseCompleteReason = -1;
static gint ett_h225_Setup_UUIE = -1;
static gint ett_h225_SEQUENCE_OF_CallReferenceValue = -1;
static gint ett_h225_T_conferenceGoal = -1;
static gint ett_h225_SEQUENCE_OF_H245Security = -1;
static gint ett_h225_FastStart = -1;
static gint ett_h225_T_connectionParameters = -1;
static gint ett_h225_Language = -1;
static gint ett_h225_SEQUENCE_OF_SupportedProtocols = -1;
static gint ett_h225_SEQUENCE_OF_FeatureDescriptor = -1;
static gint ett_h225_ParallelH245Control = -1;
static gint ett_h225_SEQUENCE_OF_ExtendedAliasAddress = -1;
static gint ett_h225_ScnConnectionType = -1;
static gint ett_h225_ScnConnectionAggregation = -1;
static gint ett_h225_PresentationIndicator = -1;
static gint ett_h225_Facility_UUIE = -1;
static gint ett_h225_SEQUENCE_OF_ConferenceList = -1;
static gint ett_h225_ConferenceList = -1;
static gint ett_h225_FacilityReason = -1;
static gint ett_h225_Progress_UUIE = -1;
static gint ett_h225_TransportAddress = -1;
static gint ett_h225_H245TransportAddress = -1;
static gint ett_h225_T_h245IpAddress = -1;
static gint ett_h225_T_h245IpSourceRoute = -1;
static gint ett_h225_T_h245Route = -1;
static gint ett_h225_T_h245Routing = -1;
static gint ett_h225_T_h245IpxAddress = -1;
static gint ett_h225_T_h245Ip6Address = -1;
static gint ett_h225_T_ipAddress = -1;
static gint ett_h225_T_ipSourceRoute = -1;
static gint ett_h225_T_route = -1;
static gint ett_h225_T_routing = -1;
static gint ett_h225_T_ipxAddress = -1;
static gint ett_h225_T_ip6Address = -1;
static gint ett_h225_Status_UUIE = -1;
static gint ett_h225_StatusInquiry_UUIE = -1;
static gint ett_h225_SetupAcknowledge_UUIE = -1;
static gint ett_h225_Notify_UUIE = -1;
static gint ett_h225_EndpointType = -1;
static gint ett_h225_SEQUENCE_OF_TunnelledProtocol = -1;
static gint ett_h225_GatewayInfo = -1;
static gint ett_h225_SupportedProtocols = -1;
static gint ett_h225_H310Caps = -1;
static gint ett_h225_SEQUENCE_OF_DataRate = -1;
static gint ett_h225_SEQUENCE_OF_SupportedPrefix = -1;
static gint ett_h225_H320Caps = -1;
static gint ett_h225_H321Caps = -1;
static gint ett_h225_H322Caps = -1;
static gint ett_h225_H323Caps = -1;
static gint ett_h225_H324Caps = -1;
static gint ett_h225_VoiceCaps = -1;
static gint ett_h225_T120OnlyCaps = -1;
static gint ett_h225_NonStandardProtocol = -1;
static gint ett_h225_T38FaxAnnexbOnlyCaps = -1;
static gint ett_h225_SIPCaps = -1;
static gint ett_h225_McuInfo = -1;
static gint ett_h225_TerminalInfo = -1;
static gint ett_h225_GatekeeperInfo = -1;
static gint ett_h225_VendorIdentifier = -1;
static gint ett_h225_H221NonStandard = -1;
static gint ett_h225_TunnelledProtocol = -1;
static gint ett_h225_TunnelledProtocol_id = -1;
static gint ett_h225_TunnelledProtocolAlternateIdentifier = -1;
static gint ett_h225_NonStandardParameter = -1;
static gint ett_h225_NonStandardIdentifier = -1;
static gint ett_h225_AliasAddress = -1;
static gint ett_h225_AddressPattern = -1;
static gint ett_h225_T_range = -1;
static gint ett_h225_PartyNumber = -1;
static gint ett_h225_PublicPartyNumber = -1;
static gint ett_h225_PrivatePartyNumber = -1;
static gint ett_h225_DisplayName = -1;
static gint ett_h225_PublicTypeOfNumber = -1;
static gint ett_h225_PrivateTypeOfNumber = -1;
static gint ett_h225_MobileUIM = -1;
static gint ett_h225_ANSI_41_UIM = -1;
static gint ett_h225_T_system_id = -1;
static gint ett_h225_GSM_UIM = -1;
static gint ett_h225_IsupNumber = -1;
static gint ett_h225_IsupPublicPartyNumber = -1;
static gint ett_h225_IsupPrivatePartyNumber = -1;
static gint ett_h225_NatureOfAddress = -1;
static gint ett_h225_ExtendedAliasAddress = -1;
static gint ett_h225_Endpoint = -1;
static gint ett_h225_SEQUENCE_OF_TransportAddress = -1;
static gint ett_h225_AlternateTransportAddresses = -1;
static gint ett_h225_UseSpecifiedTransport = -1;
static gint ett_h225_AlternateGK = -1;
static gint ett_h225_AltGKInfo = -1;
static gint ett_h225_SEQUENCE_OF_AlternateGK = -1;
static gint ett_h225_SecurityServiceMode = -1;
static gint ett_h225_SecurityCapabilities = -1;
static gint ett_h225_SecurityErrors = -1;
static gint ett_h225_SecurityErrors2 = -1;
static gint ett_h225_H245Security = -1;
static gint ett_h225_QseriesOptions = -1;
static gint ett_h225_Q954Details = -1;
static gint ett_h225_CallIdentifier = -1;
static gint ett_h225_EncryptIntAlg = -1;
static gint ett_h225_NonIsoIntegrityMechanism = -1;
static gint ett_h225_IntegrityMechanism = -1;
static gint ett_h225_ICV = -1;
static gint ett_h225_CryptoH323Token = -1;
static gint ett_h225_T_cryptoEPPwdHash = -1;
static gint ett_h225_T_cryptoGKPwdHash = -1;
static gint ett_h225_DataRate = -1;
static gint ett_h225_CallLinkage = -1;
static gint ett_h225_SupportedPrefix = -1;
static gint ett_h225_CapacityReportingCapability = -1;
static gint ett_h225_CapacityReportingSpecification = -1;
static gint ett_h225_CapacityReportingSpecification_when = -1;
static gint ett_h225_CallCapacity = -1;
static gint ett_h225_CallCapacityInfo = -1;
static gint ett_h225_SEQUENCE_OF_CallsAvailable = -1;
static gint ett_h225_CallsAvailable = -1;
static gint ett_h225_CircuitInfo = -1;
static gint ett_h225_CircuitIdentifier = -1;
static gint ett_h225_CicInfo = -1;
static gint ett_h225_T_cic_2_4 = -1;
static gint ett_h225_GroupID = -1;
static gint ett_h225_T_member = -1;
static gint ett_h225_CarrierInfo = -1;
static gint ett_h225_ServiceControlDescriptor = -1;
static gint ett_h225_ServiceControlSession = -1;
static gint ett_h225_ServiceControlSession_reason = -1;
static gint ett_h225_RasUsageInfoTypes = -1;
static gint ett_h225_RasUsageSpecification = -1;
static gint ett_h225_RasUsageSpecification_when = -1;
static gint ett_h225_RasUsageSpecificationcallStartingPoint = -1;
static gint ett_h225_RasUsageInformation = -1;
static gint ett_h225_CallTerminationCause = -1;
static gint ett_h225_BandwidthDetails = -1;
static gint ett_h225_CallCreditCapability = -1;
static gint ett_h225_CallCreditServiceControl = -1;
static gint ett_h225_T_billingMode = -1;
static gint ett_h225_CallCreditServiceControl_callStartingPoint = -1;
static gint ett_h225_GenericData = -1;
static gint ett_h225_T_parameters = -1;
static gint ett_h225_GenericIdentifier = -1;
static gint ett_h225_EnumeratedParameter = -1;
static gint ett_h225_Content = -1;
static gint ett_h225_SEQUENCE_SIZE_1_512_OF_EnumeratedParameter = -1;
static gint ett_h225_SEQUENCE_SIZE_1_16_OF_GenericData = -1;
static gint ett_h225_FeatureSet = -1;
static gint ett_h225_TransportChannelInfo = -1;
static gint ett_h225_RTPSession = -1;
static gint ett_h225_T_associatedSessionIds = -1;
static gint ett_h225_RehomingModel = -1;
static gint ett_h225_RasMessage = -1;
static gint ett_h225_SEQUENCE_OF_AdmissionConfirm = -1;
static gint ett_h225_GatekeeperRequest = -1;
static gint ett_h225_SEQUENCE_OF_Endpoint = -1;
static gint ett_h225_SEQUENCE_OF_AuthenticationMechanism = -1;
static gint ett_h225_T_algorithmOIDs = -1;
static gint ett_h225_SEQUENCE_OF_IntegrityMechanism = -1;
static gint ett_h225_GatekeeperConfirm = -1;
static gint ett_h225_GatekeeperReject = -1;
static gint ett_h225_GatekeeperRejectReason = -1;
static gint ett_h225_RegistrationRequest = -1;
static gint ett_h225_SEQUENCE_OF_AddressPattern = -1;
static gint ett_h225_SEQUENCE_OF_H248PackagesDescriptor = -1;
static gint ett_h225_RegistrationConfirm = -1;
static gint ett_h225_T_preGrantedARQ = -1;
static gint ett_h225_SEQUENCE_OF_RasUsageSpecification = -1;
static gint ett_h225_RegistrationReject = -1;
static gint ett_h225_RegistrationRejectReason = -1;
static gint ett_h225_T_invalidTerminalAliases = -1;
static gint ett_h225_UnregistrationRequest = -1;
static gint ett_h225_UnregRequestReason = -1;
static gint ett_h225_UnregistrationConfirm = -1;
static gint ett_h225_UnregistrationReject = -1;
static gint ett_h225_UnregRejectReason = -1;
static gint ett_h225_AdmissionRequest = -1;
static gint ett_h225_DestinationInfo = -1;
static gint ett_h225_CallType = -1;
static gint ett_h225_CallModel = -1;
static gint ett_h225_TransportQOS = -1;
static gint ett_h225_SEQUENCE_SIZE_1_256_OF_QOSCapability = -1;
static gint ett_h225_AdmissionConfirm = -1;
static gint ett_h225_UUIEsRequested = -1;
static gint ett_h225_AdmissionReject = -1;
static gint ett_h225_AdmissionRejectReason = -1;
static gint ett_h225_SEQUENCE_OF_PartyNumber = -1;
static gint ett_h225_BandwidthRequest = -1;
static gint ett_h225_SEQUENCE_OF_BandwidthDetails = -1;
static gint ett_h225_BandwidthConfirm = -1;
static gint ett_h225_BandwidthReject = -1;
static gint ett_h225_BandRejectReason = -1;
static gint ett_h225_LocationRequest = -1;
static gint ett_h225_LocationConfirm = -1;
static gint ett_h225_LocationReject = -1;
static gint ett_h225_LocationRejectReason = -1;
static gint ett_h225_DisengageRequest = -1;
static gint ett_h225_DisengageReason = -1;
static gint ett_h225_DisengageConfirm = -1;
static gint ett_h225_DisengageReject = -1;
static gint ett_h225_DisengageRejectReason = -1;
static gint ett_h225_InfoRequest = -1;
static gint ett_h225_InfoRequestResponse = -1;
static gint ett_h225_T_perCallInfo = -1;
static gint ett_h225_T_perCallInfo_item = -1;
static gint ett_h225_SEQUENCE_OF_RTPSession = -1;
static gint ett_h225_SEQUENCE_OF_TransportChannelInfo = -1;
static gint ett_h225_SEQUENCE_OF_ConferenceIdentifier = -1;
static gint ett_h225_T_pdu = -1;
static gint ett_h225_T_pdu_item = -1;
static gint ett_h225_InfoRequestResponseStatus = -1;
static gint ett_h225_InfoRequestAck = -1;
static gint ett_h225_InfoRequestNak = -1;
static gint ett_h225_InfoRequestNakReason = -1;
static gint ett_h225_NonStandardMessage = -1;
static gint ett_h225_UnknownMessageResponse = -1;
static gint ett_h225_RequestInProgress = -1;
static gint ett_h225_ResourcesAvailableIndicate = -1;
static gint ett_h225_ResourcesAvailableConfirm = -1;
static gint ett_h225_ServiceControlIndication = -1;
static gint ett_h225_T_callSpecific = -1;
static gint ett_h225_ServiceControlResponse = -1;
static gint ett_h225_T_result = -1;
/* Global variables */
static guint32  ipv4_address;
static guint32  ipv4_port;
static gboolean contains_faststart = FALSE;
static e_guid_t *call_id_guid;

int dissect_h225_AliasAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) ;
static int dissect_h225_Content(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index );
static dissector_handle_t tp_handle;
static const char *tpOID;
static int pi_current=0;
static h225_packet_info pi_arr[5];
h225_packet_info *h225_pi=&pi_arr[0];
static next_tvb_list_t tp_list;
static dissector_handle_t h245dg_handle=NULL;
void next_tvb_init(next_tvb_list_t *list) {
  list->first = NULL;
  list->last = NULL;
  list->count = 0;
}
static void reset_h225_packet_info(h225_packet_info *pi)
{
	if(pi == NULL) {
		return;
	}

	pi->msg_type = H225_OTHERS;
	pi->cs_type = H225_OTHER;
	pi->msg_tag = -1;
	pi->reason = -1;
	pi->requestSeqNum = 0;
	memset(&pi->guid,0,sizeof pi->guid);
	pi->is_duplicate = FALSE;
	pi->request_available = FALSE;
	pi->is_faststart = FALSE;
	pi->is_h245 = FALSE;
	pi->is_h245Tunneling = FALSE;
	pi->h245_address = 0;
	pi->h245_port = 0;
	pi->frame_label[0] = '\0';
	pi->dialedDigits[0] = '\0';
	pi->is_destinationInfo = FALSE;
}
static gboolean
proto_is_protocol_enabled(const protocol_t *protocol)
{
	return protocol->is_enabled;
}
static int
call_dissector_through_handle(dissector_handle_t handle, tvbuff_t *tvb,
			      packet_info *pinfo/*, proto_tree *tree*/)
{
	const char *saved_proto;
	int         ret;

	saved_proto = pinfo->current_proto;

	if (handle->protocol != NULL) {
		//pinfo->current_proto =
		//	proto_get_protocol_short_name(handle->protocol);
	}

	if (handle->is_new) {
		//EP_CHECK_CANARY(("before calling handle->dissector.new for %s",handle->name));
		fprintf(stderr,"before calling handle->dissector.new for %s",handle->name);
		ret = (*handle->dissector.NEW)(tvb, pinfo/*/*, tree*/);
		//EP_CHECK_CANARY(("after calling handle->dissector.new for %s",handle->name));
		fprintf(stderr,"after calling handle->dissector.new for %s",handle->name);
	} else {
		fprintf(stderr,"before calling handle->dissector.old for %s",handle->name);
//		(*handle->dissector.old)(tvb /*, pinfo/*, tree*/);
		fprintf(stderr,"after calling handle->dissector.old for %s",handle->name);
		ret = tvb_length(tvb);
		if (ret == 0) {
			/*
			 * XXX - a tvbuff can have 0 bytes of data in
			 * it, so we have to make sure we don't return
			 * 0.
			 */
			ret = 1;
		}
	}

	pinfo->current_proto = saved_proto;

	return ret;
}
static int
call_dissector_work_error(dissector_handle_t handle, tvbuff_t *tvb,
			  packet_info *pinfo_arg/*, proto_tree *tree*/)
{
	packet_info  *pinfo = pinfo_arg;
	const char   *saved_proto;
	guint16       saved_can_desegment;
	volatile int  ret = 0;
	gboolean      save_writable;
	address       save_dl_src;
	address       save_dl_dst;
	address       save_net_src;
	address       save_net_dst;
	address       save_src;
	address       save_dst;

	/*
	* This isn't a packet being transported inside
	* the protocol whose dissector is calling us,
	* it's a copy of a packet that caused an error
	* in some protocol included in a packet that
	* reports the error (e.g., an ICMP Unreachable
	* packet).
	*/

	/*
	* Save the current state of the writability of
	* the columns, and restore them after the
	* dissector returns, so that the columns
	* don't reflect the packet that got the error,
	* they reflect the packet that reported the
	* error.
	*/
	saved_proto = pinfo->current_proto;
	saved_can_desegment = pinfo->can_desegment;

	//save_writable = col_get_writable(pinfo->cinfo);
	//col_set_writable(pinfo->cinfo, FALSE);
	save_dl_src   = pinfo->dl_src;
	save_dl_dst   = pinfo->dl_dst;
	save_net_src  = pinfo->net_src;
	save_net_dst  = pinfo->net_dst;
	save_src      = pinfo->src;
	save_dst      = pinfo->dst;

	/* Dissect the contained packet. */
	//TRY {
		ret = call_dissector_through_handle(handle, tvb,pinfo/*, tree*/);
	//}
	//CATCH(BoundsError) {
	if(BoundsError) {
		/*
		* Restore the column writability and addresses.
		*/
		//col_set_writable(pinfo->cinfo, save_writable);
		pinfo->dl_src  = save_dl_src;
		pinfo->dl_dst  = save_dl_dst;
		pinfo->net_src = save_net_src;
		pinfo->net_dst = save_net_dst;
		pinfo->src     = save_src;
		pinfo->dst     = save_dst;

		/*
		* Restore the current protocol, so any
		* "Short Frame" indication reflects that
		* protocol, not the protocol for the
		* packet that got the error.
		*/
		pinfo->current_proto = saved_proto;

		/*
		* Restore the desegmentability state.
		*/
		pinfo->can_desegment = saved_can_desegment;

		/*
		* Rethrow the exception, so this will be
		* reported as a short frame.
		*/
		//RETHROW;
	}
	//CATCH(ReportedBoundsError) {
	else if(ReportedBoundsError) {
		/*
		* "ret" wasn't set because an exception was thrown
		* before "call_dissector_through_handle()" returned.
		* As it called something, at least one dissector
		* accepted the packet, and, as an exception was
		* thrown, not only was all the tvbuff dissected,
		* a dissector tried dissecting past the end of
		* the data in some tvbuff, so we'll assume that
		* the entire tvbuff was dissected.
		*/
		ret = tvb_length(tvb);
	}
	//CATCH(OutOfMemoryError) {
	else if(OutOfMemoryError) {
		//RETHROW;
	}
	//ENDTRY;

	//col_set_writable(pinfo->cinfo, save_writable);
	pinfo->dl_src  = save_dl_src;
	pinfo->dl_dst  = save_dl_dst;
	pinfo->net_src = save_net_src;
	pinfo->net_dst = save_net_dst;
	pinfo->src     = save_src;
	pinfo->dst     = save_dst;
	pinfo->want_pdu_tracking = 0;
	return ret;
}
static GString*
g_string_truncate (GString *string,
		   gsize    len)    
{
  //g_return_val_if_fail (string != NULL, NULL);
 if(string != NULL)
	 return NULL;

  string->len = MIN (len, string->len);
  string->str[string->len] = 0;

  return string;
}
static int
call_dissector_work(dissector_handle_t handle, tvbuff_t *tvb,
		    packet_info *pinfo_arg,/**/gboolean add_proto_name)
{
 	packet_info *pinfo = pinfo_arg;
	const char  *saved_proto;
	guint16      saved_can_desegment;
	int          ret;
	gint         saved_layer_names_len = 0;

	if (handle->protocol != NULL &&
	    !proto_is_protocol_enabled(handle->protocol)) {
		/*
		 * The protocol isn't enabled.
		 */
		return 0;
	}

	saved_proto = pinfo->current_proto;
	saved_can_desegment = pinfo->can_desegment;

	if (pinfo->layer_names != NULL)
		saved_layer_names_len = (gint) pinfo->layer_names->len;
	pinfo->saved_can_desegment = saved_can_desegment;
	pinfo->can_desegment = saved_can_desegment-(saved_can_desegment>0);
	if (handle->protocol != NULL) {
		//pinfo->current_proto =
			//proto_get_protocol_short_name(handle->protocol);

		/*
		 * Add the protocol name to the layers
		 * if not told not to. Asn2wrs generated dissectors may be added multiple times otherwise.
		 */
		//if ((pinfo->layer_names)&&(add_proto_name)) {
		//	if (pinfo->layer_names->len > 0)
		//		g_string_append(pinfo->layer_names, ":");
		//		g_string_append(pinfo->layer_names,
		//		proto_get_protocol_filter_name(proto_get_id(handle->protocol)));
		//}
	}

	if (pinfo->flags.in_error_pkt) {
		ret = call_dissector_work_error(handle, tvb, pinfo/*, tree*/);
	} else {
		/*
 		 * Just call the subdissector.
 		 */
		ret = call_dissector_through_handle(handle, tvb, pinfo/*, tree*/);
	}
	if (ret == 0) {
		/*
 		 * That dissector didn't accept the packet, so
 		 * remove its protocol's name from the list
 		 * of protocols.
		 */
 		if ((pinfo->layer_names != NULL)&&(add_proto_name)) {
 			g_string_truncate(pinfo->layer_names, saved_layer_names_len);
		}
 	}
 	pinfo->current_proto = saved_proto;
 	pinfo->can_desegment = saved_can_desegment;
 	return ret;
}
static int
call_dissector_only(dissector_handle_t handle, tvbuff_t *tvb,
		    packet_info *pinfo/*, proto_tree *tree*/)
{
	int ret;

	g_assert(handle != NULL);
	ret = call_dissector_work(handle, tvb, pinfo, /*tree, */TRUE);
	return ret;
}
static int
call_dissector(dissector_handle_t handle, tvbuff_t *tvb,
	       packet_info *pinfo/* proto_tree *tree*/)
{
	int ret;
	ret = call_dissector_only(handle, tvb, pinfo/*, tree*/);
	if (ret == 0) {
		/*
		 * The protocol was disabled, or the dissector rejected
		 * it.  Just dissect this packet as data.
		 */
		g_assert(data_handle != NULL);
		g_assert(data_handle->protocol != NULL);
		call_dissector_work(data_handle, tvb, pinfo/*, tree*/, TRUE);
		return tvb_length(tvb);
	}
	return ret;
}
static /*inline*/ guint
g_hash_table_lookup_node (GHashTable    *hash_table,
                          gconstpointer  key,
                          guint         *hash_return)
{
  guint node_index;
  guint node_hash;
  guint hash_value;
  guint first_tombstone = 0;
  gboolean have_tombstone = FALSE;
  guint step = 0;

  /* If this happens, then the application is probably doing too much work
   * from a destroy notifier. The alternative would be to crash any second
   * (as keys, etc. will be NULL).
   * Applications need to either use g_hash_table_destroy, or ensure the hash
   * table is empty prior to removing the last reference using g_hash_table_unref(). */
  //g_assert (hash_table->ref_count > 0);

  hash_value = hash_table->hash_func (key);
  if (G_UNLIKELY (!HASH_IS_REAL (hash_value)))
    hash_value = 2;

  *hash_return = hash_value;

  node_index = hash_value % hash_table->mod;
  node_hash = hash_table->hashes[node_index];

  while (!HASH_IS_UNUSED (node_hash))
    {
      /* We first check if our full hash values
       * are equal so we can avoid calling the full-blown
       * key equality function in most cases.
       */
      if (node_hash == hash_value)
        {
          gpointer node_key = hash_table->keys[node_index];

/*          if (hash_table->key_equal_func)
            {
              if (hash_table->key_equal_func (node_key, key))
                return node_index;
            }
          else */if (node_key == key)
            {
              return node_index;
            }
        }
      else if (HASH_IS_TOMBSTONE (node_hash) && !have_tombstone)
        {
          first_tombstone = node_index;
          have_tombstone = TRUE;
        }

      step++;
      node_index += step;
      node_index &= hash_table->mask;
      node_hash = hash_table->hashes[node_index];
    }

  if (have_tombstone)
    return first_tombstone;

  return node_index;
}
static gpointer
g_hash_table_lookup (GHashTable    *hash_table,
                     gconstpointer  key)
{
  guint node_index;
  guint node_hash;

  //g_return_val_if_fail (hash_table != NULL, NULL);
  if(hash_table == NULL)
	  return NULL;

  node_index = g_hash_table_lookup_node (hash_table, key, &node_hash);

  return HASH_IS_REAL (hash_table->hashes[node_index])
    ? hash_table->values[node_index]
    : NULL;
}
static dtbl_entry_t *
find_string_dtbl_entry(dissector_table_t  sub_dissectors, const gchar *pattern)
{
	switch (sub_dissectors->type) {

	case FT_STRING:
	case FT_STRINGZ:
		/*
		 * You can do a string lookup in these tables.
		 */
		break;

	default:
		/*
		 * But you can't do a string lookup in any other types
		 * of tables.
		 */
		g_assert_not_reached();
	}

	/*
	 * Find the entry.
	 */
	return (dtbl_entry_t *)g_hash_table_lookup(sub_dissectors->hash_table, pattern);
}
gboolean
dissector_try_string(dissector_table_t sub_dissectors, const gchar *string,

		     tvbuff_t *tvb, packet_info *pinfo)
{
	dtbl_entry_t            *dtbl_entry;
	struct dissector_handle *handle;
	int                      ret;
	const gchar             *saved_match_string;

	/* XXX ASSERT instead ? */
	if (!string) return FALSE;
	dtbl_entry = find_string_dtbl_entry(sub_dissectors, string);
	if (dtbl_entry != NULL) {
		/*
		 * Is there currently a dissector handle for this entry?
		 */
		handle = dtbl_entry->current;
		if (handle == NULL) {
			/*
			 * No - pretend this dissector didn't exist,
			 * so that other dissectors might have a chance
			 * to dissect this packet.
			 */
			return FALSE;
		}

		/*
		 * Save the current value of "pinfo->match_string",
		 * set it to the string that matched, call the
		 * dissector, and restore "pinfo->match_string".
		 */
		saved_match_string = pinfo->match_string;
		pinfo->match_string = string;
		ret = call_dissector_work(handle, tvb, pinfo,  TRUE);
		pinfo->match_string = saved_match_string;

		/*
		 * If a new-style dissector returned 0, it means that
		 * it didn't think this tvbuff represented a packet for
		 * its protocol, and didn't dissect anything.
		 *
		 * Old-style dissectors can't reject the packet.
		 *
		 * 0 is also returned if the protocol wasn't enabled.
		 *
		 * If the packet was rejected, we return FALSE, so that
		 * other dissectors might have a chance to dissect this
		 * packet, otherwise we return TRUE.
		 */
		return ret != 0;
	}
	return FALSE;
}
static int
dissect_h225_ProtocolIdentifier(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  printf("protocolIdentifier:");
	offset = dissect_per_object_identifier_h225(tvb, offset, actx, hf_index, NULL);

  return offset;
}

int
dissect_h225_NonStandardParameter(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//#line 625 "../../asn1/h225/h225.cnf"
  nsp_handle = NULL;

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_NonStandardParameter, NonStandardParameter_sequence);

  return offset;
}
guint32
tvb_get_ipv4(tvbuff_t *tvb, const gint offset)
{
	const guint8 *ptr;
	guint32       addr;

	ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32));
	memcpy(&addr, ptr, sizeof addr);
	return addr;
}

static int
dissect_h225_T_h245Ip(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  tvbuff_t *value_tvb;
  printf("\nip: ");
  ipv4_address = 0;
  guint8* src_ip=(guint8*)malloc(sizeof(guint8));
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       4, 4, FALSE, &value_tvb);

  if (value_tvb)
    ipv4_address = tvb_get_ipv4(value_tvb, 0);
  for(int i=0;i<4;i++)
  {
  printf("%d.",tvb_get_guint8(value_tvb,i));
  src_ip[i]=tvb_get_guint8(value_tvb,i);
  }
  ip_val->h245_ip=src_ip;
  printf("\n");
  return offset;
}
static int
dissect_h225_T_h245IpPort(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf("port: ");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, &ipv4_port, FALSE);
  printf("%d\n",h_225_message_value.vendor_value);
  ip_val->h245_port=h_225_message_value.vendor_value;
  return offset;
}

static const per_sequence_t T_h245IpAddress_sequence[] = {
  { &hf_h225_h245Ip         , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_T_h245Ip },
  { &hf_h225_h245IpPort     , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_T_h245IpPort },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_h245IpAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_h245IpAddress, T_h245IpAddress_sequence);

  return offset;
}
static int
dissect_h225_OCTET_STRING_SIZE_4(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       4, 4, FALSE, NULL);

  return offset;
}
static int
dissect_h225_INTEGER_0_65535(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("port: ");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, NULL, FALSE);
  printf("%d\n",h_225_message_value.vendor_value);
  return offset;
}
static const value_string h225_T_h245Routing_vals[] = {
  {   0, "strict" },
  {   1, "loose" },
  { 0, NULL }
};
static int
dissect_h225_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static const per_choice_t T_h245Routing_choice[] = {
  {   0, &hf_h225_strict         , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_loose          , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_T_h245Routing(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_T_h245Routing, T_h245Routing_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_h245Route_sequence_of[1] = {
  { &hf_h225_h245Route_item , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_4 },
};

static int
dissect_h225_T_h245Route(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_T_h245Route, T_h245Route_sequence_of);

  return offset;
}
static const per_sequence_t T_h245IpSourceRoute_sequence[] = {
  { &hf_h225_ip             , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_4 },
  { &hf_h225_port           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_65535 },
  { &hf_h225_h245Route      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_h245Route },
  { &hf_h225_h245Routing    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_h245Routing },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_h245IpSourceRoute(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_h245IpSourceRoute, T_h245IpSourceRoute_sequence);

  return offset;
}
static int
dissect_h225_OCTET_STRING_SIZE_6(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       6, 6, FALSE, NULL);

  return offset;
}
static int
dissect_h225_OCTET_STRING_SIZE_2(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       2, 2, FALSE, NULL);

  return offset;
}

static const per_sequence_t T_h245IpxAddress_sequence[] = {
  { &hf_h225_node           , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_6 },
  { &hf_h225_netnum         , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_4 },
  { &hf_h225_h245IpxPort    , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_2 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_h245IpxAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_h245IpxAddress, T_h245IpxAddress_sequence);

  return offset;
}
static int
dissect_h225_OCTET_STRING_SIZE_16(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       16, 16, FALSE, NULL);

  return offset;
}
static const per_sequence_t T_h245Ip6Address_sequence[] = {
  { &hf_h225_h245Ip6        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_16 },
  { &hf_h225_port           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_h245Ip6Address(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_h245Ip6Address, T_h245Ip6Address_sequence);

  return offset;
}
static int
dissect_h225_OCTET_STRING_SIZE_1_20(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 20, FALSE, NULL);

  return offset;
}

static const per_choice_t H245TransportAddress_choice[] = {
  {   0, &hf_h225_h245IpAddress  , ASN1_EXTENSION_ROOT    , dissect_h225_T_h245IpAddress },
  {   1, &hf_h225_h245IpSourceRoute, ASN1_EXTENSION_ROOT    , dissect_h225_T_h245IpSourceRoute },
  {   2, &hf_h225_h245IpxAddress , ASN1_EXTENSION_ROOT    , dissect_h225_T_h245IpxAddress },
  {   3, &hf_h225_h245Ip6Address , ASN1_EXTENSION_ROOT    , dissect_h225_T_h245Ip6Address },
  {   4, &hf_h225_netBios        , ASN1_EXTENSION_ROOT    , dissect_h225_OCTET_STRING_SIZE_16 },
  {   5, &hf_h225_nsap           , ASN1_EXTENSION_ROOT    , dissect_h225_OCTET_STRING_SIZE_1_20 },
  {   6, &hf_h225_nonStandardAddress, ASN1_EXTENSION_ROOT    , dissect_h225_NonStandardParameter },
  { 0, NULL, 0, NULL }
};
static int
dissect_h225_H245TransportAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 432 "../../asn1/h225/h225.cnf"
	ipv4_address=0;
	ipv4_port=0;

	printf("SourceAddress:");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_H245TransportAddress, H245TransportAddress_choice,
                                 NULL);
  	printf("%d item\n",h_225_message_value.msg_value);
//#line 438 "../../asn1/h225/h225.cnf"
	/* we need this info for TAPing */
	/*h225_pi->is_h245 = TRUE;
	h225_pi->h245_address = ipv4_address;	
	h225_pi->h245_port = ipv4_port;	

	if((!actx->pinfo->fd->flags.visited) && ipv4_address!=0 && ipv4_port!=0 && h245_handle){
		address src_addr;
		conversation_t *conv=NULL;

		src_addr.type=AT_IPv4;
		src_addr.len=4;
		src_addr.data=(const guint8 *)&ipv4_address;*/

		/*conv=find_conversation(actx->pinfo->fd->num, &src_addr, &src_addr, PT_TCP, ipv4_port, ipv4_port, NO_ADDR_B|NO_PORT_B);
		if(!conv){
			conv=conversation_new(actx->pinfo->fd->num, &src_addr, &src_addr, PT_TCP, ipv4_port, ipv4_port, NO_ADDR2|NO_PORT2);
			conversation_set_dissector(conv, h245_handle);
		}
	}*/


  return offset;
}
static const per_sequence_t SEQUENCE_OF_AliasAddress_sequence_of[1] = {
  { &hf_h225_alertingAddress_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_AliasAddress },
};

static int
dissect_h225_SEQUENCE_OF_AliasAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
		printf("SourceAddress\n");
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_AliasAddress, SEQUENCE_OF_AliasAddress_sequence_of);

  return offset;
}
const value_string T35CountryCode_vals[] = {
	{ 0x00, "Japan"},
	{ 0x01, "Albania"},
	{ 0x02, "Algeria"},
	{ 0x03, "American Samoa"},
	{ 0x04, "Germany"},
	{ 0x05, "Anguilla"},
	{ 0x06, "Antigua and Barbuda"},
	{ 0x07, "Argentina"},
	{ 0x08, "Ascension (see S. Helena)"},
	{ 0x09, "Australia"},
	{ 0x0a, "Austria"},
	{ 0x0b, "Bahamas"},
	{ 0x0c, "Bahrain"},
	{ 0x0d, "Bangladesh"},
	{ 0x0e, "Barbados"},
	{ 0x0f, "Belgium"},
	{ 0x10, "Belize"},
	{ 0x11, "Benin"},
	{ 0x12, "Bermuda"},
	{ 0x13, "Bhutan"},
	{ 0x14, "Bolivia"},
	{ 0x15, "Botswana"},
	{ 0x16, "Brazil"},
	{ 0x17, "British Antarctic Territory"},
	{ 0x18, "British Indian Ocean Territory"},
	{ 0x19, "British Virgin Islands"},
	{ 0x1a, "Brunei Darussalam"},
	{ 0x1b, "Bulgaria"},
	{ 0x1c, "Myanmar"},
	{ 0x1d, "Burundi"},
	{ 0x1e, "Belarus"},
	{ 0x1f, "Cameroon"},
	{ 0x20, "Canada"},
	{ 0x21, "Cape Verde"},
	{ 0x22, "Cayman Islands"},
	{ 0x23, "Central African Rep."},
	{ 0x24, "Chad"},
	{ 0x25, "Chile"},
	{ 0x26, "China"},
	{ 0x27, "Colombia"},
	{ 0x28, "Comoros"},
	{ 0x29, "Congo"},
	{ 0x2a, "Cook Islands"},
	{ 0x2b, "Costa Rica"},
	{ 0x2c, "Cuba"},
	{ 0x2d, "Cyprus"},
	{ 0x2e, "Czech Rep."},
	{ 0x2f, "Cambodia"},
	{ 0x30, "Dem. People's Rep. of Korea"},
	{ 0x31, "Denmark"},
	{ 0x32, "Djibouti"},
	{ 0x33, "Dominican Rep."},
	{ 0x34, "Dominica"},
	{ 0x35, "Ecuador"},
	{ 0x36, "Egypt"},
	{ 0x37, "El Salvador"},
	{ 0x38, "Equatorial Guinea"},
	{ 0x39, "Ethiopia"},
	{ 0x3a, "Falkland Islands (Malvinas)"},
	{ 0x3b, "Fiji"},
	{ 0x3c, "Finland"},
	{ 0x3d, "France"},
	{ 0x3e, "French Polynesia"},
	/* { 0x3f, "(Available)"}, */
	{ 0x40, "Gabon"},
	{ 0x41, "Gambia"},
	{ 0x42, "Germany"},
	{ 0x43, "Angola"},
	{ 0x44, "Ghana"},
	{ 0x45, "Gibraltar"},
	{ 0x46, "Greece"},
	{ 0x47, "Grenada"},
	{ 0x48, "Guam"},
	{ 0x49, "Guatemala"},
	{ 0x4a, "Guernsey"},
	{ 0x4b, "Guinea"},
	{ 0x4c, "Guinea-Bissau"},
	{ 0x4d, "Guayana"},
	{ 0x4e, "Haiti"},
	{ 0x4f, "Honduras"},
	{ 0x50, "Hong Kong, China"},
	{ 0x51, "Hungary"},
	{ 0x52, "Iceland"},
	{ 0x53, "India"},
	{ 0x54, "Indonesia"},
	{ 0x55, "Iran (Islamic Republic of)"},
	{ 0x56, "Iraq"},
	{ 0x57, "Ireland"},
	{ 0x58, "Israel"},
	{ 0x59, "Italy"},
	{ 0x5a, "Cote d'Ivoire"},
	{ 0x5b, "Jamaica"},
	{ 0x5c, "Afghanistan"},
	{ 0x5d, "Jersey"},
	{ 0x5e, "Jordan"},
	{ 0x5f, "Kenya"},
	{ 0x60, "Kiribati"},
	{ 0x61, "Korea (Rep. of)"},
	{ 0x62, "Kuwait"},
	{ 0x63, "Lao P.D.R."},
	{ 0x64, "Lebanon"},
	{ 0x65, "Lesotho"},
	{ 0x66, "Liberia"},
	{ 0x67, "Libya"},
	{ 0x68, "Liechtenstein"},
	{ 0x69, "Luxembourg"},
	{ 0x6a, "Macao, China"},
	{ 0x6b, "Madagascar"},
	{ 0x6c, "Malaysia"},
	{ 0x6d, "Malawi"},
	{ 0x6e, "Maldives"},
	{ 0x6f, "Mali"},
	{ 0x70, "Malta"},
	{ 0x71, "Mauritania"},
	{ 0x72, "Mauritius"},
	{ 0x73, "Mexico"},
	{ 0x74, "Monaco"},
	{ 0x75, "Mongolia"},
	{ 0x76, "Montserrat"},
	{ 0x77, "Morocco"},
	{ 0x78, "Mozambique"},
	{ 0x79, "Nauru"},
	{ 0x7a, "Nepal"},
	{ 0x7b, "Netherlands"},
	{ 0x7c, "Netherlands Antilles"},
	{ 0x7d, "New Caledonia"},
	{ 0x7e, "New Zealand"},
	{ 0x7f, "Nicaragua"},
	{ 0x80, "Niger"},
	{ 0x81, "Nigeria"},
	{ 0x82, "Norway"},
	{ 0x83, "Oman"},
	{ 0x84, "Pakistan"},
	{ 0x85, "Panama"},
	{ 0x86, "Papua New Guinea"},
	{ 0x87, "Paraguay"},
	{ 0x88, "Peru"},
	{ 0x89, "Philippines"},
	{ 0x8a, "Poland"},
	{ 0x8b, "Portugal"},
	{ 0x8c, "Puerto Rico"},
	{ 0x8d, "Qatar"},
	{ 0x8e, "Romania"},
	{ 0x8f, "Rwanda"},
	{ 0x90, "Saint Kitts and Nevis"},
	{ 0x91, "Saint Croix"},
	{ 0x92, "Saint Helena and Ascension"},
	{ 0x93, "Saint Lucia"},
	{ 0x94, "San Marino"},
	{ 0x95, "Saint Thomas"},
	{ 0x96, "Sao Tome and Principe"},
	{ 0x97, "Saint Vincent and the Grenadines"},
	{ 0x98, "Saudi Arabia"},
	{ 0x99, "Senegal"},
	{ 0x9a, "Seychelles"},
	{ 0x9b, "Sierra Leone"},
	{ 0x9c, "Singapore"},
	{ 0x9d, "Solomon"},
	{ 0x9e, "Somalia"},
	{ 0x9f, "South Africa"},
	{ 0xa0, "Spain"},
	{ 0xa1, "Sri Lanka"},
	{ 0xa2, "Sudan"},
	{ 0xa3, "Suriname"},
	{ 0xa4, "Swaziland"},
	{ 0xa5, "Sweden"},
	{ 0xa6, "Switzerland"},
	{ 0xa7, "Syria"},
	{ 0xa8, "Tanzania"},
	{ 0xa9, "Thailand"},
	{ 0xaa, "Togo"},
	{ 0xab, "Tonga"},
	{ 0xac, "Trinidad and Tobago"},
	{ 0xad, "Tunisia"},
	{ 0xae, "Turkey"},
	{ 0xaf, "Turks and Caicos Islands"},
	{ 0xb0, "Tuvalu"},
	{ 0xb1, "Uganda"},
	{ 0xb2, "Ukraine"},
	{ 0xb3, "United Arab Emirates"},
	{ 0xb4, "United Kingdom"},
	{ 0xb5, "United States"},
	{ 0xb6, "Burkina Faso"},
	{ 0xb7, "Uruguay"},
	{ 0xb8, "Russia"},
	{ 0xb9, "Vanuatu"},
	{ 0xba, "Vatican"},
	{ 0xbb, "Venezuela"},
	{ 0xbc, "Viet Nam"},
	{ 0xbd, "Wallis and Futuna"},
	{ 0xbe, "Samoa"},
	{ 0xbf, "Yemen"},
	{ 0xc0, "Yemen"},
	{ 0xc1, "Yugoslavia"},
	{ 0xc2, "Dem. Rep. of the Congo"},
	{ 0xc3, "Zambia"},
	{ 0xc4, "Zimbabwe"},
	{ 0xc5, "Slovakia"},
	{ 0xc6, "Slovenia"},
	{  0, NULL }
};

static int
dissect_h225_T_t35CountryCode(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("t35CountryCode: ");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                       0U, 255U, &t35CountryCode, FALSE); 
   printf("%s",val_to_str(h_225_message_value.vendor_value, T35CountryCode_vals, "<unknown>"));  
   printf("(%d)\n",h_225_message_value.vendor_value);
  return offset;
}
const value_string T35Extension_vals[] = {
	{  0, NULL }
};

static int
dissect_h225_T_t35Extension(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
 printf("t35Extension:");
	offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, &t35Extension, FALSE);
	 printf("%d\n",h_225_message_value.vendor_value);
  return offset;
}
const value_string H221ManufacturerCode_vals[] = {
	{  0x00000000,"unknown"},
	{  0x000b2d00, "Sony"}					,                           /* From captures */
	{  0x04000042, "Deutsche Telekom AG" },                             /* From Ref. 3 */
	{  0x04000043, "Deutsche Telekom AG" },                             /* From Ref. 3 */
	{  0x04000082, "Siemens AG" },                                      /* From Ref. 3 */
	{  0x04000084, "ITO Communication" },                               /* From Ref. 3 */
	{  0x04000086, "Hauni Elektronik" },                                /* From Ref. 3 */
	{  0x04000088, "Dr.Neuhaus Mikroelektronik" },                      /* From Ref. 3 */
	{  0x0400008a, "mps Software" },                                    /* From Ref. 3 */
	{  0x0400008b, "Ferrari electronik GmbH" },                         /* From Ref. 3 */
	{  0x0400008c, "mbp Kommunikationssysteme GmbH" },                  /* From Ref. 3 */
	{  0x0400008d, "Schneider Rundfunkwerke AG" },                      /* From Ref. 3 */
	{  0x0400008e, "Digitronic computersysteme GmbH" },                 /* From Ref. 3 */
	{  0x0400008f, "DeTeWe - Deutsche Telephonwerke AG &Co" },          /* From Ref. 3 */
	{  0x04000082, "SITK Institut fuer Telekommunikation GmbH & Co KG" },/* From Ref. 3 */
	{  0x0900003D, "Equivalence (OpenH323)" },                          /* From captures */
	{  0x20000081, "Mediatrix Telecom" },                               /* From Ref. 1 */
	{  0x3c000000, "Nokia" },											/* From captures */
	{  0x3d000310, "Swissvoice" },
	{  0x3d000311, "Swissvoice" },
	{  0x3d000312, "Swissvoice" },
	{  0x3d000313, "Swissvoice" },
	{  0x3d000314, "Swissvoice" },
	{  0x3d000315, "Swissvoice" },
	{  0x3d000316, "Swissvoice" },
	{  0x3d000317, "Swissvoice" },
	{  0x3d000318, "Swissvoice" },
	{  0x3d000319, "Swissvoice" },
	{  0x3d00031a, "Swissvoice" },
	{  0x3d00031b, "Swissvoice" },
	{  0x3d00031c, "Swissvoice" },
	{  0x3d00031d, "Swissvoice" },
	{  0x3d00031e, "Swissvoice" },
	{  0x3d00031f, "Swissvoice" },
	{  0x82000002, "Ericsson" },                                        /* From captures */
	{  0x8a000003, "Teldat H. Kruszynski, M. Cichocki Sp. J." } ,		/* By email		 */
	{  0xa5000001, "Ericsson" },                                        /* From captures */
	{  0xb4000000, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000100, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000200, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000300, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000400, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000500, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000600, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000700, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000800, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000900, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000a00, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000b00, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000c00, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000d00, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000e00, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4000f00, "British Telecommunications" },                      /* From Ref. 2 */
	{  0xb4001000, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001100, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001200, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001300, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001400, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001500, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001600, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001700, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001800, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001900, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001a00, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001b00, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001c00, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001d00, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001e00, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4001f00, "GPT Video Systems" },                               /* From Ref. 2 */
	{  0xb4002000, "Marconi Communications" },                          /* From Ref. 2 */ 
	{  0xb4002100, "Indigo Active Vision Systems" },                    /* From Ref. 2 */ 
	{  0xb4002200, "LiveWorks Limited" },                               /* From Ref. 2 */ 
	{  0xb4002300, "ATL Telecom Limited" },                             /* From Ref. 2 */ 
	{  0xb4002a00, "Network Alchemy Limited" },                         /* From Ref. 2 */ 
	{  0xb4004200, "Motion Media Technology" },                         /* From Ref. 2 */ 
	{  0xb4004400, "Data Connection" },                                 /* From Ref. 2 */ 
	{  0xb4004500, "Westbay Engineers" },                               /* From Ref. 2 */ 
	{  0xb4004600, "FarSite Communications" },                               /* From Ref. 2 */ 
	{  0xb4004900, "ImageCom" },                                        /* From Ref. 2 */ 
	{  0xb4004d00, "Madge Networks" },                                  /* From Ref. 2 */ 
	{  0xb4005200, "Ridgeway Systems and Software" },                   /* From Ref. 2 */ 
	{  0xb4005300, "SpliceCom" },                                       /* From Ref. 2 */ 
	{  0xb4005400, "TeleWare" },                                        /* From Ref. 2 */ 
	{  0xb4005600, "Vegastream" },                                      /* From Ref. 2 */ 
	{  0xb4006600, "Westell" },                                         /* From Ref. 2 */ 
	{  0xb4006900, "ISDN Communications" },                             /* From Ref. 2 */ 
	{  0xb400c000, "Codian" },                                          /* From Ref. 2 */ 

	{  0xb5000000, "Compression Labs" },                                /* From Ref. 1 */
	{  0xb5000001, "PictureTel" },                                      /* From Ref. 1 */
	{  0xb5000002, "Compression Labs" },                                /* From Ref. 1 */
	{  0xb5000003, "VTEL" },                                            /* From Ref. 1 */
	{  0xb5000005, "ERIS" },                                            /* From Ref. 1 */
	{  0xb5000007, "AT&T Worldworx" },                                  /* From Ref. 1 */
	{  0xb5000009, "VideoServer" },                                     /* From Ref. 1 */
	{  0xb500000b, "3Com Corporation" },                                /* From Ref. 1 */
	{  0xb500000c, "Clarent Corporation" },                             /* From Ref. 1 */
	{  0xb500000d, "Genesys Telecommunications Labs Inc" },             /* From Ref. 1 */
	{  0xb500000e, "C-Phone Corporation." },                            /* From Ref. 1 */
	{  0xb500000f, "Science Dynamics Corporation" },                    /* From Ref. 1 */
	{  0xb5000010, "AT&T Starpoint" },                                  /* From Ref. 1 */
	{  0xb5000011, "Netscape Conference" },                             /* From Ref. 1 */
	{  0xb5000012, "Cisco" },                                           /* From Ref. 1 */
	{  0xb5000013, "Cirilium, Inc." },                                  /* From Ref. 1 */
	{  0xb5000014, "Ascend Communications, Inc." },                     /* From Ref. 1 */
	{  0xb5000015, "RADVision, Inc." },                                 /* From Ref. 1 */
	{  0xb5000016, "Objective Communications" },                        /* From Ref. 1 */
	{  0xb5000017, "VocalTec Communications, Inc." },                   /* From Ref. 1 */
	{  0xb5000018, "Serome Technology, Inc." },                         /* From Ref. 1 */
	{  0xb5000019, "Aspect Communications" },                           /* From Ref. 1 */
	{  0xb500001a, "Cintech Tele-Management" },                         /* From Ref. 1 */
	{  0xb500001b, "Philips Video Conferencing Systems" },              /* From Ref. 1 */
	{  0xb500001c, "Vertical Networks, Inc." },                         /* From Ref. 1 */
	{  0xb500001d, "Syndeo Corp." },                                    /* From Ref. 1 */
	{  0xb500001e, "Telxon Corporation" },                              /* From Ref. 1 */
	{  0xb500001f, "Network Equipment Technologies" },                  /* From Ref. 1 */
	{  0xb5000020, "Pagoo, Inc." },                                     /* From Ref. 1 */
	{  0xb5000021, "General Dynamics" },                                /* From Ref. 1 */
	{  0xb5000022, "Vanguard Managed Solutions" },                      /* From Ref. 1 */
	{  0xb5000023, "TeleStream Technologies, Inc." },                   /* From Ref. 1 */
	{  0xb5000024, "Spirent Communications" },                          /* From Ref. 1 */
	{  0xb5000025, "CrystalVoice Communications" },                     /* From Ref. 1 */
	{  0xb5000026, "Xiph.org" },                                        /* From Ref. 1 */
	{  0xb5000027, "NACT Telecommunications" },                         /* From Ref. 1 */
	{  0xb5000028, "AudioCodes, Inc." },                                /* From Ref. 1 */
	{  0xb5000120, "AT&T - GBCS" },                                     /* From Ref. 1 */
	{  0xb5000168, "Leadtek Research Inc." },                           /* From Ref. 1 */
	{  0xb5000247, "Lucent Technologies" },                             /* From Ref. 1 */
	{  0xb500029a, "Symbol Technologies Inc." },                        /* From Ref. 1 */
	{  0xb5000378, "StarVox, Inc." },                                   /* From Ref. 1 */
	{  0xb50003f7, "Inari Inc." },                                      /* From Ref. 1 */
	{  0xb5000727, "Quintum Technologies, Inc." },                      /* From Ref. 1 */
	{  0xb5000918, "Netrix Corporation" },                              /* From Ref. 1 */
	{  0xb500101e, "SysMaster Corporation" },                           /* From Ref. 1 */
	{  0xb5001a1a, "Alpha Telecom, Inc. U.S.A." },                      /* From Ref. 1 */
	{  0xb5002331, "ViaVideo" },                                        /* From Ref. 1 */
	{  0xb500301c, "Congruency, Inc." },                                /* From Ref. 1 */
	{  0xb5003039, "MiBridge Inc." },                                   /* From Ref. 1 */
	{  0xb5003838, "8x8 Inc." },                                        /* From Ref. 1 */
	{  0xb5004147, "Agere Systems" },                                   /* From Ref. 1 */
	{  0xb5004153, "Artisoft Inc." },                                   /* From Ref. 1 */
	{  0xb5004156, "Avaya" },                                           /* From Ref. 1 */
	{  0xb5004242, "IBM." },                                            /* From Ref. 1 */
	{  0xb5004257, "StreamComm" },                                      /* From Ref. 1 */

	{  0xb5004c54, "Lucent Technologies" },                             /* From Ref. 1 */
	{  0xb5004d47, "MediaGate" },                                       /* From Ref. 1 */
	{  0xb5004e54, "Nortel Networks" },                                 /* From Ref. 1 */

	{  0xb5005243, "Siemens Business Communication Systems" },          /* From Ref. 1 */
	{  0xb500534c, "Microsoft" },                                       /* From Ref. 1 */

	{  0xb500600d, "Lucent Technologies" },                             /* From Ref. 1 */

	{  0xb5008080, "Intel" },                                           /* From Ref. 1 */
	{  0xa5000001, "Ericsson" },                                        /* From captures */
	{  0, NULL }
};
static int
dissect_h225_T_manufacturerCode(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("manufacturercod:");
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, &manufacturerCode, FALSE);

  printf("%d\n",h_225_message_value.vendor_value);
   //printf("%s",val_to_str(h_225_message_value.vendor_value, H221ManufacturerCode_vals, "<unknown>"));  
  return offset;
}
static const per_sequence_t H221NonStandard_sequence[] = {
  { &hf_h225_t35CountryCode , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_t35CountryCode },
  { &hf_h225_t35Extension   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_t35Extension },
  { &hf_h225_manufacturerCode, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_manufacturerCode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_H221NonStandard(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  t35CountryCode = 0;
  t35Extension = 0;
  manufacturerCode = 0;
  printf("vendor\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_H221NonStandard, H221NonStandard_sequence);

  h221NonStandard = ((t35CountryCode * 256) + t35Extension) * 65536 + manufacturerCode;
 // proto_tree_add_uint( hf_h221Manufacturer, tvb, (offset>>3)-4, 4, h221NonStandard);
  printf("H.225 Manufacturer:%s(0x%2x)\n",val_to_str(h221NonStandard, H221ManufacturerCode_vals, "<unknown>"),h221NonStandard);  

  return offset;
}
static int
dissect_h225_OCTET_STRING_SIZE_1_256(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("productID: ");
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 256, FALSE, NULL);
  printf(" %s\n",h_225_message_value.data_output);

  return offset;
}

static int
dissect_h225_OCTET_STRING_SIZE_V1_256(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("versionID:");
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 256, FALSE, NULL);
  printf(" %s\n",h_225_message_value.data_output);

  return offset;
}

static int
dissect_h225_OBJECT_IDENTIFIER(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_object_identifier(tvb, offset, actx, hf_index, NULL);

  return offset;
}
static const per_sequence_t VendorIdentifier_sequence[] = {
  { &hf_h225_vendorIdentifier_vendor, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_H221NonStandard },
  { &hf_h225_productId      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_OCTET_STRING_SIZE_1_256 },
  { &hf_h225_versionId      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_OCTET_STRING_SIZE_V1_256 },
  { &hf_h225_enterpriseNumber, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_OBJECT_IDENTIFIER },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_VendorIdentifier(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("vendor\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_VendorIdentifier, VendorIdentifier_sequence);

  return offset;
}
static const per_sequence_t GatekeeperInfo_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_GatekeeperInfo(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_GatekeeperInfo, GatekeeperInfo_sequence);

  return offset;
}

const value_string h225_SupportedProtocols_vals[] = {
  {   0, "nonStandardData" },
  {   1, "h310" },
  {   2, "h320" },
  {   3, "h321" },
  {   4, "h322" },
  {   5, "h323" },
  {   6, "h324" },
  {   7, "voice" },
  {   8, "t120-only" },
  {   9, "nonStandardProtocol" },
  {  10, "t38FaxAnnexbOnly" },
  {  11, "sip" },
  { 0, NULL }
};
int
dissect_h225_BandWidth(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 4294967295U, NULL, FALSE);

  return offset;
}

static int
dissect_h225_INTEGER_1_256(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 256U, NULL, FALSE);

  return offset;
}

static const per_sequence_t DataRate_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_channelRate    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BandWidth },
  { &hf_h225_channelMultiplier, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_INTEGER_1_256 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_DataRate(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_DataRate, DataRate_sequence);

  return offset;
}
static const per_sequence_t SEQUENCE_OF_DataRate_sequence_of[1] = {
  { &hf_h225_dataRatesSupported_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_DataRate },
};

static int
dissect_h225_SEQUENCE_OF_DataRate(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_DataRate, SEQUENCE_OF_DataRate_sequence_of);

  return offset;
}
static const per_sequence_t SupportedPrefix_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_prefix         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_AliasAddress },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_SupportedPrefix(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_SupportedPrefix, SupportedPrefix_sequence);

  return offset;
}

static const per_sequence_t SEQUENCE_OF_SupportedPrefix_sequence_of[1] = {
  { &hf_h225_supportedPrefixes_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_SupportedPrefix },
};

static int
dissect_h225_SEQUENCE_OF_SupportedPrefix(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_SupportedPrefix, SEQUENCE_OF_SupportedPrefix_sequence_of);

  return offset;
}

static const per_sequence_t H310Caps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_H310Caps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_H310Caps, H310Caps_sequence);

  return offset;
}


static const per_sequence_t H320Caps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_H320Caps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_H320Caps, H320Caps_sequence);

  return offset;
}


static const per_sequence_t H321Caps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_H321Caps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_H321Caps, H321Caps_sequence);

  return offset;
}


static const per_sequence_t H322Caps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_H322Caps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_H322Caps, H322Caps_sequence);

  return offset;
}


static const per_sequence_t H323Caps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_H323Caps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_H323Caps, H323Caps_sequence);

  return offset;
}


static const per_sequence_t H324Caps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_H324Caps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_H324Caps, H324Caps_sequence);

  return offset;
}


static const per_sequence_t VoiceCaps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_VoiceCaps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_VoiceCaps, VoiceCaps_sequence);

  return offset;
}


static const per_sequence_t T120OnlyCaps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T120OnlyCaps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T120OnlyCaps, T120OnlyCaps_sequence);

  return offset;
}
static const per_sequence_t NonStandardProtocol_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_NonStandardProtocol(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_NonStandardProtocol, NonStandardProtocol_sequence);

  return offset;
}



static const per_sequence_t T38FaxAnnexbOnlyCaps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { &hf_h225_t38FaxProtocol , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_DataProtocolCapability },
  { &hf_h225_t38FaxProfile  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h245_T38FaxProfile },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T38FaxAnnexbOnlyCaps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T38FaxAnnexbOnlyCaps, T38FaxAnnexbOnlyCaps_sequence);

  return offset;
}
static const per_sequence_t SIPCaps_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_dataRatesSupported, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DataRate },
  { &hf_h225_supportedPrefixes, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_SupportedPrefix },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_SIPCaps(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_SIPCaps, SIPCaps_sequence);

  return offset;
}

static const per_choice_t SupportedProtocols_choice[] = {
  {   0, &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , dissect_h225_NonStandardParameter },
  {   1, &hf_h225_h310           , ASN1_EXTENSION_ROOT    , dissect_h225_H310Caps },
  {   2, &hf_h225_h320           , ASN1_EXTENSION_ROOT    , dissect_h225_H320Caps },
  {   3, &hf_h225_h321           , ASN1_EXTENSION_ROOT    , dissect_h225_H321Caps },
  {   4, &hf_h225_h322           , ASN1_EXTENSION_ROOT    , dissect_h225_H322Caps },
  {   5, &hf_h225_h323           , ASN1_EXTENSION_ROOT    , dissect_h225_H323Caps },
  {   6, &hf_h225_h324           , ASN1_EXTENSION_ROOT    , dissect_h225_H324Caps },
  {   7, &hf_h225_voice          , ASN1_EXTENSION_ROOT    , dissect_h225_VoiceCaps },
  {   8, &hf_h225_t120_only      , ASN1_EXTENSION_ROOT    , dissect_h225_T120OnlyCaps },
  {   9, &hf_h225_nonStandardProtocol, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NonStandardProtocol },
  {  10, &hf_h225_t38FaxAnnexbOnly, ASN1_NOT_EXTENSION_ROOT, dissect_h225_T38FaxAnnexbOnlyCaps },
  {  11, &hf_h225_sip            , ASN1_NOT_EXTENSION_ROOT, dissect_h225_SIPCaps },
  { 0, NULL, 0, NULL }
};

int
dissect_h225_SupportedProtocols(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_SupportedProtocols, SupportedProtocols_choice,
                                 NULL);

  return offset;
}

static const per_sequence_t SEQUENCE_OF_SupportedProtocols_sequence_of[1] = {
  { &hf_h225_desiredProtocols_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_SupportedProtocols },
};

static int
dissect_h225_SEQUENCE_OF_SupportedProtocols(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_SupportedProtocols, SEQUENCE_OF_SupportedProtocols_sequence_of);

  return offset;
}

static const per_sequence_t GatewayInfo_sequence[] = {
  { &hf_h225_protocol       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_SupportedProtocols },
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_GatewayInfo(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_GatewayInfo, GatewayInfo_sequence);

  return offset;
}
static const per_sequence_t McuInfo_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_protocol       , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_SupportedProtocols },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_McuInfo(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_McuInfo, McuInfo_sequence);

  return offset;
}
static const per_sequence_t TerminalInfo_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_TerminalInfo(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("terminal\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_TerminalInfo, TerminalInfo_sequence);

  return offset;
}
static int
dissect_h225_BOOLEAN_mc(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("mc: ");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_225_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h225_BOOLEAN_undifindnod(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("UndifiendNode: ");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_225_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}

static int
dissect_h225_BIT_STRING_SIZE_32(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_bit_string(tvb, offset, actx, hf_index,
                                     32, 32, FALSE, NULL);

  return offset;
}






static const value_string h225_TunnelledProtocol_id_vals[] = {
  {   0, "tunnelledProtocolObjectID" },
  {   1, "tunnelledProtocolAlternateID" },
  { 0, NULL }
};
static int
dissect_h225_T_tunnelledProtocolObjectID(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_object_identifier_str(tvb, offset, actx, hf_index, &tpOID);

  return offset;
}
static const per_choice_t TunnelledProtocol_id_choice[] = {
  {   0, &hf_h225_tunnelledProtocolObjectID, ASN1_EXTENSION_ROOT    , dissect_h225_T_tunnelledProtocolObjectID },
  {   1, &hf_h225_tunnelledProtocolAlternateID, ASN1_EXTENSION_ROOT    , dissect_h225_TunnelledProtocolAlternateIdentifier },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_TunnelledProtocol_id(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_TunnelledProtocol_id, TunnelledProtocol_id_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t TunnelledProtocol_sequence[] = {
  { &hf_h225_tunnelledProtocol_id, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_TunnelledProtocol_id },
  { &hf_h225_subIdentifier  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_IA5String_SIZE_1_64 },
  { NULL, 0, 0, NULL }
};

int
dissect_h225_TunnelledProtocol(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//#line 570 "../../asn1/h225/h225.cnf"
	
	
  tpOID = "";

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_TunnelledProtocol, TunnelledProtocol_sequence);

//#line 572 "../../asn1/h225/h225.cnf"
  tp_handle = dissector_get_string_handle(tp_dissector_table, tpOID);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_TunnelledProtocol_sequence_of[1] = {
  { &hf_h225_supportedTunnelledProtocols_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_TunnelledProtocol },
};

static int
dissect_h225_SEQUENCE_OF_TunnelledProtocol(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_TunnelledProtocol, SEQUENCE_OF_TunnelledProtocol_sequence_of);

  return offset;
}

static const per_sequence_t EndpointType_sequence[] = {
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_vendor         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_VendorIdentifier },
  { &hf_h225_gatekeeper     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_GatekeeperInfo },
  { &hf_h225_gateway        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_GatewayInfo },
  { &hf_h225_mcu            , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_McuInfo },
  { &hf_h225_terminal       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TerminalInfo },
  { &hf_h225_mc             , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_mc },
  { &hf_h225_undefinedNode  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_undifindnod },
  { &hf_h225_set            , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_BIT_STRING_SIZE_32 },
  { &hf_h225_supportedTunnelledProtocols, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_TunnelledProtocol },
  { NULL, 0, 0, NULL }
};

int
dissect_h225_EndpointType(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("DestnationInfo\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_EndpointType, EndpointType_sequence);

  return offset;
}
int
dissect_h225_CallReferenceValue(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 65535U, NULL, FALSE);

  return offset;
}
static const per_sequence_t SEQUENCE_OF_CallReferenceValue_sequence_of[1] = {
  { &hf_h225_destExtraCRV_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_CallReferenceValue },
};

static int
dissect_h225_SEQUENCE_OF_CallReferenceValue(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_CallReferenceValue, SEQUENCE_OF_CallReferenceValue_sequence_of);

  return offset;
}
static int
dissect_h225_BOOLEAN_mediaWaitForConnect(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("mediaWaitForConnect: ");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_225_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h225_BOOLEAN_canOverlapSend(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("canOverlapSend: ");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_225_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h225_BOOLEAN_multiplecalls(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("multiplecalls: ");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_225_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h225_BOOLEAN_maintainConnection(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("maintainConnection: ");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_225_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
static int
dissect_h225_BOOLEAN_activeMC(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("activeMC: ");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);
  if(h_225_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}
int
dissect_h225_GloballyUniqueID(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       16, 16, FALSE,/*actx->value_ptr*/NULL);
  	/*printf("%x\n",h_225_message_value.id);*/
  return offset;
}
int
dissect_h225_ConferenceIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf("confrenceID:");
  offset = dissect_h225_GloballyUniqueID(tvb, offset, actx, hf_index);

  return offset;
}
static const value_string h225_T_conferenceGoal_vals[] = {
  {   0, "create" },
  {   1, "join" },
  {   2, "invite" },
  {   3, "capability-negotiation" },
  {   4, "callIndependentSupplementaryService" },
  { 0, NULL }
};
static int
dissect_h225_create_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, h225_T_conferenceGoal_vals, "<unknown>"),	h_225_message_value.msg_value);
  printf("create: ");
	offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static int
dissect_join_h225_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, h225_T_conferenceGoal_vals, "<unknown>"),	h_225_message_value.msg_value);
  printf("join: ");
	offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static int
dissect_h225_invite_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, h225_T_conferenceGoal_vals, "<unknown>"),	h_225_message_value.msg_value);
  printf("invite: ");
	offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static int
dissect_capability_negotiation_h225_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, h225_T_conferenceGoal_vals, "<unknown>"),	h_225_message_value.msg_value);
  printf("capability_negotiation: ");
	offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static int
dissect_h225_callIndependentSupplementaryService_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, h225_T_conferenceGoal_vals, "<unknown>"),	h_225_message_value.msg_value);
  printf("callIndependentSupplementaryService: ");
	offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static const per_choice_t T_conferenceGoal_choice[] = {
  {   0, &hf_h225_create         , ASN1_EXTENSION_ROOT    , dissect_h225_create_NULL },
  {   1, &hf_h225_join           , ASN1_EXTENSION_ROOT    , dissect_join_h225_NULL },
  {   2, &hf_h225_invite         , ASN1_EXTENSION_ROOT    , dissect_h225_invite_NULL },
  {   3, &hf_h225_capability_negotiation, ASN1_NOT_EXTENSION_ROOT, dissect_capability_negotiation_h225_NULL },
  {   4, &hf_h225_callIndependentSupplementaryService, ASN1_NOT_EXTENSION_ROOT, dissect_h225_callIndependentSupplementaryService_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_T_conferenceGoal(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf("conferenceGoal:");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_T_conferenceGoal, T_conferenceGoal_choice,
                                 NULL);

  return offset;
}
static int
dissect_h225_BOOLEAN(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);

  return offset;
}

static const per_sequence_t Q954Details_sequence[] = {
  { &hf_h225_conferenceCalling, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { &hf_h225_threePartyService, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_Q954Details(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_Q954Details, Q954Details_sequence);

  return offset;
}

static const per_sequence_t QseriesOptions_sequence[] = {
  { &hf_h225_q932Full       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { &hf_h225_q951Full       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { &hf_h225_q952Full       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { &hf_h225_q953Full       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { &hf_h225_q955Full       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { &hf_h225_q956Full       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { &hf_h225_q957Full       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { &hf_h225_q954Info       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_Q954Details },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_QseriesOptions(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_QseriesOptions, QseriesOptions_sequence);

  return offset;
}
static const value_string h225_CallType_vals[] = {
  {   0, "pointToPoint" },
  {   1, "oneToN" },
  {   2, "nToOne" },
  {   3, "nToN" },
  { 0, NULL }
};
static int
dissect_h225_pointToPoint_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf(" %s (%d)\n", val_to_str(h_225_message_value.msg_value, h225_CallType_vals, "<unknown>"),h_225_message_value.msg_value);
	printf("pointToPoint: ");
	offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static int
dissect_h225_oneToN_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf(" %s (%d)\n", val_to_str(h_225_message_value.msg_value, h225_CallType_vals, "<unknown>"),h_225_message_value.msg_value);
	printf("oneToN: ");
	offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static int
dissect_h225_nToOne_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf(" %s (%d)\n", val_to_str(h_225_message_value.msg_value, h225_CallType_vals, "<unknown>"),h_225_message_value.msg_value);
	printf("nToOne: ");
	offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static int
dissect_h225_nToN_NULL(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf(" %s (%d)\n", val_to_str(h_225_message_value.msg_value, h225_CallType_vals, "<unknown>"),h_225_message_value.msg_value);
	printf("nToN: ");
	offset = dissect_per_null(tvb, offset, actx, hf_index);

  return offset;
}
static const per_choice_t CallType_choice[] = {
  {   0, &hf_h225_pointToPoint   , ASN1_EXTENSION_ROOT    , dissect_h225_pointToPoint_NULL },
  {   1, &hf_h225_oneToN         , ASN1_EXTENSION_ROOT    , dissect_h225_oneToN_NULL },
  {   2, &hf_h225_nToOne         , ASN1_EXTENSION_ROOT    , dissect_h225_nToOne_NULL },
  {   3, &hf_h225_nToN           , ASN1_EXTENSION_ROOT    , dissect_h225_nToN_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_CallType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf("CallType: ");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_CallType, CallType_choice,
                                 NULL);

  return offset;
}
void
tvb_get_ntohguid(tvbuff_t *tvb, const gint offset, e_guid_t *guid)
{
	ensure_contiguous(tvb, offset, sizeof(*guid));
	guid->data1 = tvb_get_ntohl(tvb, offset);
	guid->data2 = tvb_get_ntohs(tvb, offset + 4);
	guid->data3 = tvb_get_ntohs(tvb, offset + 6);
	tvb_memcpy(tvb, guid->data4, offset + 8, sizeof guid->data4);
}
static int
dissect_h225_T_guid(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 544 "../../asn1/h225/h225.cnf"
  tvbuff_t *guid_tvb = NULL;

  actx->value_ptr = &guid_tvb;
  printf("guid:");
  offset = dissect_h225_GloballyUniqueID(tvb, offset, actx, hf_index);

  if (guid_tvb)
    tvb_get_ntohguid(guid_tvb, 0, call_id_guid =(e_guid_t*) malloc(sizeof(e_guid_t)));
  actx->value_ptr = NULL;


  return offset;
}


static const per_sequence_t CallIdentifier_sequence[] = {
  { &hf_h225_guid           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_guid },
  { NULL, 0, 0, NULL }
};

int
dissect_h225_CallIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf("callIdentier\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CallIdentifier, CallIdentifier_sequence);

  return offset;
}
static const per_choice_t SecurityServiceMode_choice[] = {
  {   0, &hf_h225_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h225_NonStandardParameter },
  {   1, &hf_h225_none           , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_default        , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_SecurityServiceMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_SecurityServiceMode, SecurityServiceMode_choice,
                                 NULL);

  return offset;
}

static const per_sequence_t SecurityCapabilities_sequence[] = {
  { &hf_h225_nonStandard    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_encryption     , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_SecurityServiceMode },
  { &hf_h225_authenticaton  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_SecurityServiceMode },
  { &hf_h225_securityCapabilities_integrity, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_SecurityServiceMode },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_SecurityCapabilities(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_SecurityCapabilities, SecurityCapabilities_sequence);

  return offset;
}


static const value_string h225_H245Security_vals[] = {
  {   0, "nonStandard" },
  {   1, "noSecurity" },
  {   2, "tls" },
  {   3, "ipsec" },
  { 0, NULL }
};

static const per_choice_t H245Security_choice[] = {
  {   0, &hf_h225_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h225_NonStandardParameter },
  {   1, &hf_h225_noSecurity     , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_tls            , ASN1_EXTENSION_ROOT    , dissect_h225_SecurityCapabilities },
  {   3, &hf_h225_ipsec          , ASN1_EXTENSION_ROOT    , dissect_h225_SecurityCapabilities },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_H245Security(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_H245Security, H245Security_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_H245Security_sequence_of[1] = {
  { &hf_h225_h245SecurityCapability_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_H245Security },
};

static int
dissect_h225_SEQUENCE_OF_H245Security(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_H245Security, SEQUENCE_OF_H245Security_sequence_of);

  return offset;
}
static const value_string h235_Element_vals[] = {
  {   0, "octets" },
  {   1, "integer" },
  {   2, "bits" },
  {   3, "name" },
  {   4, "flag" },
  { 0, NULL }
};

static int
dissect_h235_OCTET_STRING(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, NULL);

  return offset;
}
static int
dissect_h235_INTEGER(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_integer(tvb, offset, actx, hf_index, NULL);

  return offset;
}
static int
dissect_h235_BIT_STRING(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_bit_string(tvb, offset, actx, hf_index,
                                     NO_BOUND, NO_BOUND, FALSE, NULL);

  return offset;
}
static int
dissect_h235_BMPString(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          NO_BOUND, NO_BOUND, FALSE);

  return offset;
}
static int
dissect_h235_BOOLEAN(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, NULL);

  return offset;
}
static const per_choice_t Element_choice[] = {
  {   0, &hf_h235_octets         , ASN1_EXTENSION_ROOT    , dissect_h235_OCTET_STRING },
  {   1, &hf_h235_integer        , ASN1_EXTENSION_ROOT    , dissect_h235_INTEGER },
  {   2, &hf_h235_bits           , ASN1_EXTENSION_ROOT    , dissect_h235_BIT_STRING },
  {   3, &hf_h235_name           , ASN1_EXTENSION_ROOT    , dissect_h235_BMPString },
  {   4, &hf_h235_flag           , ASN1_EXTENSION_ROOT    , dissect_h235_BOOLEAN },
  { 0, NULL, 0, NULL }
};

static int
dissect_h235_Element(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h235_Element, Element_choice,
                                 NULL);

  return offset;
}
static int
dissect_h235_INTEGER_0_255(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, NULL, FALSE);

  return offset;
}
static int
dissect_h235_IV8(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       8, 8, FALSE, NULL);

  return offset;
}
static int
dissect_h235_IV16(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       16, 16, FALSE, NULL);

  return offset;
}


static int
dissect_h235_Params(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_Params, Params_sequence);

  return offset;
}
static const per_sequence_t ProfileElement_sequence[] = {
  { &hf_h235_elementID      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h235_INTEGER_0_255 },
  { &hf_h235_paramS         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_Params },
  { &hf_h235_element        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_Element },
  { NULL, 0, 0, NULL }
};

static int
dissect_h235_ProfileElement(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_ProfileElement, ProfileElement_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_ProfileElement_sequence_of[1] = {
  { &hf_h235_profileInfo_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_ProfileElement },
};

static int
dissect_h235_SEQUENCE_OF_ProfileElement(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h235_SEQUENCE_OF_ProfileElement, SEQUENCE_OF_ProfileElement_sequence_of);

  return offset;
}
static int
dissect_h235_OBJECT_IDENTIFIER(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_object_identifier(tvb, offset, actx, hf_index, NULL);

  return offset;
}
int
dissect_h235_TimeStamp(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 4294967295U, NULL, FALSE);

  return offset;
}
static int
dissect_h235_Password(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          1, 128, FALSE);

  return offset;
}
static int
dissect_h235_BIT_STRING_SIZE_0_2048(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_bit_string(tvb, offset, actx, hf_index,
                                     0, 2048, FALSE, NULL);

  return offset;
}
static const per_sequence_t DHset_sequence[] = {
  { &hf_h235_halfkey        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING_SIZE_0_2048 },
  { &hf_h235_modSize        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING_SIZE_0_2048 },
  { &hf_h235_generator      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING_SIZE_0_2048 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h235_DHset(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_DHset, DHset_sequence);

  return offset;
}
static int
dissect_h235_ChallengeString(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       8, 128, FALSE, NULL);

  return offset;
}
static int
dissect_h235_RandomVal(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_integer(tvb, offset, actx, hf_index, NULL);

  return offset;
}

static const per_sequence_t TypedCertificate_sequence[] = {
  { &hf_h235_type           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_certificatedata, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h235_OCTET_STRING },
  { NULL, 0, 0, NULL }
};

static int
dissect_h235_TypedCertificate(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_TypedCertificate, TypedCertificate_sequence);

  return offset;
}
static int
dissect_h235_Identifier(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          1, 128, FALSE);

  return offset;
}
static int
dissect_h235_NonStandardParameter(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_NonStandardParameter, NonStandardParameter_sequence);

  return offset;
}
static int
dissect_h235_BIT_STRING_SIZE_0_511(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_bit_string(tvb, offset, actx, hf_index,
                                     0, 511, FALSE, NULL);

  return offset;
}
static const per_sequence_t ECpoint_sequence[] = {
  { &hf_h235_x              , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_BIT_STRING_SIZE_0_511 },
  { &hf_h235_y              , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_BIT_STRING_SIZE_0_511 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h235_ECpoint(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_ECpoint, ECpoint_sequence);

  return offset;
}
static const per_sequence_t T_eckasdhp_sequence[] = {
  { &hf_h235_public_key     , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_ECpoint },
  { &hf_h235_modulus        , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING_SIZE_0_511 },
  { &hf_h235_base           , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_ECpoint },
  { &hf_h235_weierstrassA   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING_SIZE_0_511 },
  { &hf_h235_weierstrassB   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING_SIZE_0_511 },
  { NULL, 0, 0, NULL }
};
static int
dissect_h235_T_eckasdhp(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_T_eckasdhp, T_eckasdhp_sequence);

  return offset;
}
static const per_sequence_t T_eckasdh2_sequence[] = {
  { &hf_h235_public_key     , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_ECpoint },
  { &hf_h235_fieldSize      , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING_SIZE_0_511 },
  { &hf_h235_base           , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_ECpoint },
  { &hf_h235_weierstrassA   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING_SIZE_0_511 },
  { &hf_h235_weierstrassB   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING_SIZE_0_511 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h235_T_eckasdh2(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_T_eckasdh2, T_eckasdh2_sequence);

  return offset;
}
static const value_string h235_ECKASDH_vals[] = {
  {   0, "eckasdhp" },
  {   1, "eckasdh2" },
  { 0, NULL }
};

static const per_choice_t ECKASDH_choice[] = {
  {   0, &hf_h235_eckasdhp       , ASN1_EXTENSION_ROOT    , dissect_h235_T_eckasdhp },
  {   1, &hf_h235_eckasdh2       , ASN1_EXTENSION_ROOT    , dissect_h235_T_eckasdh2 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h235_ECKASDH(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h235_ECKASDH, ECKASDH_choice,
                                 NULL);

  return offset;
}
static int
dissect_xxx_ToBeSigned(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//PER_NOT_DECODED_YET("ToBeSigned");
  return offset;
}
static const per_sequence_t SIGNED_sequence[] = {
  { &hf_h235_toBeSigned     , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_xxx_ToBeSigned },
  { &hf_h235_algorithmOID   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_paramS         , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_Params },
  { &hf_h235_signaturedata  , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING },
  { NULL, 0, 0, NULL }
};

int
dissect_h235_SIGNED(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//#line 60 "../../asn1/h235/h235.cnf"
  //proto_item  *hidden_item;
  //hidden_item = proto_tree_add_item(tree, proto_h235, tvb, offset>>3, 0, ENC_NA);
  //PROTO_ITEM_SET_HIDDEN(hidden_item);

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_SIGNED, SIGNED_sequence);

  return offset;
}
static const per_sequence_t V3KeySyncMaterial_sequence[] = {
  { &hf_h235_generalID      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_Identifier },
  { &hf_h235_algorithmOID   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_paramS         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h235_Params },
  { &hf_h235_encryptedSessionKey, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_OCTET_STRING },
  { &hf_h235_encryptedSaltingKey, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_OCTET_STRING },
  { &hf_h235_clearSaltingKey, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_OCTET_STRING },
  { &hf_h235_paramSsalt     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_Params },
  { &hf_h235_keyDerivationOID, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_genericKeyMaterial, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h235_OCTET_STRING },
  { NULL, 0, 0, NULL }
};

static int
dissect_h235_V3KeySyncMaterial(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_V3KeySyncMaterial, V3KeySyncMaterial_sequence);

  return offset;
}
static const value_string h235_H235Key_vals[] = {
  {   0, "secureChannel" },
  {   1, "sharedSecret" },
  {   2, "certProtectedKey" },
  {   3, "secureSharedSecret" },
  { 0, NULL }
};
static int
dissect_h235_KeyMaterial(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_bit_string(tvb, offset, actx, hf_index,
                                     1, 2048, FALSE, NULL);

  return offset;
}
static const per_sequence_t ENCRYPTED_sequence[] = {
  { &hf_h235_algorithmOID   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_paramS         , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_Params },
  { &hf_h235_encryptedData  , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_OCTET_STRING },
  { NULL, 0, 0, NULL }
};

int
dissect_h235_ENCRYPTED(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//#line 65 "../../asn1/h235/h235.cnf"
  //proto_item  *hidden_item;
  //hidden_item = proto_tree_add_item(tree, proto_h235, tvb, offset>>3, 0, ENC_NA);
 // PROTO_ITEM_SET_HIDDEN(hidden_item);

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_ENCRYPTED, ENCRYPTED_sequence);

  return offset;
}
static const per_choice_t H235Key_choice[] = {
  {   0, &hf_h235_secureChannel  , ASN1_EXTENSION_ROOT    , dissect_h235_KeyMaterial },
  {   1, &hf_h235_sharedSecret   , ASN1_EXTENSION_ROOT    , dissect_h235_ENCRYPTED },
  {   2, &hf_h235_certProtectedKey, ASN1_EXTENSION_ROOT    , dissect_h235_SIGNED },
  {   3, &hf_h235_secureSharedSecret, ASN1_NOT_EXTENSION_ROOT, dissect_h235_V3KeySyncMaterial },
  { 0, NULL, 0, NULL }
};

static int
dissect_h235_H235Key(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h235_H235Key, H235Key_choice,
                                 NULL);

  return offset;
}
static const per_sequence_t ClearToken_sequence[] = {
  { &hf_h235_tokenOID       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_timeStamp      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_TimeStamp },
  { &hf_h235_password       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_Password },
  { &hf_h235_dhkey          , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_DHset },
  { &hf_h235_challenge      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_ChallengeString },
  { &hf_h235_random         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_RandomVal },
  { &hf_h235_certificate    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_TypedCertificate },
  { &hf_h235_generalID      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_Identifier },
  { &hf_h235_nonStandard    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h235_NonStandardParameter },
  { &hf_h235_eckasdhkey     , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h235_ECKASDH },
  { &hf_h235_sendersID      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h235_Identifier },
  { &hf_h235_h235Key        , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h235_H235Key },
  { &hf_h235_profileInfo    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h235_SEQUENCE_OF_ProfileElement },
  { NULL, 0, 0, NULL }
};

int
dissect_h235_ClearToken(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//#line 76 "../../asn1/h235/h235.cnf"
  //proto_item  *hidden_item;
 // hidden_item = proto_tree_add_item(tree, proto_h235, tvb, offset>>3, 0, ENC_NA);
 // PROTO_ITEM_SET_HIDDEN(hidden_item);

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_ClearToken, ClearToken_sequence);

  return offset;
}
static const per_sequence_t SEQUENCE_OF_ClearToken_sequence_of[1] = {
  { &hf_h225_tokens_item    , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_ClearToken },
};

static int
dissect_h225_SEQUENCE_OF_ClearToken(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_ClearToken, SEQUENCE_OF_ClearToken_sequence_of);

  return offset;
}
const value_string h225_CryptoH323Token_vals[] = {
  {   0, "cryptoEPPwdHash" },
  {   1, "cryptoGKPwdHash" },
  {   2, "cryptoEPPwdEncr" },
  {   3, "cryptoGKPwdEncr" },
  {   4, "cryptoEPCert" },
  {   5, "cryptoGKCert" },
  {   6, "cryptoFastStart" },
  {   7, "nestedcryptoToken" },
  { 0, NULL }
};
static const per_sequence_t HASHED_sequence[] = {
  { &hf_h235_algorithmOID   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_paramS         , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_Params },
  { &hf_h235_hash           , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_BIT_STRING },
  { NULL, 0, 0, NULL }
};

int
dissect_h235_HASHED(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//#line 70 "../../asn1/h235/h235.cnf"
 // proto_item  *hidden_item;
 // hidden_item = proto_tree_add_item(tree, proto_h235, tvb, offset>>3, 0, ENC_NA);
  //PROTO_ITEM_SET_HIDDEN(hidden_item);

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_HASHED, HASHED_sequence);

  return offset;
}
static const per_sequence_t T_cryptoEPPwdHash_sequence[] = {
  { &hf_h225_alias          , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_AliasAddress },
  { &hf_h225_timeStamp      , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_TimeStamp },
  { &hf_h225_token          , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_HASHED },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_cryptoEPPwdHash(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_cryptoEPPwdHash, T_cryptoEPPwdHash_sequence);

  return offset;
}

int
dissect_h225_GatekeeperIdentifier(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          1, 128, FALSE);

  return offset;
}
static const per_sequence_t T_cryptoGKPwdHash_sequence[] = {
  { &hf_h225_gatekeeperId   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_GatekeeperIdentifier },
  { &hf_h225_timeStamp      , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_TimeStamp },
  { &hf_h225_token          , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_HASHED },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_cryptoGKPwdHash(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_cryptoGKPwdHash, T_cryptoGKPwdHash_sequence);

  return offset;
}
static const per_sequence_t T_cryptoEncryptedToken_sequence[] = {
  { &hf_h235_tokenOID       , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_encryptedToken , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_ENCRYPTED },
  { NULL, 0, 0, NULL }
};

static int
dissect_h235_T_cryptoEncryptedToken(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_T_cryptoEncryptedToken, T_cryptoEncryptedToken_sequence);

  return offset;
}
static const per_sequence_t T_cryptoSignedToken_sequence[] = {
  { &hf_h235_tokenOID       , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_signedToken    , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_SIGNED },
  { NULL, 0, 0, NULL }
};

static int
dissect_h235_T_cryptoSignedToken(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_T_cryptoSignedToken, T_cryptoSignedToken_sequence);

  return offset;
}
static const per_sequence_t T_cryptoHashedToken_sequence[] = {
  { &hf_h235_tokenOID       , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_OBJECT_IDENTIFIER },
  { &hf_h235_hashedVals     , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_ClearToken },
  { &hf_h235_hashedToken    , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h235_HASHED },
  { NULL, 0, 0, NULL }
};

static int
dissect_h235_T_cryptoHashedToken(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h235_T_cryptoHashedToken, T_cryptoHashedToken_sequence);

  return offset;
}
const value_string h235_CryptoToken_vals[] = {
  {   0, "cryptoEncryptedToken" },
  {   1, "cryptoSignedToken" },
  {   2, "cryptoHashedToken" },
  {   3, "cryptoPwdEncr" },
  { 0, NULL }
};

static const per_choice_t CryptoToken_choice[] = {
  {   0, &hf_h235_cryptoEncryptedToken, ASN1_EXTENSION_ROOT    , dissect_h235_T_cryptoEncryptedToken },
  {   1, &hf_h235_cryptoSignedToken, ASN1_EXTENSION_ROOT    , dissect_h235_T_cryptoSignedToken },
  {   2, &hf_h235_cryptoHashedToken, ASN1_EXTENSION_ROOT    , dissect_h235_T_cryptoHashedToken },
  {   3, &hf_h235_cryptoPwdEncr  , ASN1_EXTENSION_ROOT    , dissect_h235_ENCRYPTED },
  { 0, NULL, 0, NULL }
};

int
dissect_h235_CryptoToken(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//#line 82 "../../asn1/h235/h235.cnf"
 // proto_item  *hidden_item;
 // hidden_item = proto_tree_add_item(tree, proto_h235, tvb, offset>>3, 0, ENC_NA);
 // PROTO_ITEM_SET_HIDDEN(hidden_item);

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h235_CryptoToken, CryptoToken_choice,
                                 NULL);

  return offset;
}
static const per_choice_t CryptoH323Token_choice[] = {
  {   0, &hf_h225_cryptoEPPwdHash, ASN1_EXTENSION_ROOT    , dissect_h225_T_cryptoEPPwdHash },
  {   1, &hf_h225_cryptoGKPwdHash, ASN1_EXTENSION_ROOT    , dissect_h225_T_cryptoGKPwdHash },
  {   2, &hf_h225_cryptoEPPwdEncr, ASN1_EXTENSION_ROOT    , dissect_h235_ENCRYPTED },
  {   3, &hf_h225_cryptoGKPwdEncr, ASN1_EXTENSION_ROOT    , dissect_h235_ENCRYPTED },
  {   4, &hf_h225_cryptoEPCert   , ASN1_EXTENSION_ROOT    , dissect_h235_SIGNED },
  {   5, &hf_h225_cryptoGKCert   , ASN1_EXTENSION_ROOT    , dissect_h235_SIGNED },
  {   6, &hf_h225_cryptoFastStart, ASN1_EXTENSION_ROOT    , dissect_h235_SIGNED },
  {   7, &hf_h225_nestedcryptoToken, ASN1_EXTENSION_ROOT    , dissect_h235_CryptoToken },
  { 0, NULL, 0, NULL }
};

int
dissect_h225_CryptoH323Token(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_CryptoH323Token, CryptoH323Token_choice,
                                 NULL);

  return offset;
}
static const per_sequence_t SEQUENCE_OF_CryptoH323Token_sequence_of[1] = {
  { &hf_h225_cryptoTokens_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_CryptoH323Token },
};

static int
dissect_h225_SEQUENCE_OF_CryptoH323Token(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_CryptoH323Token, SEQUENCE_OF_CryptoH323Token_sequence_of);

  return offset;
}

static int
dissect_h225_FastStart_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	tvbuff_t *value_tvb = NULL;
	char codec_str[50];

  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, &value_tvb);

	if (value_tvb && tvb_length(value_tvb)) {
		dissect_h245_FastStart_OLC(value_tvb, actx->pinfo, codec_str);
	}

    /* Add to packet info */
    g_snprintf(h225_pi->frame_label, 50, "%s %s", h225_pi->frame_label, codec_str);

	contains_faststart = TRUE;
	h225_pi->is_faststart = TRUE;


  return offset;
}


static const per_sequence_t FastStart_sequence_of[1] = {
  { &hf_h225_FastStart_item , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_FastStart_item },
};

static int
dissect_h225_FastStart(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_FastStart, FastStart_sequence_of);

  return offset;
}
static int
dissect_h225_EndpointIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          1, 128, FALSE);

  return offset;
}
static const value_string h225_ScnConnectionType_vals[] = {
  {   0, "unknown" },
  {   1, "bChannel" },
  {   2, "hybrid2x64" },
  {   3, "hybrid384" },
  {   4, "hybrid1536" },
  {   5, "hybrid1920" },
  {   6, "multirate" },
  { 0, NULL }
};

static const per_choice_t ScnConnectionType_choice[] = {
  {   0, &hf_h225_unknown        , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_bChannel       , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_hybrid2x64     , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   3, &hf_h225_hybrid384      , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   4, &hf_h225_hybrid1536     , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   5, &hf_h225_hybrid1920     , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   6, &hf_h225_multirate      , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_ScnConnectionType(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_ScnConnectionType, ScnConnectionType_choice,
                                 NULL);

  return offset;
}


static const value_string h225_ScnConnectionAggregation_vals[] = {
  {   0, "auto" },
  {   1, "none" },
  {   2, "h221" },
  {   3, "bonded-mode1" },
  {   4, "bonded-mode2" },
  {   5, "bonded-mode3" },
  { 0, NULL }
};

static const per_choice_t ScnConnectionAggregation_choice[] = {
  {   0, &hf_h225_auto           , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_none           , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_h221           , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   3, &hf_h225_bonded_mode1   , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   4, &hf_h225_bonded_mode2   , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   5, &hf_h225_bonded_mode3   , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_ScnConnectionAggregation(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_ScnConnectionAggregation, ScnConnectionAggregation_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t T_connectionParameters_sequence[] = {
  { &hf_h225_connectionType , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ScnConnectionType },
  { &hf_h225_numberOfScnConnections, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_65535 },
  { &hf_h225_connectionAggregation, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ScnConnectionAggregation },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_connectionParameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_connectionParameters, T_connectionParameters_sequence);

  return offset;
}
static int
dissect_h225_IA5String_SIZE_1_32(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_IA5String(tvb, offset, actx, hf_index,
                                          1, 32, FALSE);

  return offset;
}


static const per_sequence_t Language_sequence_of[1] = {
  { &hf_h225_Language_item  , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_IA5String_SIZE_1_32 },
};

static int
dissect_h225_Language(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_Language, Language_sequence_of);

  return offset;
}
const value_string h225_PresentationIndicator_vals[] = {
  {   0, "presentationAllowed" },
  {   1, "presentationRestricted" },
  {   2, "addressNotAvailable" },
  { 0, NULL }
};

static const per_choice_t PresentationIndicator_choice[] = {
  {   0, &hf_h225_presentationAllowed, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_presentationRestricted, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_addressNotAvailable, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

int
dissect_h225_PresentationIndicator(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_PresentationIndicator, PresentationIndicator_choice,
                                 NULL);

  return offset;
}
const value_string h225_ScreeningIndicator_vals[] = {
  {   0, "userProvidedNotScreened" },
  {   1, "userProvidedVerifiedAndPassed" },
  {   2, "userProvidedVerifiedAndFailed" },
  {   3, "networkProvided" },
  { 0, NULL }
};
/* 13 Encoding the enumerated type */
guint32
dissect_per_enumerated(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, int hf_index, guint32 root_num, guint32 *value, gboolean has_extension, guint32 ext_num, guint32 *value_map)
{

	proto_item *it=NULL;
	guint32 enum_index, val;
	guint32 start_offset = offset;
	gboolean extension_present = FALSE;
	header_field_info *hfi;

	if (has_extension) {
		/* Extension bit */
		offset = dissect_per_boolean(tvb, offset, actx, hf_per_extension_present_bit, &extension_present);
		//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
	}

	if (!extension_present) {
		/* 13.2  */
		offset = dissect_per_constrained_integer(tvb, offset, actx, hf_per_enum_index, 0, root_num - 1, &enum_index, FALSE);
		//if (!display_internal_per_fields) PROTO_ITEM_SET_HIDDEN(actx->created_item);
	} else {
		/* 13.3  */
		if (ext_num == 1) {
			/* 10.5.4	If "range" has the value 1,
			 * then the result of the encoding shall be
			 * an empty bit-field (no bits).
			 */
			enum_index = 0;
		} else {
			/* 13.3 ".. and the value shall be added to the field-list as a
			 * normally small non-negative whole number whose value is the
			 * enumeration index of the additional enumeration and with "lb" set to 0.."
			 */
			offset = dissect_per_normally_small_nonnegative_whole_number(tvb, offset, actx, hf_per_enum_extension_index, &enum_index);
		}
		enum_index += root_num;
	}
    val = (value_map && (enum_index<(root_num+ext_num))) ? value_map[enum_index] : enum_index;
	/*hfi = proto_registrar_get_nth(hf_index);
	if (IS_FT_UINT(hfi->type)) {
		it = proto_tree_add_uint(tree, hf_index, tvb, start_offset>>3, BLEN(start_offset, offset), val);
	} else {
		THROW(ReportedBoundsError);
	}
	actx->created_item = it;*/
	if (value) *value = val;
	return offset;
}

int
dissect_h225_ScreeningIndicator(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_enumerated(tvb, offset, actx, hf_index,
                                     4, NULL, TRUE, 0, NULL);

  return offset;
}
static int
dissect_h225_IA5String_SIZE_0_512(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_IA5String(tvb, offset, actx, hf_index,
                                          0, 512, FALSE);

  return offset;
}



static int
dissect_h225_H248SignalsDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, NULL);

  return offset;
}



static int
dissect_h225_BMPString_SIZE_1_512(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          1, 512, FALSE);

  return offset;
}
static const value_string h225_T_billingMode_vals[] = {
  {   0, "credit" },
  {   1, "debit" },
  { 0, NULL }
};

static const per_choice_t T_billingMode_choice[] = {
  {   0, &hf_h225_credit         , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_debit          , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_T_billingMode(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_T_billingMode, T_billingMode_choice,
                                 NULL);

  return offset;
}
static int
dissect_h225_INTEGER_1_4294967295(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 4294967295U, NULL, FALSE);

  return offset;
}
static const value_string h225_CallCreditServiceControl_callStartingPoint_vals[] = {
  {   0, "alerting" },
  {   1, "connect" },
  { 0, NULL }
};

static const per_choice_t CallCreditServiceControl_callStartingPoint_choice[] = {
  {   0, &hf_h225_alerting_flg   , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_connect_flg    , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_CallCreditServiceControl_callStartingPoint(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_CallCreditServiceControl_callStartingPoint, CallCreditServiceControl_callStartingPoint_choice,
                                 NULL);

  return offset;
}
static const per_sequence_t CallCreditServiceControl_sequence[] = {
  { &hf_h225_amountString   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_BMPString_SIZE_1_512 },
  { &hf_h225_billingMode    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_T_billingMode },
  { &hf_h225_callDurationLimit, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_INTEGER_1_4294967295 },
  { &hf_h225_enforceCallDurationLimit, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_BOOLEAN },
  { &hf_h225_callStartingPoint, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_CallCreditServiceControl_callStartingPoint },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_CallCreditServiceControl(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CallCreditServiceControl, CallCreditServiceControl_sequence);

  return offset;
}


static const value_string h225_ServiceControlDescriptor_vals[] = {
  {   0, "url" },
  {   1, "signal" },
  {   2, "nonStandard" },
  {   3, "callCreditServiceControl" },
  { 0, NULL }
};

static const per_choice_t ServiceControlDescriptor_choice[] = {
  {   0, &hf_h225_url            , ASN1_EXTENSION_ROOT    , dissect_h225_IA5String_SIZE_0_512 },
  {   1, &hf_h225_signal         , ASN1_EXTENSION_ROOT    , dissect_h225_H248SignalsDescriptor },
  {   2, &hf_h225_nonStandard    , ASN1_EXTENSION_ROOT    , dissect_h225_NonStandardParameter },
  {   3, &hf_h225_callCreditServiceControl, ASN1_EXTENSION_ROOT    , dissect_h225_CallCreditServiceControl },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_ServiceControlDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_ServiceControlDescriptor, ServiceControlDescriptor_choice,
                                 NULL);

  return offset;
}


static const value_string h225_ServiceControlSession_reason_vals[] = {
  {   0, "open" },
  {   1, "refresh" },
  {   2, "close" },
  { 0, NULL }
};

static const per_choice_t ServiceControlSession_reason_choice[] = {
  {   0, &hf_h225_open           , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_refresh        , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_close          , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_ServiceControlSession_reason(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_ServiceControlSession_reason, ServiceControlSession_reason_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t ServiceControlSession_sequence[] = {
  { &hf_h225_sessionId_0_255, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_255 },
  { &hf_h225_contents       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_ServiceControlDescriptor },
  { &hf_h225_reason         , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ServiceControlSession_reason },
  { NULL, 0, 0, NULL }
};

int
dissect_h225_ServiceControlSession(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_ServiceControlSession, ServiceControlSession_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_ServiceControlSession_sequence_of[1] = {
  { &hf_h225_serviceControl_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_ServiceControlSession },
};

static int
dissect_h225_SEQUENCE_OF_ServiceControlSession(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_ServiceControlSession, SEQUENCE_OF_ServiceControlSession_sequence_of);

  return offset;
}


static int
dissect_h225_IA5String_SIZE_1_128(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_IA5String(tvb, offset, actx, hf_index,
                                          1, 128, FALSE);

  return offset;
}
static int
dissect_h225_OCTET_STRING_SIZE_3_4(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       3, 4, FALSE, NULL);

  return offset;
}


static const per_sequence_t CarrierInfo_sequence[] = {
  { &hf_h225_carrierIdentificationCode, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_OCTET_STRING_SIZE_3_4 },
  { &hf_h225_carrierName    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_IA5String_SIZE_1_128 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_CarrierInfo(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CarrierInfo, CarrierInfo_sequence);

  return offset;
}
static const per_sequence_t CallsAvailable_sequence[] = {
  { &hf_h225_calls          , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_4294967295 },
  { &hf_h225_group_IA5String, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_IA5String_SIZE_1_128 },
  { &hf_h225_carrier        , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CarrierInfo },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_CallsAvailable(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CallsAvailable, CallsAvailable_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_CallsAvailable_sequence_of[1] = {
  { &hf_h225_voiceGwCallsAvailable_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_CallsAvailable },
};

static int
dissect_h225_SEQUENCE_OF_CallsAvailable(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_CallsAvailable, SEQUENCE_OF_CallsAvailable_sequence_of);

  return offset;
}

static const per_sequence_t CallCapacityInfo_sequence[] = {
  { &hf_h225_voiceGwCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_h310GwCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_h320GwCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_h321GwCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_h322GwCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_h323GwCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_h324GwCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_t120OnlyGwCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_t38FaxAnnexbOnlyGwCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_terminalCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_mcuCallsAvailable, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { &hf_h225_sipGwCallsAvailable, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallsAvailable },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_CallCapacityInfo(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CallCapacityInfo, CallCapacityInfo_sequence);

  return offset;
}

static const per_sequence_t CallCapacity_sequence[] = {
  { &hf_h225_maximumCallCapacity, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_CallCapacityInfo },
  { &hf_h225_currentCallCapacity, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_CallCapacityInfo },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_CallCapacity(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CallCapacity, CallCapacity_sequence);

  return offset;
}
 gboolean gef_ctx_check_signature(gef_ctx_t *gefx) {
    return gefx && (gefx->signature == GEF_CTX_SIGNATURE);
   }
gef_ctx_t* gef_ctx_get(void *ptr) {
  gef_ctx_t *gefx = (gef_ctx_t*)ptr;
  asn1_ctx_t *actx = (asn1_ctx_t*)ptr;

  if (!asn1_ctx_check_signature(actx))
    actx = NULL;

  if (actx)
    gefx = (gef_ctx_t *)actx->private_data;

  if (!gef_ctx_check_signature(gefx))
    gefx = NULL;

  return gefx;
}
static int
dissect_h225_T_parameters_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 652 "../../asn1/h225/h225.cnf"
  gef_ctx_t *parent_gefx;

  parent_gefx = gef_ctx_get(actx->private_data);
  actx->private_data = gef_ctx_alloc(parent_gefx, NULL);

  offset = dissect_h225_EnumeratedParameter(tvb, offset, actx, hf_index);

//#line 657 "../../asn1/h225/h225.cnf"
  actx->private_data = parent_gefx;

  return offset;
}
static const per_sequence_t T_parameters_sequence_of[1] = {
  { &hf_h225_parameters_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_T_parameters_item },
};

static int
dissect_h225_T_parameters(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h225_T_parameters, T_parameters_sequence_of,
                                                  1, 512, FALSE);

  return offset;
}
static const per_sequence_t GenericData_sequence[] = {
  { &hf_h225_id             , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_GenericIdentifier },
  { &hf_h225_parameters     , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_T_parameters },
  { NULL, 0, 0, NULL }
};

int
dissect_h225_GenericData(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 638 "../../asn1/h225/h225.cnf"
  void *priv_data = actx->private_data;
  gef_ctx_t *gefx;

  /* check if not inherited from FeatureDescriptor */
  gefx = gef_ctx_get(actx->private_data);
  if (!gefx) {
    gefx = gef_ctx_alloc(NULL, "GenericData");
    actx->private_data = gefx;
  }

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_GenericData, GenericData_sequence);

//#line 648 "../../asn1/h225/h225.cnf"
  actx->private_data = priv_data;

  return offset;
}
static const per_sequence_t SEQUENCE_OF_GenericData_sequence_of[1] = {
  { &hf_h225_genericData_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_GenericData },
};

static int
dissect_h225_SEQUENCE_OF_GenericData(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_GenericData, SEQUENCE_OF_GenericData_sequence_of);

  return offset;
}
static int
dissect_h225_OCTET_STRING_SIZE_2_4(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       2, 4, FALSE, NULL);

  return offset;
}


static const per_sequence_t T_cic_2_4_sequence_of[1] = {
  { &hf_h225_cic_2_4_item   , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_2_4 },
};

static int
dissect_h225_T_cic_2_4(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_T_cic_2_4, T_cic_2_4_sequence_of);

  return offset;
}



static int
dissect_h225_OCTET_STRING_SIZE_2_5(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       2, 5, FALSE, NULL);

  return offset;
}


static const per_sequence_t CicInfo_sequence[] = {
  { &hf_h225_cic_2_4        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_cic_2_4 },
  { &hf_h225_pointCode      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_2_5 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_CicInfo(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CicInfo, CicInfo_sequence);

  return offset;
}
static const per_sequence_t T_member_sequence_of[1] = {
  { &hf_h225_member_item    , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_65535 },
};

static int
dissect_h225_T_member(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_T_member, T_member_sequence_of);

  return offset;
}



static const per_sequence_t GroupID_sequence[] = {
  { &hf_h225_member         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_T_member },
  { &hf_h225_group_IA5String, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_IA5String_SIZE_1_128 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_GroupID(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_GroupID, GroupID_sequence);

  return offset;
}
static const per_sequence_t CircuitIdentifier_sequence[] = {
  { &hf_h225_cic            , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_CicInfo },
  { &hf_h225_group          , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_GroupID },
  { &hf_h225_carrier        , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CarrierInfo },
  { NULL, 0, 0, NULL }
};

int
dissect_h225_CircuitIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CircuitIdentifier, CircuitIdentifier_sequence);

  return offset;
}
static const per_sequence_t CircuitInfo_sequence[] = {
  { &hf_h225_sourceCircuitID, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_CircuitIdentifier },
  { &hf_h225_destinationCircuitID, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_CircuitIdentifier },
  { &hf_h225_genericData    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_GenericData },
  { NULL, 0, 0, NULL }
};

int
dissect_h225_CircuitInfo(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CircuitInfo, CircuitInfo_sequence);

  return offset;
}
static int
dissect_h225_FeatureDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
////#line 662 "../../asn1/h225/h225.cnf"
  void *priv_data = actx->private_data;
  actx->private_data = gef_ctx_alloc(NULL, "FeatureDescriptor");

  offset = dissect_h225_GenericData(tvb, offset, actx, hf_index);

//#line 665 "../../asn1/h225/h225.cnf"
  actx->private_data = priv_data;

  return offset;
}


static const per_sequence_t SEQUENCE_OF_FeatureDescriptor_sequence_of[1] = {
  { &hf_h225_neededFeatures_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_FeatureDescriptor },
};

static int
dissect_h225_SEQUENCE_OF_FeatureDescriptor(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_FeatureDescriptor, SEQUENCE_OF_FeatureDescriptor_sequence_of);

  return offset;
}
void next_tvb_add_handle(next_tvb_list_t *list, tvbuff_t *tvb,  dissector_handle_t handle) {
  next_tvb_item_t *item;

 item = (next_tvb_item_t*)malloc(sizeof(next_tvb_item_t));

  item->type = NTVB_HANDLE;
  item->handle = handle;
  item->tvb = tvb;
 // item->tree = tree;

  if (list->last) {
    list->last->next = item;
  } else {
    list->first = item;
  }
  item->next = NULL;
  item->previous = list->last;
  list->last = item;
  list->count++;
}

static int
dissect_h225_ParallelH245Control_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	tvbuff_t *h245_tvb = NULL;

  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, &h245_tvb);

  next_tvb_add_handle(&h245_list, h245_tvb,/* (h225_h245_in_tree)?tree:NULL,*/ h245dg_handle);


  return offset;
}
static const per_sequence_t ParallelH245Control_sequence_of[1] = {
  { &hf_h225_ParallelH245Control_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_ParallelH245Control_item },
};

static int
dissect_h225_ParallelH245Control(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_ParallelH245Control, ParallelH245Control_sequence_of);

  return offset;
}
static const per_sequence_t ExtendedAliasAddress_sequence[] = {
  { &hf_h225_extAliasAddress, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_AliasAddress },
  { &hf_h225_presentationIndicator, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_PresentationIndicator },
  { &hf_h225_screeningIndicator, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_ScreeningIndicator },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_ExtendedAliasAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_ExtendedAliasAddress, ExtendedAliasAddress_sequence);

  return offset;
}
static const per_sequence_t SEQUENCE_OF_ExtendedAliasAddress_sequence_of[1] = {
  { &hf_h225_additionalSourceAddresses_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_ExtendedAliasAddress },
};

static int
dissect_h225_SEQUENCE_OF_ExtendedAliasAddress(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_ExtendedAliasAddress, SEQUENCE_OF_ExtendedAliasAddress_sequence_of);

  return offset;
}
static int
dissect_h225_INTEGER_1_31(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            1U, 31U, NULL, FALSE);

  return offset;
}
static int
dissect_h225_BMPString_SIZE_1_80(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          1, 80, FALSE);

  return offset;
}


static const per_sequence_t DisplayName_sequence[] = {
  { &hf_h225_language_01    , ASN1_NO_EXTENSIONS     , ASN1_OPTIONAL    , dissect_h225_IA5String },
  { &hf_h225_name           , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_BMPString_SIZE_1_80 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_DisplayName(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_DisplayName, DisplayName_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_DisplayName_sequence_of[1] = {
  { &hf_h225_displayName_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_DisplayName },
};

static int
dissect_h225_SEQUENCE_OF_DisplayName(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_DisplayName, SEQUENCE_OF_DisplayName_sequence_of);

  return offset;
}
static const per_choice_t TransportAddress_choice_h225[] = {
  {   0, &hf_h225_ipAddress      , ASN1_EXTENSION_ROOT    , dissect_h225_T_ipAddress },
  {   1, &hf_h225_ipSourceRoute  , ASN1_EXTENSION_ROOT    , dissect_h225_T_ipSourceRoute },
  {   2, &hf_h225_ipxAddress     , ASN1_EXTENSION_ROOT    , dissect_h225_T_ipxAddress },
 {   3, &hf_h225_ip6Address     , ASN1_EXTENSION_ROOT    , dissect_h225_T_ip6Address },
   {   4, &hf_h225_netBios        , ASN1_EXTENSION_ROOT    , dissect_h225_OCTET_STRING_SIZE_16 },
  {   5, &hf_h225_nsap           , ASN1_EXTENSION_ROOT    , dissect_h225_OCTET_STRING_SIZE_1_20 },
  {   6, &hf_h225_nonStandardAddress, ASN1_EXTENSION_ROOT    , dissect_h225_NonStandardParameter },
  { 0, NULL, 0, NULL }
};
static int
dissect_h225_IpV4_dest(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("ip: ");
	guint8* ip=(guint8*)malloc(sizeof(guint8));
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       4, 4, FALSE, NULL);
  //printf("%d\n",h_225_message_value.data_output);
  for(int i=0;i<4;i++){
	  printf("%d.",tvb_get_guint8((tvbuff_t*)h_225_message_value.octet_ip,i));
	  ip[i]=tvb_get_guint8((tvbuff_t*)h_225_message_value.octet_ip,i);
  }
  ip_val->dest_ip = ip;
  printf("\n");
  return offset;
}
static const per_sequence_t T_ipAddress_sequence_dest[] = {
  { &hf_h225_ipV4           , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_IpV4_dest },
  { &hf_h225_ipV4_port      , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};
int
dissect_h225_T_ipAddress_dest(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("ipAddress(0)\n");
	printf("ipAddress\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_ipAddress, T_ipAddress_sequence_dest);

  return offset;
}
static const per_choice_t TransportAddress_choice_h225_dest[] = {
  {   0, &hf_h225_ipAddress      , ASN1_EXTENSION_ROOT    , dissect_h225_T_ipAddress_dest },
  {   1, &hf_h225_ipSourceRoute  , ASN1_EXTENSION_ROOT    , dissect_h225_T_ipSourceRoute },
  {   2, &hf_h225_ipxAddress     , ASN1_EXTENSION_ROOT    , dissect_h225_T_ipxAddress },
 {   3, &hf_h225_ip6Address     , ASN1_EXTENSION_ROOT    , dissect_h225_T_ip6Address },
   {   4, &hf_h225_netBios        , ASN1_EXTENSION_ROOT    , dissect_h225_OCTET_STRING_SIZE_16 },
  {   5, &hf_h225_nsap           , ASN1_EXTENSION_ROOT    , dissect_h225_OCTET_STRING_SIZE_1_20 },
  {   6, &hf_h225_nonStandardAddress, ASN1_EXTENSION_ROOT    , dissect_h225_NonStandardParameter },
  { 0, NULL, 0, NULL }
};
int
dissect_h225_TransportAddress_h225(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("DestCallSignalAddress: ");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_TransportAddress, TransportAddress_choice_h225_dest,
                                 NULL);


  return offset;
}
int
dissect_h225_TransportAddress_h225_source(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("SourceCallSignalAddress: ");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_TransportAddress, TransportAddress_choice_h225,
                                 NULL);


  return offset;
}
static const per_sequence_t Setup_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_h245Address    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_H245TransportAddress },
  { &hf_h225_sourceAddress  , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_AliasAddress },
  { &hf_h225_setup_UUIE_sourceInfo, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_EndpointType },
  { &hf_h225_destinationAddress, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_AliasAddress },
  { &hf_h225_destCallSignalAddress, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TransportAddress_h225 },
  { &hf_h225_destExtraCallInfo, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_AliasAddress },
  { &hf_h225_destExtraCRV   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CallReferenceValue },
  { &hf_h225_activeMC       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_activeMC },
  { &hf_h225_conferenceID   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ConferenceIdentifier },
  { &hf_h225_conferenceGoal , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_conferenceGoal },
  { &hf_h225_callServices   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_QseriesOptions },
  { &hf_h225_callType       , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_CallType },
  { &hf_h225_sourceCallSignalAddress, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_TransportAddress_h225_source },
  { &hf_h225_uUIE_remoteExtensionAddress, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_AliasAddress },
  { &hf_h225_callIdentifier , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_h245SecurityCapability, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_H245Security },
  { &hf_h225_tokens         , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { &hf_h225_fastStart      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FastStart },
  { &hf_h225_mediaWaitForConnect, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_mediaWaitForConnect },
  { &hf_h225_canOverlapSend , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_canOverlapSend },
  { &hf_h225_endpointIdentifier, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_EndpointIdentifier },
  { &hf_h225_multipleCalls  , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_multiplecalls },
  { &hf_h225_maintainConnection, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_maintainConnection },
  { &hf_h225_connectionParameters, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_T_connectionParameters },
  { &hf_h225_language       , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_Language },
  { &hf_h225_presentationIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_PresentationIndicator },
  { &hf_h225_screeningIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_ScreeningIndicator },
  { &hf_h225_serviceControl , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ServiceControlSession },
  { &hf_h225_symmetricOperationRequired, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_NULL },
  { &hf_h225_capacity       , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CallCapacity },
  { &hf_h225_circuitInfo    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CircuitInfo },
  { &hf_h225_desiredProtocols, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_SupportedProtocols },
  { &hf_h225_neededFeatures , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_FeatureDescriptor },
  { &hf_h225_desiredFeatures, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_FeatureDescriptor },
  { &hf_h225_supportedFeatures, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_FeatureDescriptor },
  { &hf_h225_parallelH245Control, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_ParallelH245Control },
  { &hf_h225_additionalSourceAddresses, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ExtendedAliasAddress },
  { &hf_h225_hopCount_1_31  , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_INTEGER_1_31 },
  { &hf_h225_displayName    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DisplayName },
  { NULL, 0, 0, NULL }
};
const value_string T_h323_message_body_vals[] = {
  {   0, "setup" },
  {   1, "callProceeding" },
  {   2, "connect" },
  {   3, "alerting" },
  {   4, "information" },
  {   5, "releaseComplete" },
  {   6, "facility" },
  {   7, "progress" },
  {   8, "empty" },
  {   9, "status" },
  {  10, "statusInquiry" },
  {  11, "setupAcknowledge" },
  {  12, "notify" },
  { 0, NULL }
};
static int
dissect_h225_Setup_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 386 "../../asn1/h225/h225.cnf"
	//printf(" %s (%d)\n", val_to_str(h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);

  contains_faststart = FALSE;
  printf("setup(0)\n");
  printf("setup\n");
 
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_Setup_UUIE, Setup_UUIE_sequence);

//#line 390 "../../asn1/h225/h225.cnf"
  /* Add to packet info */
  h225_pi->cs_type = H225_SETUP;
  
  if (contains_faststart == TRUE )
      g_snprintf(h225_pi->frame_label, 50, "%s OLC (%s)", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"), h225_pi->frame_label);
  else
      g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}
static const per_sequence_t FeatureSet_sequence[] = {
  { &hf_h225_replacementFeatureSet, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN },
  { &hf_h225_neededFeatures , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_FeatureDescriptor },
  { &hf_h225_desiredFeatures, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_FeatureDescriptor },
  { &hf_h225_supportedFeatures, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_FeatureDescriptor },
  { NULL, 0, 0, NULL }
};

int
dissect_h225_FeatureSet(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_FeatureSet, FeatureSet_sequence);

  return offset;
}
static const per_sequence_t CallProceeding_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_uUIE_destinationInfo, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_EndpointType },
  { &hf_h225_h245Address    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_H245TransportAddress },
  { &hf_h225_callIdentifier , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_h245SecurityMode, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_H245Security },
  { &hf_h225_tokens         , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { &hf_h225_fastStart      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FastStart },
  { &hf_h225_multipleCalls  , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_multiplecalls },
  { &hf_h225_maintainConnection, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_maintainConnection },
  { &hf_h225_fastConnectRefused, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_NULL },
  { &hf_h225_featureSet     , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FeatureSet },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_CallProceeding_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CallProceeding_UUIE, CallProceeding_UUIE_sequence);

  /* Add to packet info */
  h225_pi->cs_type = H225_CALL_PROCEDING;
  if (contains_faststart == TRUE )
        g_snprintf(h225_pi->frame_label, 50, "%s OLC (%s)", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"), h225_pi->frame_label);
  else
        g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}


static const per_sequence_t Connect_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_h245Address    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_H245TransportAddress },
  { &hf_h225_uUIE_destinationInfo, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_EndpointType },
  { &hf_h225_conferenceID   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ConferenceIdentifier },
  { &hf_h225_callIdentifier , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_h245SecurityMode, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_H245Security },
  { &hf_h225_tokens         , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { &hf_h225_fastStart      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FastStart },
  { &hf_h225_multipleCalls  , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_multiplecalls },
  { &hf_h225_maintainConnection, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_maintainConnection },
  { &hf_h225_language       , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_Language },
  { &hf_h225_connectedAddress, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_AliasAddress },
  { &hf_h225_presentationIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_PresentationIndicator },
  { &hf_h225_screeningIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_ScreeningIndicator },
  { &hf_h225_fastConnectRefused, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_NULL },
  { &hf_h225_serviceControl , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ServiceControlSession },
  { &hf_h225_capacity       , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CallCapacity },
  { &hf_h225_featureSet     , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FeatureSet },
  { &hf_h225_displayName    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DisplayName },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_Connect_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_Connect_UUIE, Connect_UUIE_sequence);


  /* Add to packet info */
  h225_pi->cs_type = H225_CONNECT;
  if (contains_faststart == TRUE )
      g_snprintf(h225_pi->frame_label, 50, "%s OLC (%s)", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"), h225_pi->frame_label);
  else 
      g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}
static const per_sequence_t Alerting_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_uUIE_destinationInfo, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_EndpointType },
  { &hf_h225_h245Address    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_H245TransportAddress },
  { &hf_h225_callIdentifier , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_h245SecurityMode, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_H245Security },
  { &hf_h225_tokens         , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { &hf_h225_fastStart      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FastStart },
  { &hf_h225_multipleCalls  , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_multiplecalls },
  { &hf_h225_maintainConnection, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_maintainConnection },
  { &hf_h225_alertingAddress, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_AliasAddress },
  { &hf_h225_presentationIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_PresentationIndicator },
  { &hf_h225_screeningIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_ScreeningIndicator },
  { &hf_h225_fastConnectRefused, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_NULL },
  { &hf_h225_serviceControl , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ServiceControlSession },
  { &hf_h225_capacity       , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CallCapacity },
  { &hf_h225_featureSet     , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FeatureSet },
  { &hf_h225_displayName    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DisplayName },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_Alerting_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_Alerting_UUIE, Alerting_UUIE_sequence);

  /* Add to packet info */
  h225_pi->cs_type = H225_ALERTING;
  if (contains_faststart == TRUE )
       g_snprintf(h225_pi->frame_label, 50, "%s OLC (%s)", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"), h225_pi->frame_label);
  else 
       g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}
static const per_sequence_t Information_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_callIdentifier , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_tokens         , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { &hf_h225_fastStart      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FastStart },
  { &hf_h225_fastConnectRefused, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_NULL },
  { &hf_h225_circuitInfo    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CircuitInfo },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_Information_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_Information_UUIE, Information_UUIE_sequence);

  /* Add to packet info */
  h225_pi->cs_type = H225_INFORMATION;
  g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}
static const value_string h225_SecurityErrors_vals[] = {
  {   0, "securityWrongSyncTime" },
  {   1, "securityReplay" },
  {   2, "securityWrongGeneralID" },
  {   3, "securityWrongSendersID" },
  {   4, "securityIntegrityFailed" },
  {   5, "securityWrongOID" },
  {   6, "securityDHmismatch" },
  {   7, "securityCertificateExpired" },
  {   8, "securityCertificateDateInvalid" },
  {   9, "securityCertificateRevoked" },
  {  10, "securityCertificateNotReadable" },
  {  11, "securityCertificateSignatureInvalid" },
  {  12, "securityCertificateMissing" },
  {  13, "securityCertificateIncomplete" },
  {  14, "securityUnsupportedCertificateAlgOID" },
  {  15, "securityUnknownCA" },
  { 0, NULL }
};

static const per_choice_t SecurityErrors_choice[] = {
  {   0, &hf_h225_securityWrongSyncTime, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_securityReplay , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_securityWrongGeneralID, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   3, &hf_h225_securityWrongSendersID, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   4, &hf_h225_securityIntegrityFailed, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   5, &hf_h225_securityWrongOID, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   6, &hf_h225_securityDHmismatch, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   7, &hf_h225_securityCertificateExpired, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   8, &hf_h225_securityCertificateDateInvalid, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   9, &hf_h225_securityCertificateRevoked, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {  10, &hf_h225_securityCertificateNotReadable, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {  11, &hf_h225_securityCertificateSignatureInvalid, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {  12, &hf_h225_securityCertificateMissing, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {  13, &hf_h225_securityCertificateIncomplete, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {  14, &hf_h225_securityUnsupportedCertificateAlgOID, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {  15, &hf_h225_securityUnknownCA, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_SecurityErrors(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_SecurityErrors, SecurityErrors_choice,
                                 NULL);

  return offset;
}
const value_string h225_ReleaseCompleteReason_vals[] = {
  {   0, "noBandwidth" },
  {   1, "gatekeeperResources" },
  {   2, "unreachableDestination" },
  {   3, "destinationRejection" },
  {   4, "invalidRevision" },
  {   5, "noPermission" },
  {   6, "unreachableGatekeeper" },
  {   7, "gatewayResources" },
  {   8, "badFormatAddress" },
  {   9, "adaptiveBusy" },
  {  10, "inConf" },
  {  11, "undefinedReason" },
  {  12, "facilityCallDeflection" },
  {  13, "securityDenied" },
  {  14, "calledPartyNotRegistered" },
  {  15, "callerNotRegistered" },
  {  16, "newConnectionNeeded" },
  {  17, "nonStandardReason" },
  {  18, "replaceWithConferenceInvite" },
  {  19, "genericDataReason" },
  {  20, "neededFeatureNotSupported" },
  {  21, "tunnelledSignallingRejected" },
  {  22, "invalidCID" },
  {  23, "securityError" },
  {  24, "hopCountExceeded" },
  { 0, NULL }
};

static const per_choice_t ReleaseCompleteReason_choice[] = {
  {   0, &hf_h225_noBandwidth    , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_gatekeeperResources, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_unreachableDestination, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   3, &hf_h225_destinationRejection, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   4, &hf_h225_invalidRevision, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   5, &hf_h225_noPermission   , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   6, &hf_h225_unreachableGatekeeper, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   7, &hf_h225_gatewayResources, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   8, &hf_h225_badFormatAddress, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   9, &hf_h225_adaptiveBusy   , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {  10, &hf_h225_inConf         , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {  11, &hf_h225_undefinedReason, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {  12, &hf_h225_facilityCallDeflection, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  13, &hf_h225_securityDenied , ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  14, &hf_h225_calledPartyNotRegistered, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  15, &hf_h225_callerNotRegistered, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  16, &hf_h225_newConnectionNeeded, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  17, &hf_h225_nonStandardReason, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NonStandardParameter },
  {  18, &hf_h225_replaceWithConferenceInvite, ASN1_NOT_EXTENSION_ROOT, dissect_h225_ConferenceIdentifier },
  {  19, &hf_h225_genericDataReason, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  20, &hf_h225_neededFeatureNotSupported, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  21, &hf_h225_tunnelledSignallingRejected, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  22, &hf_h225_invalidCID     , ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  23, &hf_h225_rLC_securityError, ASN1_NOT_EXTENSION_ROOT, dissect_h225_SecurityErrors },
  {  24, &hf_h225_hopCountExceeded, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

int
dissect_h225_ReleaseCompleteReason(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  gint32 value;
	
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_ReleaseCompleteReason, ReleaseCompleteReason_choice,
                                 &value);

  h225_pi->reason = value;


  return offset;
}
static const per_sequence_t ReleaseComplete_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_releaseCompleteReason, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_ReleaseCompleteReason },
  { &hf_h225_callIdentifier , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_tokens         , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { &hf_h225_busyAddress    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_AliasAddress },
  { &hf_h225_presentationIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_PresentationIndicator },
  { &hf_h225_screeningIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_ScreeningIndicator },
  { &hf_h225_capacity       , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CallCapacity },
  { &hf_h225_serviceControl , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ServiceControlSession },
  { &hf_h225_featureSet     , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FeatureSet },
  { &hf_h225_destinationInfo, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_EndpointType },
  { &hf_h225_displayName    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DisplayName },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_ReleaseComplete_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_ReleaseComplete_UUIE, ReleaseComplete_UUIE_sequence);

  /* Add to packet info */
  h225_pi->cs_type = H225_RELEASE_COMPLET;
  g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}

const value_string FacilityReason_vals[] = {
  {   0, "routeCallToGatekeeper" },
  {   1, "callForwarded" },
  {   2, "routeCallToMC" },
  {   3, "undefinedReason" },
  {   4, "conferenceListChoice" },
  {   5, "startH245" },
  {   6, "noH245" },
  {   7, "newTokens" },
  {   8, "featureSetUpdate" },
  {   9, "forwardedElements" },
  {  10, "transportedInformation" },
  { 0, NULL }
};

static const per_choice_t FacilityReason_choice[] = {
  {   0, &hf_h225_routeCallToGatekeeper, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_callForwarded  , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_routeCallToMC  , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   3, &hf_h225_undefinedReason, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   4, &hf_h225_conferenceListChoice, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {   5, &hf_h225_startH245      , ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {   6, &hf_h225_noH245         , ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {   7, &hf_h225_newTokens      , ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {   8, &hf_h225_featureSetUpdate, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {   9, &hf_h225_forwardedElements, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  {  10, &hf_h225_transportedInformation, ASN1_NOT_EXTENSION_ROOT, dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_FacilityReason(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	gint32 value;
	
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_FacilityReason, FacilityReason_choice,
                                 &value);

	h225_pi->reason = value;


  return offset;
}
static const per_sequence_t ConferenceList_sequence[] = {
  { &hf_h225_conferenceID   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_ConferenceIdentifier },
  { &hf_h225_conferenceAlias, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_AliasAddress },
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_ConferenceList(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_ConferenceList, ConferenceList_sequence);

  return offset;
}


static const per_sequence_t SEQUENCE_OF_ConferenceList_sequence_of[1] = {
  { &hf_h225_conferences_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_ConferenceList },
};

static int
dissect_h225_SEQUENCE_OF_ConferenceList(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_ConferenceList, SEQUENCE_OF_ConferenceList_sequence_of);

  return offset;
}
static const per_sequence_t Facility_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_alternativeAddress, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TransportAddress },
  { &hf_h225_alternativeAliasAddress, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_AliasAddress },
  { &hf_h225_conferenceID   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_ConferenceIdentifier },
  { &hf_h225_facilityReason , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_FacilityReason },
  { &hf_h225_callIdentifier , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_destExtraCallInfo, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_AliasAddress },
  { &hf_h225_uUIE_remoteExtensionAddress, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_AliasAddress },
  { &hf_h225_tokens         , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { &hf_h225_conferences    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ConferenceList },
  { &hf_h225_h245Address    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_H245TransportAddress },
  { &hf_h225_fastStart      , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FastStart },
  { &hf_h225_multipleCalls  , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_multiplecalls },
  { &hf_h225_maintainConnection, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_maintainConnection },
  { &hf_h225_fastConnectRefused, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_NULL },
  { &hf_h225_serviceControl , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ServiceControlSession },
  { &hf_h225_circuitInfo    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CircuitInfo },
  { &hf_h225_featureSet     , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_FeatureSet },
  { &hf_h225_uUIE_destinationInfo, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_EndpointType },
  { &hf_h225_h245SecurityMode, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_H245Security },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_Facility_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
    printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_Facility_UUIE, Facility_UUIE_sequence);

  /* Add to packet info */
  h225_pi->cs_type = H225_FACILITY;
  g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}
static const per_sequence_t Progress_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_uUIE_destinationInfo, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_EndpointType },
  { &hf_h225_h245Address    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_H245TransportAddress },
  { &hf_h225_callIdentifier , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_h245SecurityMode, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_H245Security },
  { &hf_h225_tokens         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { &hf_h225_fastStart      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_FastStart },
  { &hf_h225_multipleCalls  , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_multiplecalls },
  { &hf_h225_maintainConnection, ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_BOOLEAN_maintainConnection },
  { &hf_h225_fastConnectRefused, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_NULL },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_Progress_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_Progress_UUIE, Progress_UUIE_sequence);

  /* Add to packet info */
  h225_pi->cs_type = H225_PROGRESS;
  if (contains_faststart == TRUE )
        g_snprintf(h225_pi->frame_label, 50, "%s OLC (%s)", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"), h225_pi->frame_label);
  else 
        g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}
static int
dissect_h225_T_empty_flg(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	//printf(" %s (%d)\n", val_to_str(h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),h_225_message_value.msg_value);
	printf("empty(8)\n");
	printf("empty\n");
  offset = dissect_per_null(tvb, offset, actx, hf_index);

  h225_pi->cs_type = H225_EMPTY;

  return offset;
}
static const per_sequence_t Status_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_callIdentifier , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_tokens         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_Status_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_Status_UUIE, Status_UUIE_sequence);

  /* Add to packet info */
  h225_pi->cs_type = H225_STATUS;
 g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}
static const per_sequence_t StatusInquiry_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_callIdentifier , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_tokens         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_StatusInquiry_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_StatusInquiry_UUIE, StatusInquiry_UUIE_sequence);

  return offset;
}
static const per_sequence_t SetupAcknowledge_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_callIdentifier , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_tokens         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_SetupAcknowledge_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_SetupAcknowledge_UUIE, SetupAcknowledge_UUIE_sequence);

  /* Add to packet info */
  h225_pi->cs_type = H225_SETUP_ACK;
  g_snprintf(h225_pi->frame_label, 50, "%s", val_to_str(h225_pi->cs_type, T_h323_message_body_vals, "<unknown>"));

  return offset;
}
static const per_sequence_t Notify_UUIE_sequence[] = {
  { &hf_h225_protocolIdentifier, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_ProtocolIdentifier },
  { &hf_h225_callIdentifier , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_CallIdentifier },
  { &hf_h225_tokens         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_ClearToken },
  { &hf_h225_cryptoTokens   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_CryptoH323Token },
  { &hf_h225_connectedAddress, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_AliasAddress },
  { &hf_h225_presentationIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_PresentationIndicator },
  { &hf_h225_screeningIndicator, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_ScreeningIndicator },
  { &hf_h225_destinationInfo, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_EndpointType },
  { &hf_h225_displayName    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_DisplayName },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_Notify_UUIE(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf(" %s (%d)\n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"),	h_225_message_value.msg_value);
	printf(" %s \n", val_to_str(	h_225_message_value.msg_value, T_h323_message_body_vals, "<unknown>"));
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_Notify_UUIE, Notify_UUIE_sequence);

  return offset;
}


static const per_choice_t T_h323_message_body_choice[] = {
 {   0, &hf_h225_setup          , ASN1_EXTENSION_ROOT    , dissect_h225_Setup_UUIE },
   {   1, &hf_h225_callProceeding , ASN1_EXTENSION_ROOT    , dissect_h225_CallProceeding_UUIE },
  {   2, &hf_h225_connect        , ASN1_EXTENSION_ROOT    , dissect_h225_Connect_UUIE },
  {   3, &hf_h225_alerting       , ASN1_EXTENSION_ROOT    , dissect_h225_Alerting_UUIE },
  {   4, &hf_h225_information    , ASN1_EXTENSION_ROOT    , dissect_h225_Information_UUIE },
  {   5, &hf_h225_releaseComplete, ASN1_EXTENSION_ROOT    , dissect_h225_ReleaseComplete_UUIE },
  {   6, &hf_h225_facility       , ASN1_EXTENSION_ROOT    , dissect_h225_Facility_UUIE },
  {   7, &hf_h225_progress       , ASN1_NOT_EXTENSION_ROOT, dissect_h225_Progress_UUIE },
  {   8, &hf_h225_empty_flg      , ASN1_NOT_EXTENSION_ROOT, dissect_h225_T_empty_flg },
  {   9, &hf_h225_status         , ASN1_NOT_EXTENSION_ROOT, dissect_h225_Status_UUIE },
  {  10, &hf_h225_statusInquiry  , ASN1_NOT_EXTENSION_ROOT, dissect_h225_StatusInquiry_UUIE },
  {  11, &hf_h225_setupAcknowledge, ASN1_NOT_EXTENSION_ROOT, dissect_h225_SetupAcknowledge_UUIE },
  {  12, &hf_h225_notify         , ASN1_NOT_EXTENSION_ROOT, dissect_h225_Notify_UUIE },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_T_h323_message_body(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	gint32 message_body_val;
	printf("h323-message-body:");
	contains_faststart = FALSE;
	call_id_guid = NULL;
	
	
   offset = dissect_per_choice(tvb, offset, actx, /*tree,*/ hf_index,
                                 ett_h225_T_h323_message_body, T_h323_message_body_choice,
                                 &message_body_val);


	//col_append_fstr(actx->pinfo->cinfo, COL_INFO, 
 

	if (h225_pi->msg_type == H225_CS) {
		/* Don't override msg_tag value from IRR */
		h225_pi->msg_tag = message_body_val;
	}

	if (call_id_guid) {
		h225_pi->guid = *call_id_guid;
	}

	if (contains_faststart == TRUE )
	{
		//col_append_str(actx->pinfo->cinfo, 
		printf( "OpenLogicalChannel\n " );
	}

	//col_set_fence(actx->pinfo->cinfo,COL_INFO);



  return offset;
}

static int
dissect_h225_T_h4501SupplementaryService_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 558 "../../asn1/h225/h225.cnf"
	tvbuff_t *h4501_tvb = NULL;

  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, &h4501_tvb);

	if (h4501_tvb && tvb_length(h4501_tvb)) {
		//call_dissector(h4501_handle, h4501_tvb, actx->pinfo);
	}


  return offset;
}
static const per_sequence_t T_h4501SupplementaryService_sequence_of[1] = {
  { &hf_h225_h4501SupplementaryService_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_T_h4501SupplementaryService_item },
};

static int
dissect_h225_T_h4501SupplementaryService(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_T_h4501SupplementaryService, T_h4501SupplementaryService_sequence_of);

  return offset;
}
static int
dissect_h225_T_h245Tunnelling(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
	printf("h245Tunnelling: ");
  offset = dissect_per_boolean(tvb, offset, actx, hf_index, &(h225_pi->is_h245Tunneling));
  if(h_225_message_value.true_false==1){
   printf("TRUE\n");
  }
  else{
  printf("FALSE\n");
  }
  return offset;
}

static int
dissect_h225_H245Control_item(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 340 "../../asn1/h225/h225.cnf"
	tvbuff_t *h245_tvb = NULL;

  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, &h245_tvb);

  next_tvb_add_handle(&h245_list, h245_tvb,/* (h225_h245_in_tree)?tree:NULL,*/ h245dg_handle);


  return offset;
}


static const per_sequence_t H245Control_sequence_of[1] = {
  { &hf_h225_H245Control_item, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_H245Control_item },
};

static int
dissect_h225_H245Control(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_H245Control, H245Control_sequence_of);

  return offset;
}
static int
dissect_h225_SEQUENCE_OF_NonStandardParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_SEQUENCE_OF_NonStandardParameter, SEQUENCE_OF_NonStandardParameter_sequence_of);

  return offset;
}


static const per_sequence_t CallLinkage_sequence[] = {
  { &hf_h225_globalCallId   , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_GloballyUniqueID },
  { &hf_h225_threadId       , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_GloballyUniqueID },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_CallLinkage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_CallLinkage, CallLinkage_sequence);

  return offset;
}

static int
dissect_h225_T_messageContent(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_T_messageContent, T_messageContent_sequence_of);

  return offset;
}
static int
dissect_h225_IA5String_SIZE_1_64(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_IA5String(tvb, offset, actx, hf_index,
                                          1, 64, FALSE);

  return offset;
}


static const per_sequence_t TunnelledProtocolAlternateIdentifier_sequence[] = {
  { &hf_h225_protocolType   , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_IA5String_SIZE_1_64 },
  { &hf_h225_protocolVariant, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_IA5String_SIZE_1_64 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_TunnelledProtocolAlternateIdentifier(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_TunnelledProtocolAlternateIdentifier, TunnelledProtocolAlternateIdentifier_sequence);

  return offset;
}







dissector_handle_t
dissector_get_string_handle(dissector_table_t sub_dissectors,
			    const gchar *string)
{
	dtbl_entry_t  *dtbl_entry;

	dtbl_entry = find_string_dtbl_entry(sub_dissectors, string);
	if (dtbl_entry != NULL)
		return dtbl_entry->current;
	else
		return NULL;
}



static const per_sequence_t T_tunnelledSignallingMessage_sequence[] = {
  { &hf_h225_tunnelledProtocolID, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_TunnelledProtocol },
  { &hf_h225_messageContent , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_messageContent },
  { &hf_h225_tunnellingRequired, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NULL },
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_tunnelledSignallingMessage(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 578 "../../asn1/h225/h225.cnf"
  tp_handle = NULL;

  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_tunnelledSignallingMessage, T_tunnelledSignallingMessage_sequence);

  return offset;
}
static int
dissect_h225_OCTET_STRING(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, NULL);

  return offset;
}
static const per_sequence_t StimulusControl_sequence[] = {
  { &hf_h225_nonStandard    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_isText         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NULL },
  { &hf_h225_h248Message    , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_OCTET_STRING },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_StimulusControl(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_StimulusControl, StimulusControl_sequence);

  return offset;
}
//void asn1_ctx_init(asn1_ctx_t *actx, asn1_enc_e encoding, gboolean aligned, packet_info *pinfo) {
//  memset(actx, '\0', sizeof(*actx));
//  actx->signature = ASN1_CTX_SIGNATURE;
//  actx->encoding = encoding;
//  actx->aligned = aligned;
//  actx->pinfo = pinfo;
//}

gboolean asn1_ctx_check_signature(asn1_ctx_t *actx) {
  return actx && (actx->signature == ASN1_CTX_SIGNATURE);
}

void asn1_ctx_clean_external(asn1_ctx_t *actx) {
  memset(&actx->external, '\0', sizeof(actx->external));
  actx->external.hf_index = -1;
  actx->external.encoding = -1;
}


/* Generic Extensible Framework */
gef_ctx_t* gef_ctx_alloc(gef_ctx_t *parent, const gchar *type) {
  gef_ctx_t *gefx;

  //gefx = wmem_new0(wmem_packet_scope(), gef_ctx_t);
  gefx->signature = GEF_CTX_SIGNATURE;
  gefx->parent = parent;
  gefx->type = type;
  return gefx;
}



const value_string h225_GenericIdentifier_vals[] = {
  {   0, "standard" },
  {   1, "oid" },
  {   2, "nonStandard" },
  { 0, NULL }
};
static int
dissect_h225_T_standard(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 684 "../../asn1/h225/h225.cnf"
  guint32 value_int = (guint32)-1;
  gef_ctx_t *gefx;

  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 16383U, &value_int, TRUE);

  gefx = gef_ctx_get(actx->private_data);
  if (gefx) gefx->id = ep_strdup_printf("%u", value_int);


  return offset;
}

static int
dissect_h225_T_oid(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 693 "../../asn1/h225/h225.cnf"
  const gchar *oid_str = NULL;
  gef_ctx_t *gefx;

  offset = dissect_per_object_identifier_str(tvb, offset, actx, hf_index, &oid_str);

  gefx = gef_ctx_get(actx->private_data);
  if (gefx) gefx->id = oid_str;


  return offset;
}
static const per_choice_t GenericIdentifier_choice[] = {
  {   0, &hf_h225_standard       , ASN1_EXTENSION_ROOT    , dissect_h225_T_standard },
  {   1, &hf_h225_oid            , ASN1_EXTENSION_ROOT    , dissect_h225_T_oid },
  {   2, &hf_h225_genericIdentifier_nonStandard, ASN1_EXTENSION_ROOT    , dissect_h225_GloballyUniqueID },
  { 0, NULL, 0, NULL }
};
void gef_ctx_update_key(gef_ctx_t *gefx) {
  const gchar *parent_key;

  if (!gefx) return;
  parent_key = (gefx->parent) ? gefx->parent->key : NULL;
//  gefx->key = wmem_strdup_printf(wmem_packet_scope(),
  //  "%s%s"    /* parent prefix */
  //  "%s%s%s"  /* type, id */
  //  "%s%s"    /* subid */,
  //  (parent_key) ? parent_key : "", (parent_key) ? "/" : "",
  //  (gefx->type) ? gefx->type : "", (gefx->type && (gefx->id || gefx->subid)) ? "/" : "", (gefx->id) ? gefx->id : "",
  //  (gefx->subid) ? "-" : "", (gefx->subid) ? gefx->subid : ""
  //);
}
int
dissect_h225_GenericIdentifier(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
//#line 670 "../../asn1/h225/h225.cnf"
  gef_ctx_t *gefx;

  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_GenericIdentifier, GenericIdentifier_choice,
                                 NULL);

//#line 672 "../../asn1/h225/h225.cnf"
  gef_ctx_update_key(gef_ctx_get(actx->private_data));
  /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG GenericIdentifier: %s", gef_ctx_get(actx->private_data)->key);*/
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    /* DEBUG */ /*proto_tree_add_text(tree, tvb, offset>>3, 0, "*** DEBUG dissector_try_string: %s", gefx->key);*/
  /*  actx->pinfo->private_data = actx;*/
   // dissector_try_string(gef_name_dissector_table, gefx->key, tvb_new_subset(tvb, offset>>3, 0, 0), actx->pinfo);
  }
  actx->private_data = gefx;  /* subdissector could overwrite it */

  return offset;
}

static const value_string h225_Content_vals[] = {
  {   0, "raw" },
  {   1, "text" },
  {   2, "unicode" },
  {   3, "bool" },
  {   4, "number8" },
  {   5, "number16" },
  {   6, "number32" },
  {   7, "id" },
  {   8, "alias" },
  {   9, "transport" },
  {  10, "compound" },
  {  11, "nested" },
  { 0, NULL }
};

static int
dissect_h225_IA5String(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_IA5String(tvb, offset, actx, hf_index,
                                          NO_BOUND, NO_BOUND, FALSE);

  return offset;
}
static int
dissect_h225_BMPString(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          NO_BOUND, NO_BOUND, FALSE);

  return offset;
}

static int
dissect_h225_INTEGER_0_255(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 255U, NULL, FALSE);

  return offset;
}
static int
dissect_h225_INTEGER_0_4294967295(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_constrained_integer(tvb, offset, actx, hf_index,
                                                            0U, 4294967295U, NULL, FALSE);

  return offset;
}

static const per_sequence_t EnumeratedParameter_sequence[] = {
  { &hf_h225_id             , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_GenericIdentifier },
  { &hf_h225_content        , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_Content },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_EnumeratedParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_EnumeratedParameter, EnumeratedParameter_sequence);

  return offset;
}


static int
dissect_h225_DialedDigits(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//#line 304 "../../asn1/h225/h225.cnf"
  tvbuff_t *value_tvb = NULL;
  guint len = 0;

  offset = dissect_per_restricted_character_string(tvb, offset, actx, hf_index,
                                                      1, 128, FALSE, "0123456789#*,", 13,
                                                      &value_tvb);

  if (h225_pi && h225_pi->is_destinationInfo == TRUE) {
    if (value_tvb) {
      len = tvb_length(value_tvb);
      /* XXX - should this be allocated as an ephemeral string? */
      if (len > sizeof h225_pi->dialedDigits - 1)
        len = sizeof h225_pi->dialedDigits - 1;
      tvb_memcpy(value_tvb, (guint8*)h225_pi->dialedDigits, 0, len);
    }
    h225_pi->dialedDigits[len] = '\0';
    h225_pi->is_destinationInfo = FALSE;
  }


  return offset;
}

guint16
tvb_get_letohs(tvbuff_t *tvb, const gint offset)
{
	const guint8 *ptr;

	ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint16));
	return pletohs(ptr);
}
static int
g_unichar_to_utf8 (gunichar c, gchar * outbuf)
{
  guint len = 0;
  int first;
  int i;

  if (c < 0x80)
    {
      first = 0;
      len = 1;
    }
  else if (c < 0x800)
    {
      first = 0xc0;
      len = 2;
    }
  else if (c < 0x10000)
    {
      first = 0xe0;
      len = 3;
    }
  else if (c < 0x200000)
    {
      first = 0xf0;
      len = 4;
    }
  else if (c < 0x4000000)
    {
      first = 0xf8;
      len = 5;
    }
  else
    {
      first = 0xfc;
      len = 6;
    }

  if (outbuf)
    {
      for (i = len - 1; i > 0; --i)
	{
	  outbuf[i] = (c & 0x3f) | 0x80;
	  c >>= 6;
	}
      outbuf[0] = c | first;
    }

  return len;
}
emem_strbuf_t *
ep_strbuf_sized_new(gsize alloc_len, gsize max_alloc_len)
{
	emem_strbuf_t *strbuf;

	strbuf =(emem_strbuf_t*) malloc(sizeof(emem_strbuf_t));

	if ((max_alloc_len == 0) || (max_alloc_len > MAX_STRBUF_LEN))
		max_alloc_len = MAX_STRBUF_LEN;
	if (alloc_len == 0)
		alloc_len = 1;
	else if (alloc_len > max_alloc_len)
		alloc_len = max_alloc_len;

	strbuf->str =(gchar*) malloc(alloc_len);
	strbuf->str[0] = '\0';

	strbuf->len = 0;
	strbuf->alloc_len = alloc_len;
	strbuf->max_alloc_len = max_alloc_len;

	return strbuf;
}
static gsize
next_size(gsize cur_alloc_len, gsize wanted_alloc_len, gsize max_alloc_len)
{
	if (max_alloc_len < 1 || max_alloc_len > MAX_STRBUF_LEN) {
		max_alloc_len = MAX_STRBUF_LEN;
	}

	if (cur_alloc_len < 1) {
		cur_alloc_len = DEFAULT_STRBUF_LEN;
	}

	while (cur_alloc_len < wanted_alloc_len) {
		cur_alloc_len *= 2;
	}

	return cur_alloc_len < max_alloc_len ? cur_alloc_len : max_alloc_len;
}
gsize
g_strlcpy (gchar       *dest,
           const gchar *src,
           gsize        dest_size)
{
  register gchar *d = dest;
  register const gchar *s = src;
  register gsize n = dest_size;
  
 // g_return_val_if_fail (dest != NULL, 0);
  //g_return_val_if_fail (src  != NULL, 0);
  
  /* Copy as many bytes as will fit */
  if (n != 0 && --n != 0)
    do
      {
	register gchar c = *s++;
	
	*d++ = c;
	if (c == 0)
	  break;
      }
    while (--n != 0);
  
  /* If not enough room in dest, add NUL and traverse rest of src */
  if (n == 0)
    {
      if (dest_size != 0)
	*d = 0;
      while (*s++)
	;
    }
  
  return s - src - 1;  /* count does not include NUL */
}
emem_strbuf_t *
ep_strbuf_new(const gchar *init)
{
	emem_strbuf_t *strbuf;

	strbuf = ep_strbuf_sized_new(next_size(0, init?strlen(init)+1:0, 0), 0);  /* +1 for NULL terminator */
	if (init) {
		gsize full_len;
		full_len = g_strlcpy(strbuf->str, init, strbuf->alloc_len);
		strbuf->len = MIN(full_len, strbuf->alloc_len-1);
	}

	return strbuf;
}
void
tvb_ensure_bytes_exist(const tvbuff_t *tvb, const gint offset, const gint length)
{
	guint abs_offset, abs_length;

	//DISSECTOR_ASSERT(tvb && tvb->initialized);

	/*
	 * -1 doesn't mean "until end of buffer", as that's pointless
	 * for this routine.  We must treat it as a Really Large Positive
	 * Number, so that we throw an exception; we throw
	 * ReportedBoundsError, as if it were past even the end of a
	 * reassembled packet, and past the end of even the data we
	 * didn't capture.
	 *
	 * We do the same with other negative lengths.
	 */
	if (length < 0) {
		//THROW(ReportedBoundsError);
	}
	check_offset_length(tvb->length, tvb->reported_length, offset, length, &abs_offset, &abs_length);
}
gchar *
tvb_get_ephemeral_unicode_string(tvbuff_t *tvb, const gint offset, gint length, const guint encoding)
{
	/* Longest UTF-8 character takes 6 bytes + 1 byte for NUL, round it to 8B */
	gchar          tmpbuf[8];
	gunichar2      uchar;
	gint           i;       /* Byte counter for tvbuff */
	gint           tmpbuf_len;
	emem_strbuf_t *strbuf = NULL;

	tvb_ensure_bytes_exist(tvb, offset, length);

	strbuf = ep_strbuf_new(NULL);

	for(i = 0; i < length; i += 2) {

		if (encoding == ENC_BIG_ENDIAN)
			uchar = tvb_get_ntohs(tvb, offset + i);
		else
			uchar = tvb_get_letohs(tvb, offset + i);

		tmpbuf_len = g_unichar_to_utf8(uchar, tmpbuf);

		/* NULL terminate the tmpbuf so ep_strbuf_append knows where
		 * to stop */
		tmpbuf[tmpbuf_len] = '\0';
		printf("%s",tmpbuf);
		//ep_strbuf_append(strbuf, tmpbuf);
	}
	printf("\n");
	return tmpbuf/*strbuf->str*/;
}

const value_string AliasAddress_vals[] = {
  {   0, "dialledDigits" },
  {   1, "h323-ID" },
  {   2, "url-ID" },
  {   3, "transportID" },
  {   4, "email-ID" },
  {   5, "partyNumber" },
  {   6, "mobileUIM" },
  {   7, "isupNumber" },
  { 0, NULL }
};
static int
dissect_h225_BMPString_SIZE_1_256(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("h323-ID(1)\n");
  printf("h323-ID:");
  offset = dissect_per_BMPString(tvb, offset, actx, hf_index,
                                          1, 256, FALSE);

  return offset;
}



static int
dissect_h225_IA5String_SIZE_1_512(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_IA5String(tvb, offset, actx, hf_index,
                                          1, 512, FALSE);

  return offset;
}
const value_string h225_PublicTypeOfNumber_vals[] = {
  {   0, "unknown" },
  {   1, "internationalNumber" },
  {   2, "nationalNumber" },
  {   3, "networkSpecificNumber" },
  {   4, "subscriberNumber" },
  {   5, "abbreviatedNumber" },
  { 0, NULL }
};

static const per_choice_t PublicTypeOfNumber_choice[] = {
  {   0, &hf_h225_unknown        , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_internationalNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_nationalNumber , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   3, &hf_h225_networkSpecificNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   4, &hf_h225_subscriberNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   5, &hf_h225_abbreviatedNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

int
dissect_h225_PublicTypeOfNumber(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_PublicTypeOfNumber, PublicTypeOfNumber_choice,
                                 NULL);

  return offset;
}



static int
dissect_h225_NumberDigits(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_restricted_character_string(tvb, offset, actx, hf_index,
                                                      1, 128, FALSE, "0123456789#*,", 13,
                                                      NULL);

  return offset;
}


static const per_sequence_t PublicPartyNumber_sequence[] = {
  { &hf_h225_publicTypeOfNumber, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_PublicTypeOfNumber },
  { &hf_h225_publicNumberDigits, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_NumberDigits },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_PublicPartyNumber(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_PublicPartyNumber, PublicPartyNumber_sequence);

  return offset;
}


const value_string h225_PrivateTypeOfNumber_vals[] = {
  {   0, "unknown" },
  {   1, "level2RegionalNumber" },
  {   2, "level1RegionalNumber" },
  {   3, "pISNSpecificNumber" },
  {   4, "localNumber" },
  {   5, "abbreviatedNumber" },
  { 0, NULL }
};

static const per_choice_t PrivateTypeOfNumber_choice[] = {
  {   0, &hf_h225_unknown        , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_level2RegionalNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_level1RegionalNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   3, &hf_h225_pISNSpecificNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   4, &hf_h225_localNumber    , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   5, &hf_h225_abbreviatedNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

int
dissect_h225_PrivateTypeOfNumber(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_PrivateTypeOfNumber, PrivateTypeOfNumber_choice,
                                 NULL);

  return offset;
}


static const per_sequence_t PrivatePartyNumber_sequence[] = {
  { &hf_h225_privateTypeOfNumber, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_PrivateTypeOfNumber },
  { &hf_h225_privateNumberDigits, ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_NumberDigits },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_PrivatePartyNumber(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_PrivatePartyNumber, PrivatePartyNumber_sequence);

  return offset;
}


const value_string h225_PartyNumber_vals[] = {
  {   0, "e164Number" },
  {   1, "dataPartyNumber" },
  {   2, "telexPartyNumber" },
  {   3, "privateNumber" },
  {   4, "nationalStandardPartyNumber" },
  { 0, NULL }
};

static const per_choice_t PartyNumber_choice[] = {
  {   0, &hf_h225_e164Number     , ASN1_EXTENSION_ROOT    , dissect_h225_PublicPartyNumber },
  {   1, &hf_h225_dataPartyNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NumberDigits },
  {   2, &hf_h225_telexPartyNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NumberDigits },
  {   3, &hf_h225_privateNumber  , ASN1_EXTENSION_ROOT    , dissect_h225_PrivatePartyNumber },
  {   4, &hf_h225_nationalStandardPartyNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NumberDigits },
  { 0, NULL, 0, NULL }
};

int
dissect_h225_PartyNumber(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_PartyNumber, PartyNumber_choice,
                                 NULL);

  return offset;
}

gboolean get_size_constraint_from_stack(asn1_ctx_t *actx, const gchar *name, int *pmin_len, int *pmax_len, gboolean *phas_extension)
{
  asn1_par_t *par;

  if (pmin_len) *pmin_len = NO_BOUND;
  if (pmax_len) *pmax_len = NO_BOUND;
  if (phas_extension) *phas_extension = FALSE;

  if (!actx->stack) return FALSE;
  if (strcmp(actx->stack->name, name)) return FALSE;

  par = actx->stack->par;
  if (!par || (par->ptype != ASN1_PAR_INTEGER)) return FALSE;
  if (pmin_len) *pmin_len = par->value.v_integer;
  par = par->next;
  if (!par || (par->ptype != ASN1_PAR_INTEGER)) return FALSE;
  if (pmax_len) *pmax_len = par->value.v_integer;
  par = par->next;
  if (!par || (par->ptype != ASN1_PAR_BOOLEAN)) return FALSE;
  if (phas_extension) *phas_extension = par->value.v_boolean;

  return TRUE;
}

static int
dissect_h225_TBCD_STRING(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
//#line 708 "../../asn1/h225/h225.cnf"
  int min_len, max_len;
  gboolean has_extension;
  
  get_size_constraint_from_stack(actx, "TBCD_STRING", &min_len, &max_len, &has_extension);

  offset = dissect_per_restricted_character_string(tvb, offset, actx, hf_index,
                                                      min_len, max_len, has_extension, "0123456789#*abc", 15,
                                                      NULL);

  return offset;
}
void asn1_stack_frame_push(asn1_ctx_t *actx, const gchar *name) {
  asn1_stack_frame_t *frame;

  frame =(asn1_stack_frame_t*) malloc(sizeof(asn1_stack_frame_t));
  frame->name = name;
  frame->next = actx->stack;
  actx->stack = frame;
}
//static asn1_par_t *push_new_par(asn1_ctx_t *actx) {
//  asn1_par_t *par, **pp;
//
////  DISSECTOR_ASSERT(actx->stack);
//
//  par =(asn1_par_t*) malloc(sizeof(asn1_par_t));
//
//  pp = &(actx->stack->par);
//  while (*pp)
//    pp = &((*pp)->next);
//  *pp = par;
//
//  return par;
//}
static asn1_par_t *push_new_par(asn1_ctx_t *actx) {
  asn1_par_t *par, **pp;

//  DISSECTOR_ASSERT(actx->stack);

  par =(asn1_par_t*) malloc(sizeof(asn1_par_t));

  pp = &(actx->stack->par);
  while (*pp)
    pp = &((*pp)->next);
  *pp = par;

  return par;
}
void asn1_param_push_integer(asn1_ctx_t *actx, gint32 value) {
  asn1_par_t *par;

  par = push_new_par(actx);
  par->ptype = ASN1_PAR_INTEGER;
  par->value.v_integer = value;
}

void asn1_stack_frame_pop(asn1_ctx_t *actx, const gchar *name) {
  //DISSECTOR_ASSERT(actx->stack);
  //DISSECTOR_ASSERT(!strcmp(actx->stack->name, name));
  actx->stack = actx->stack->next;
}
void asn1_param_push_boolean(asn1_ctx_t *actx, gboolean value) {
  asn1_par_t *par;

  par = push_new_par(actx);
  par->ptype = ASN1_PAR_BOOLEAN;
  par->value.v_boolean = value;
}
guint32 dissect_per_size_constrained_type(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx,int hf_index, per_type_fn type_cb, const gchar *name, int min_len, int max_len, gboolean has_extension)
{
  asn1_stack_frame_push(actx, name);
  asn1_param_push_integer(actx, min_len);
  asn1_param_push_integer(actx, max_len);
  asn1_param_push_boolean(actx, has_extension);

  offset = type_cb(tvb, offset, actx, hf_index);

  asn1_stack_frame_pop(actx, name);

  return offset;
}
static int
dissect_h225_TBCD_STRING_SIZE_3_16(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_size_constrained_type(tvb, offset, actx, hf_index, dissect_h225_TBCD_STRING,
                                                "TBCD_STRING", 3, 16, FALSE);

  return offset;
}



static int
dissect_h225_TBCD_STRING_SIZE_16(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_size_constrained_type(tvb, offset, actx, hf_index, dissect_h225_TBCD_STRING,
                                                "TBCD_STRING", 16, 16, FALSE);

  return offset;
}



static int
dissect_h225_TBCD_STRING_SIZE_1_4(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_size_constrained_type(tvb, offset, actx, hf_index, dissect_h225_TBCD_STRING,
                                                "TBCD_STRING", 1, 4, FALSE);

  return offset;
}


static const value_string h225_T_system_id_vals[] = {
  {   0, "sid" },
  {   1, "mid" },
  { 0, NULL }
};

static const per_choice_t T_system_id_choice[] = {
  {   0, &hf_h225_sid            , ASN1_EXTENSION_ROOT    , dissect_h225_TBCD_STRING_SIZE_1_4 },
  {   1, &hf_h225_mid            , ASN1_EXTENSION_ROOT    , dissect_h225_TBCD_STRING_SIZE_1_4 },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_T_system_id(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_T_system_id, T_system_id_choice,
                                 NULL);

  return offset;
}



static int
dissect_h225_OCTET_STRING_SIZE_1(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 1, FALSE, NULL);

  return offset;
}


static const per_sequence_t ANSI_41_UIM_sequence[] = {
  { &hf_h225_imsi           , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_3_16 },
  { &hf_h225_min            , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_3_16 },
  { &hf_h225_mdn            , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_3_16 },
  { &hf_h225_msisdn         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_3_16 },
  { &hf_h225_esn            , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_16 },
  { &hf_h225_mscid          , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_3_16 },
  { &hf_h225_system_id      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_system_id },
  { &hf_h225_systemMyTypeCode, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_OCTET_STRING_SIZE_1 },
  { &hf_h225_systemAccessType, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_OCTET_STRING_SIZE_1 },
  { &hf_h225_qualificationInformationCode, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_OCTET_STRING_SIZE_1 },
  { &hf_h225_sesn           , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_16 },
  { &hf_h225_soc            , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_3_16 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_ANSI_41_UIM(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_ANSI_41_UIM, ANSI_41_UIM_sequence);

  return offset;
}



static int
dissect_h225_OCTET_STRING_SIZE_1_4(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       1, 4, FALSE, NULL);

  return offset;
}



static int
dissect_h225_TBCD_STRING_SIZE_15_16(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_size_constrained_type(tvb, offset, actx, hf_index, dissect_h225_TBCD_STRING,
                                                "TBCD_STRING", 15, 16, FALSE);

  return offset;
}


static const per_sequence_t GSM_UIM_sequence[] = {
  { &hf_h225_imsi           , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_3_16 },
  { &hf_h225_tmsi           , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_OCTET_STRING_SIZE_1_4 },
  { &hf_h225_msisdn         , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_3_16 },
  { &hf_h225_imei           , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_15_16 },
  { &hf_h225_hplmn          , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_1_4 },
  { &hf_h225_vplmn          , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_TBCD_STRING_SIZE_1_4 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_GSM_UIM(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_GSM_UIM, GSM_UIM_sequence);

  return offset;
}


static const value_string h225_MobileUIM_vals[] = {
  {   0, "ansi-41-uim" },
  {   1, "gsm-uim" },
  { 0, NULL }
};

static const per_choice_t MobileUIM_choice[] = {
  {   0, &hf_h225_ansi_41_uim    , ASN1_EXTENSION_ROOT    , dissect_h225_ANSI_41_UIM },
  {   1, &hf_h225_gsm_uim        , ASN1_EXTENSION_ROOT    , dissect_h225_GSM_UIM },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_MobileUIM(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_MobileUIM, MobileUIM_choice,
                                 NULL);

  return offset;
}


static const value_string h225_NatureOfAddress_vals[] = {
  {   0, "unknown" },
  {   1, "subscriberNumber" },
  {   2, "nationalNumber" },
  {   3, "internationalNumber" },
  {   4, "networkSpecificNumber" },
  {   5, "routingNumberNationalFormat" },
  {   6, "routingNumberNetworkSpecificFormat" },
  {   7, "routingNumberWithCalledDirectoryNumber" },
  { 0, NULL }
};

static const per_choice_t NatureOfAddress_choice[] = {
  {   0, &hf_h225_unknown        , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   1, &hf_h225_subscriberNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   2, &hf_h225_nationalNumber , ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   3, &hf_h225_internationalNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   4, &hf_h225_networkSpecificNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   5, &hf_h225_routingNumberNationalFormat, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   6, &hf_h225_routingNumberNetworkSpecificFormat, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  {   7, &hf_h225_routingNumberWithCalledDirectoryNumber, ASN1_EXTENSION_ROOT    , dissect_h225_NULL },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_NatureOfAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_NatureOfAddress, NatureOfAddress_choice,
                                 NULL);

  return offset;
}

static int
dissect_h225_IsupDigits(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_restricted_character_string(tvb, offset, actx, hf_index,
                                                      1, 128, FALSE, "0123456789ABCDE", 15,
                                                      NULL);

  return offset;
}


static const per_sequence_t IsupPublicPartyNumber_sequence[] = {
  { &hf_h225_natureOfAddress, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_NatureOfAddress },
  { &hf_h225_address        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_IsupDigits },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_IsupPublicPartyNumber(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_IsupPublicPartyNumber, IsupPublicPartyNumber_sequence);

  return offset;
}


static const per_sequence_t IsupPrivatePartyNumber_sequence[] = {
  { &hf_h225_privateTypeOfNumber, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_PrivateTypeOfNumber },
  { &hf_h225_address        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_IsupDigits },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_IsupPrivatePartyNumber(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_IsupPrivatePartyNumber, IsupPrivatePartyNumber_sequence);

  return offset;
}


static const value_string h225_IsupNumber_vals[] = {
  {   0, "e164Number" },
  {   1, "dataPartyNumber" },
  {   2, "telexPartyNumber" },
  {   3, "privateNumber" },
  {   4, "nationalStandardPartyNumber" },
  { 0, NULL }
};

static const per_choice_t IsupNumber_choice[] = {
  {   0, &hf_h225_isupE164Number , ASN1_EXTENSION_ROOT    , dissect_h225_IsupPublicPartyNumber },
  {   1, &hf_h225_isupDataPartyNumber, ASN1_EXTENSION_ROOT    , dissect_h225_IsupDigits },
  {   2, &hf_h225_isupTelexPartyNumber, ASN1_EXTENSION_ROOT    , dissect_h225_IsupDigits },
  {   3, &hf_h225_isupPrivateNumber, ASN1_EXTENSION_ROOT    , dissect_h225_IsupPrivatePartyNumber },
  {   4, &hf_h225_isupNationalStandardPartyNumber, ASN1_EXTENSION_ROOT    , dissect_h225_IsupDigits },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_IsupNumber(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_IsupNumber, IsupNumber_choice,
                                 NULL);

  return offset;
}

static int
dissect_h225_IpV4(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("ip: ");
	guint8* ip=(guint8*)malloc (sizeof(guint8)*4);
  offset = dissect_per_octet_string(tvb, offset, actx, hf_index,
                                       4, 4, FALSE, NULL);
  //printf("%d\n",h_225_message_value.data_output);
  for(int i=0;i<4;i++){
	  printf("%d.",tvb_get_guint8((tvbuff_t*)h_225_message_value.octet_ip,i));
	  ip[i]=tvb_get_guint8((tvbuff_t*)h_225_message_value.octet_ip,i);
  }
  ip_val->src_ip = ip;
  return offset;
}

static const per_sequence_t T_ipAddress_sequence[] = {
  { &hf_h225_ipV4           , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_IpV4 },
  { &hf_h225_ipV4_port      , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};
const value_string h225_TransportAddress_vals[] = {
  {   0, "ipAddress" },
  {   1, "ipSourceRoute" },
  {   2, "ipxAddress" },
  {   3, "ip6Address" },
  {   4, "netBios" },
  {   5, "nsap" },
  {   6, "nonStandardAddress" },
  { 0, NULL }
};
static int
dissect_h225_T_ipAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("ipAddress(0)\n");
	printf("ipAddress\n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_ipAddress, T_ipAddress_sequence);

  return offset;
}



static int
dissect_h225_T_route(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence_of(tvb, offset, actx, hf_index,
                                      ett_h225_T_route, T_route_sequence_of);

  return offset;
}


static int
dissect_h225_T_routing(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
   offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_T_routing, T_routing_choice,
                                 NULL);

  return offset;
}
static const per_sequence_t T_ipSourceRoute_sequence[] = {
  { &hf_h225_src_route_ipV4 , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_4 },
  { &hf_h225_ipV4_src_port  , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_65535 },
  { &hf_h225_route          , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_route },
  { &hf_h225_routing        , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_routing },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_ipSourceRoute(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_ipSourceRoute, T_ipSourceRoute_sequence);

  return offset;
}


static const per_sequence_t T_ipxAddress_sequence[] = {
  { &hf_h225_node           , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_6 },
  { &hf_h225_netnum         , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_4 },
  { &hf_h225_ipx_port       , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_2 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_ipxAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_ipxAddress, T_ipxAddress_sequence);

  return offset;
}

static const per_sequence_t T_ip6Address_sequence[] = {
  { &hf_h225_ipV6           , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_16 },
  { &hf_h225_ipV6_port      , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_65535 },
  { NULL, 0, 0, NULL }
};


static int
dissect_h225_T_ip6Address(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_ip6Address, T_ip6Address_sequence);

  return offset;
}



int
dissect_h225_TransportAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("DestCallSignalAddress: ");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_TransportAddress, TransportAddress_choice,
                                 NULL);


  return offset;
}
static const per_choice_t AliasAddress_choice[] = {
  {   0, &hf_h225_dialledDigits  , ASN1_EXTENSION_ROOT    , dissect_h225_DialedDigits },
  {   1, &hf_h225_h323_ID        , ASN1_EXTENSION_ROOT    , dissect_h225_BMPString_SIZE_1_256 },
  {   2, &hf_h225_url_ID         , ASN1_NOT_EXTENSION_ROOT, dissect_h225_IA5String_SIZE_1_512 },
  {   3, &hf_h225_transportID    , ASN1_NOT_EXTENSION_ROOT, dissect_h225_TransportAddress },
  {   4, &hf_h225_email_ID       , ASN1_NOT_EXTENSION_ROOT, dissect_h225_IA5String_SIZE_1_512 },
  {   5, &hf_h225_partyNumber    , ASN1_NOT_EXTENSION_ROOT, dissect_h225_PartyNumber },
  {   6, &hf_h225_mobileUIM      , ASN1_NOT_EXTENSION_ROOT, dissect_h225_MobileUIM },
  {   7, &hf_h225_isupNumber     , ASN1_NOT_EXTENSION_ROOT, dissect_h225_IsupNumber },
  { 0, NULL, 0, NULL }
};

int
dissect_h225_AliasAddress(tvbuff_t *tvb, int offset, asn1_ctx_t *actx,int hf_index) {
	printf("AliasAddress :");
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_AliasAddress, AliasAddress_choice,
                                 NULL);
  
//printf("%s (%d)\n",	val_to_str(	h_225_message_value.msg_value, AliasAddress_vals, "<unknown>"),	h_225_message_value.msg_value);
  return offset;
}
static const per_sequence_t SEQUENCE_SIZE_1_512_OF_EnumeratedParameter_sequence_of[1] = {
  { &hf_h225_compound_item  , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_EnumeratedParameter },
};

static int
dissect_h225_SEQUENCE_SIZE_1_512_OF_EnumeratedParameter(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h225_SEQUENCE_SIZE_1_512_OF_EnumeratedParameter, SEQUENCE_SIZE_1_512_OF_EnumeratedParameter_sequence_of,
                                                  1, 512, FALSE);

  return offset;
}


static const per_sequence_t SEQUENCE_SIZE_1_16_OF_GenericData_sequence_of[1] = {
  { &hf_h225_nested_item    , ASN1_NO_EXTENSIONS     , ASN1_NOT_OPTIONAL, dissect_h225_GenericData },
};

static int
dissect_h225_SEQUENCE_SIZE_1_16_OF_GenericData(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_constrained_sequence_of(tvb, offset, actx, hf_index,
                                                  ett_h225_SEQUENCE_SIZE_1_16_OF_GenericData, SEQUENCE_SIZE_1_16_OF_GenericData_sequence_of,
                                                  1, 16, FALSE);

  return offset;
}

static const per_choice_t Content_choice[] = {
  {   0, &hf_h225_raw            , ASN1_EXTENSION_ROOT    , dissect_h225_OCTET_STRING },
  {   1, &hf_h225_text           , ASN1_EXTENSION_ROOT    , dissect_h225_IA5String },
  {   2, &hf_h225_unicode        , ASN1_EXTENSION_ROOT    , dissect_h225_BMPString },
  {   3, &hf_h225_bool           , ASN1_EXTENSION_ROOT    , dissect_h225_BOOLEAN },
  {   4, &hf_h225_number8        , ASN1_EXTENSION_ROOT    , dissect_h225_INTEGER_0_255 },
  {   5, &hf_h225_number16       , ASN1_EXTENSION_ROOT    , dissect_h225_INTEGER_0_65535 },
  {   6, &hf_h225_number32       , ASN1_EXTENSION_ROOT    , dissect_h225_INTEGER_0_4294967295 },
  {   7, &hf_h225_id             , ASN1_EXTENSION_ROOT    , dissect_h225_GenericIdentifier },
  {   8, &hf_h225_alias          , ASN1_EXTENSION_ROOT    , dissect_h225_AliasAddress },
  {   9, &hf_h225_transport      , ASN1_EXTENSION_ROOT    , dissect_h225_TransportAddress },
  {  10, &hf_h225_compound       , ASN1_EXTENSION_ROOT    , dissect_h225_SEQUENCE_SIZE_1_512_OF_EnumeratedParameter },
  {  11, &hf_h225_nested         , ASN1_EXTENSION_ROOT    , dissect_h225_SEQUENCE_SIZE_1_16_OF_GenericData },
  { 0, NULL, 0, NULL }
};

static int
dissect_h225_Content(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_choice(tvb, offset, actx, hf_index,
                                 ett_h225_Content, Content_choice,
                                 NULL);

  return offset;
}

static const per_sequence_t H323_UU_PDU_sequence[] = {
  { &hf_h225_h323_message_body, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_T_h323_message_body },
  { &hf_h225_nonStandardData, ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_NonStandardParameter },
  { &hf_h225_h4501SupplementaryService, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_T_h4501SupplementaryService },
  { &hf_h225_h245Tunnelling , ASN1_NOT_EXTENSION_ROOT, ASN1_NOT_OPTIONAL, dissect_h225_T_h245Tunnelling },
  { &hf_h225_h245Control    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_H245Control },
  { &hf_h225_nonStandardControl, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_NonStandardParameter },
  { &hf_h225_callLinkage    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_CallLinkage },
  { &hf_h225_tunnelledSignallingMessage, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_T_tunnelledSignallingMessage },
  { &hf_h225_provisionalRespToH245Tunnelling, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_NULL },
  { &hf_h225_stimulusControl, ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_StimulusControl },
  { &hf_h225_genericData    , ASN1_NOT_EXTENSION_ROOT, ASN1_OPTIONAL    , dissect_h225_SEQUENCE_OF_GenericData },
  { NULL, 0, 0, NULL }
};
static int
dissect_h225_H323_UU_PDU(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  printf("H323-uu-pdu \n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_H323_UU_PDU, H323_UU_PDU_sequence);

  return offset;
}

static int
dissect_h225_OCTET_STRING_SIZE_1_131(tvbuff_t *tvb , int offset , asn1_ctx_t *actx , int hf_index ) {
  offset = dissect_per_octet_string(tvb, offset, actx,  hf_index,
                                       1, 131, FALSE, NULL);

  return offset;
}
static const per_sequence_t T_user_data_sequence[] = {
  { &hf_h225_protocol_discriminator, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_INTEGER_0_255 },
  { &hf_h225_user_information, ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_OCTET_STRING_SIZE_1_131 },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_T_user_data(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	 printf("T_user_data \n");
  offset = dissect_per_sequence(tvb, offset, actx, hf_index,
                                   ett_h225_T_user_data, T_user_data_sequence);

  return offset;
}
void next_tvb_call(next_tvb_list_t *list, packet_info *pinfo, dissector_handle_t handle, dissector_handle_t data_handle) {
  next_tvb_item_t *item;

  item = list->first;
  while (item) {
    if (item->tvb && tvb_length(item->tvb)) {
      switch (item->type) {
        case NTVB_HANDLE:
          call_dissector((item->handle) ? item->handle : ((handle) ? handle : data_handle), item->tvb, pinfo);
          break;
        case NTVB_UINT:
         // dissector_try_uint(item->table, item->uint_val, item->tvb, pinfo, (item->tree) ? item->tree : tree);
          break;
        case NTVB_STRING:
          dissector_try_string(item->table, item->string, item->tvb, pinfo);
          break;
      }
    }
    item = item->next;
  }
}
static const per_sequence_t H323_UserInformation_sequence[] = {
  { &hf_h225_h323_uu_pdu    , ASN1_EXTENSION_ROOT    , ASN1_NOT_OPTIONAL, dissect_h225_H323_UU_PDU },
  { &hf_h225_user_data      , ASN1_EXTENSION_ROOT    , ASN1_OPTIONAL    , dissect_h225_T_user_data },
  { NULL, 0, 0, NULL }
};

static int
dissect_h225_H323_UserInformation(tvbuff_t *tvb , int offset , asn1_ctx_t *actx ,  int hf_index ) {
	printf("H323-UserInformation\n");
  offset = dissect_per_sequence(tvb, offset, actx,  hf_index,
                                   ett_h225_H323_UserInformation, H323_UserInformation_sequence);

  return offset;
}
/*--- PDUs ---*/

static int dissect_H323_UserInformation_PDU(tvbuff_t *tvb , packet_info *pinfo,H323_attr* h323_val ) {
  int offset = 0;
  asn1_ctx_t asn1_ctx;
  asn1_ctx_init(&asn1_ctx, ASN1_ENC_PER, TRUE, pinfo);
  offset = dissect_h225_H323_UserInformation(tvb, offset, &asn1_ctx,  hf_h225_H323_UserInformation_PDU);
  offset += 7; offset >>= 3;
  return offset;
}
int
dissect_h225_H323UserInformation(tvbuff_t *tvb,packet_info *pinfo,H323_attr* h323_val)
{
	
	int offset = 0;
	//printf("started byte: %x\n",tvb_get_guint8(tvb,offset));
	pi_current++;
	if(pi_current==5){
		pi_current=0;
	}
	h225_pi=&pi_arr[pi_current];

	/* Init struct for collecting h225_packet_info */
	reset_h225_packet_info(h225_pi);
	h225_pi->msg_type = H225_CS;

	next_tvb_init(&h245_list);
	next_tvb_init(&tp_list);
	printf("%s",PSNAME_225);
	printf(" CS\n");
	//tr=proto_item_add_subtree(it, ett_h225);

	offset = dissect_H323_UserInformation_PDU(tvb, pinfo, h323_val);

	next_tvb_call(&h245_list, pinfo,  h245dg_handle, data_handle);
	next_tvb_call(&tp_list, pinfo,  NULL, data_handle);

	//tap_queue_packet(h225_tap, pinfo, h225_pi);

	return offset;
}


                           //Q.931 AND H225
static void
dissect_q931_protocol_discriminator(tvbuff_t *tvb, int offset)
{
	unsigned int discriminator = tvb_get_guint8(tvb, offset);

	if (discriminator == NLPID_DMS) {
		//proto_tree_add_uint_format(tree, hf_q931_discriminator,
			 tvb, offset, 1, discriminator,
			 printf("Protocol discriminator: Maintenance messages\n");
	} else if (discriminator == NLPID_Q_931) {
		//proto_tree_add_uint_format(tree, hf_q931_discriminator,
			// tvb, offset, 1, discriminator,
			printf( "Protocol discriminator: Q.931\n");
	} else if (discriminator == NLPID_Q_2931) {
		//proto_tree_add_uint_format(tree, hf_q931_discriminator,
			// tvb, offset, 1, discriminator,
			 printf("Protocol discriminator: Q.2931\n");
	} else if ((discriminator >= 16 && discriminator < 63)
	    || ((discriminator >= 80) && (discriminator < 254))) {
		//proto_tree_add_uint_format(tree, hf_q931_discriminator,
		  //  tvb, offset, 1, discriminator,
		  printf(  "Protocol discriminator: Network layer or layer 3 protocol (0x%02X)\n",
		    discriminator);
	} else if (discriminator >= 64 && discriminator <= 79) {
		//proto_tree_add_uint_format(tree, hf_q931_discriminator,
		  //  tvb, offset, 1, discriminator,
		   printf( "Protocol discriminator: National use (0x%02X)\n",
		    discriminator);
	} else {
		//proto_tree_add_uint_format(tree, hf_q931_discriminator,
		   // tvb, offset, 1, discriminator,
		    printf("Protocol discriminator: Reserved (0x%02X)\n",
		    discriminator);
	}
}
static const true_false_string tfs_call_ref_flag = {
	"Message sent to originating side",
	"Message sent from originating side"
};

static const true_false_string tfs_interface_type = {
	"Primary rate interface",
	"Basic rate interface"
};

static const true_false_string tfs_channel_exclusive = {
	"Exclusive; only the indicated channel is acceptable",
	"Indicated channel is preferred"
};

static const true_false_string tfs_channel_map = {
	"Channel indicated by slot map",
	"Channel indicated by number"
};
static const value_string dms_message_type_vals[] = {
	{ DMS_SERVICE_ACKNOWLEDGE,	"SERVICE ACKNOWLEDGE" },
	{ DMS_SERVICE,				"SERVICE" },
	{ 0,				NULL }
};
static const gchar*
match_strval_ext(const guint32 val, const value_string_ext *vse) {
    if (vse) {
      const value_string *vs = vse->_vs_match2(val, vse);
      if (vs)
        return vs->strptr;
    }
    return NULL;
}
static const value_string *
_match_strval_linear(const guint32 val, const value_string_ext *vse)
{
  const value_string *vs_p = vse->_vs_p;
  guint i;
  for (i=0; i<vse->_vs_num_entries; i++) {
    if (vs_p[i].value == val)
      return &(vs_p[i]);
  }
  return NULL;
}
static const value_string *
_match_strval_bsearch(const guint32 val, const value_string_ext *vse)
{
  guint low, i, max;
  guint32 item;

  for (low = 0, max = vse->_vs_num_entries; low < max; ) {
    i = (low + max) / 2;
    item = vse->_vs_p[i].value;

    if (val < item)
      max = i;
    else if (val > item)
      low = i + 1;
    else
      return &(vse->_vs_p[i]);
  }
  return NULL;
}
static const value_string *
_match_strval_index(const guint32 val, const value_string_ext *vse)
{
  guint i;

  i = val - vse->_vs_first_value;
  if (i < vse->_vs_num_entries) {
    g_assert (val == vse->_vs_p[i].value);
    return &(vse->_vs_p[i]);
  }
  return NULL;
}
static const value_string *
_match_strval_ext_init(const guint32 val, const value_string_ext *a_vse)
{
  /*  Cast away the constness!
   *  It's better if the prototype for this function matches the other
   *  _match_strval_* functions (so we don't have to cast it when storing it
   *  in _match_strval so the compiler will notice if the prototypes get out
   *  of sync), but the init function is unique in that it does actually
   *  modify the vse.
   */
  value_string_ext    *vse            = (value_string_ext *)a_vse;

  const value_string *vs_p           = vse->_vs_p;
  const guint         vs_num_entries = vse->_vs_num_entries;

  enum { VS_SEARCH = 0, VS_BIN_TREE, VS_INDEX } type = VS_INDEX;

  guint32 prev_value;
  guint   first_value;
  guint   i;

  g_assert((vs_p[vs_num_entries].value==0) && (vs_p[vs_num_entries].strptr==NULL));

  vse->_vs_first_value = vs_p[0].value;
  first_value          = vs_p[0].value;
  prev_value           = first_value;

  for (i = 0; i < vs_num_entries; i++) {
    g_assert(vs_p[i].strptr != NULL);
    if ((type == VS_INDEX) && (vs_p[i].value != (i + first_value))) {
      type = VS_BIN_TREE;
    }
    /* XXX: Should check for dups ?? */
    if ((type == VS_BIN_TREE) && (prev_value > vs_p[i].value)) {
      type = VS_SEARCH;
      break;
    }

    prev_value = vs_p[i].value;
  }

  switch (type) {
  case VS_SEARCH:
    vse->_vs_match2 = _match_strval_linear;
    break;
  case VS_BIN_TREE:
    vse->_vs_match2 = _match_strval_bsearch;
    break;
  case VS_INDEX:
    vse->_vs_match2 = _match_strval_index;
    break;
  default:
    g_assert_not_reached();
    break;
  }

  return vse->_vs_match2(val, vse);
}
#define array_length(x)	(sizeof x / sizeof x[0])
#define VALUE_STRING_EXT_INIT(x) { _match_strval_ext_init, 0, array_length(x)-1, x, #x }
static const gchar*
val_to_str_ext(const guint32 val, const value_string_ext *vse, const char *unknown_str) {
  const gchar *ret;

  //g_assert(unknown_str != NULL);

  ret = match_strval_ext(val, vse);
  if (ret != NULL)
    return ret;

  return unknown_str;
}
static value_string_ext q931_message_type_vals_ext = VALUE_STRING_EXT_INIT(q931_message_type_vals);
static const gchar *get_message_name(guint8 prot_discr, guint8 message_type) {
	if (prot_discr == NLPID_DMS)
		return val_to_str(message_type, dms_message_type_vals, "Unknown (0x%02X)");
	else
		return val_to_str_ext(message_type, &q931_message_type_vals_ext, "Unknown (0x%02X)");
}
static const value_string q931_info_element_vals0[] = {
	{ Q931_IE_SEGMENTED_MESSAGE,		"Segmented message" },
	{ Q931_IE_CHANGE_STATUS,			"Change status" },
	{ Q931_IE_BEARER_CAPABILITY,		"Bearer capability" },
	{ Q931_IE_CAUSE,			"Cause" },
	{ Q931_IE_CALL_IDENTITY,		"Call identity" },
	{ Q931_IE_CALL_STATE,			"Call state" },
	{ Q931_IE_CHANNEL_IDENTIFICATION,	"Channel identification" },
	{ Q931_IE_FACILITY,			"Facility" },
	{ Q931_IE_PROGRESS_INDICATOR,		"Progress indicator" },
	{ Q931_IE_NETWORK_SPECIFIC_FACIL,	"Network specific facilities" },
	{ Q931_IE_NOTIFICATION_INDICATOR,	"Notification indicator" },
	{ Q931_IE_DISPLAY,			"Display" },
	{ Q931_IE_DATE_TIME,			"Date/Time" },
	{ Q931_IE_KEYPAD_FACILITY,		"Keypad facility" },
	{ Q931_IE_INFORMATION_REQUEST,		"Information request" },
	{ Q931_IE_SIGNAL,			"Signal" },
	{ Q931_IE_SWITCHHOOK,			"Switchhook" },
	{ Q931_IE_FEATURE_ACTIVATION,		"Feature activation" },
	{ Q931_IE_FEATURE_INDICATION,		"Feature Indication" },
	{ Q931_IE_ENDPOINT_IDENTIFIER,		"Endpoint identifier" },
	{ Q931_IE_SERVICE_PROFILE_ID,		"Service profile ID" },
	{ Q931_IE_INFORMATION_RATE,		"Information rate" },
	{ Q931_IE_E2E_TRANSIT_DELAY,		"End-to-end transit delay" },
	{ Q931_IE_TD_SELECTION_AND_INT,		"Transit delay selection and indication" },
	{ Q931_IE_PL_BINARY_PARAMETERS,		"Packet layer binary parameters" },
	{ Q931_IE_PL_WINDOW_SIZE,		"Packet layer window size" },
	{ Q931_IE_PACKET_SIZE,			"Packet size" },
	{ Q931_IE_CUG,				"Closed user group" },
	{ Q931_IE_REVERSE_CHARGE_IND,		"Reverse charging indication" },
	{ Q931_IE_CONNECTED_NUMBER_DEFAULT,     "Connected number" },
	{ Q931_IE_INTERFACE_SERVICE,		"Interface Service" },
	{ Q931_IE_CHANNEL_STATUS,		"Channel Status" },
	{ Q931_IE_VERSION_INFO,			"Version Info" },
	{ Q931_IE_CALLING_PARTY_NUMBER,		"Calling party number" },
	{ Q931_IE_CALLING_PARTY_SUBADDR,	"Calling party subaddress" },
	{ Q931_IE_CALLED_PARTY_NUMBER,		"Called party number" },
	{ Q931_IE_CALLED_PARTY_SUBADDR,		"Called party subaddress" },
	{ Q931_IE_REDIRECTING_NUMBER,		"Redirecting number" },
	{ Q931_IE_REDIRECTION_NUMBER,		"Redirection number" },
	{ Q931_IE_TRANSIT_NETWORK_SEL,		"Transit network selection" },
	{ Q931_IE_RESTART_INDICATOR,		"Restart indicator" },
	{ Q931_IE_LOW_LAYER_COMPAT,		"Low-layer compatibility" },
	{ Q931_IE_HIGH_LAYER_COMPAT,		"High-layer compatibility" },
	{ Q931_IE_USER_USER,			"User-user" },
	{ Q931_IE_ESCAPE,			"Escape" },
	{ Q931_IE_CONNECTED_NUMBER,		"Connected number" },
	{ Q931_IE_CONNECTED_SUBADDR,		"Connected subaddress" },
	{ 0,					NULL }
};
/* Codeset 1 */
static const value_string q931_info_element_vals1[] = {
	{ 0,					NULL }
};
/* Codeset 2 */
static const value_string q931_info_element_vals2[] = {
	{ 0,					NULL }
};
/* Codeset 3 */
static const value_string q931_info_element_vals3[] = {
	{ 0,					NULL }
};
/* Codeset 4 */
static const value_string q931_info_element_vals4[] = {
	{ 0,					NULL }
};
/* Codeset 5 */
static const value_string q931_info_element_vals5[] = {
	{ Q931_IE_CHARGING_ADVICE,		"Charging advice" },
	{ Q931_IE_OPERATOR_SYSTEM_ACCESS,	"Operator system access" },
	{ Q931_IE_PARTY_CATEGORY,		"Party category"},
	{ 0,					NULL }
};
/* Codeset 6 */
static const value_string q931_info_element_vals6[] = {
	{ Q931_IE_REDIRECTING_NUMBER,		"Redirecting number" },
	{ Q931_IE_REDIRECTING_SUBADDR,		"Redirecting subaddress" },
	{ Q931_IE_CALL_APPEARANCE,		"Call appearance" },
	{ Q931_IE_DISPLAY,			"Avaya Display" }, /* if Avaya codeset to send display = 6 */
	{ 0,					NULL }
};
/* Codeset 7 */
static const value_string q931_info_element_vals7[] = {
	{ 0,					NULL }
};

static const value_string *q931_info_element_vals[NUM_INFO_ELEMENT_VALS] = {
  q931_info_element_vals0,
  q931_info_element_vals1,
  q931_info_element_vals2,
  q931_info_element_vals3,
  q931_info_element_vals4,
  q931_info_element_vals5,
  q931_info_element_vals6,
  q931_info_element_vals7,
};
static void
dissect_q931_segmented_message_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len != 2) {
//proto_tree_add_text(tree, tvb, offset, len,
		  printf(  "Segmented message: length is %d, should be 2\n", len);
		return;
	}
	if (tvb_get_guint8(tvb, offset) & 0x80) {
		//proto_tree_add_text(tree, tvb, offset, 1,
		   printf(  "First segment: %u segments remaining\n",
		    tvb_get_guint8(tvb, offset) & 0x7F);
	} else {
		//proto_tree_add_text(tree, tvb, offset, 1,
		   printf(  "Not first segment: %u segments remaining\n",
		    tvb_get_guint8(tvb, offset) & 0x7F);
	}
	//proto_tree_add_item(tree, hf_q931_segment_type, tvb, offset + 1, 1, ENC_BIG_ENDIAN);
}
tvbuff_t*
tvb_new_subset_remaining(tvbuff_t *backing, const gint backing_offset)
{
	tvbuff_t *tvb;
	guint	  subset_tvb_offset;
	guint	  subset_tvb_length;

	check_offset_length(backing->length, backing->reported_length, backing_offset, -1 /* backing_length */,
			    &subset_tvb_offset,
			    &subset_tvb_length);

	tvb = tvb_new_with_subset(subset_tvb_offset, subset_tvb_length);

	tvb_set_subset_no_exceptions(tvb, backing, -1 /* reported_length */);

	/*
	 * The top-level data source of this tvbuff is the top-level
	 * data source of its parent.
	 */
	tvb->ds_tvb = backing->ds_tvb;

	return tvb;
}

static const value_string q931_codeset_vals[] = {
	{ 0x00, "Q.931 information elements" },
	{ 0x04, "Information elements for ISO/IEC use" },
	{ 0x05, "Information elements for national use" },
	{ 0x06, "Information elements specific to the local network" },
	{ 0x07, "User-specific information elements" },
	{ 0x00, NULL },
};
static dissector_table_t ie_dissector_table;
static dissector_table_t codeset_dissector_table;
static gboolean
dissector_try_uint_new(dissector_table_t sub_dissectors, const guint32 uint_val,
		       tvbuff_t *tvb, packet_info *pinfo, /**/const gboolean add_proto_name)
{
	dtbl_entry_t            *dtbl_entry;
	struct dissector_handle *handle;
	guint32                  saved_match_uint;
	int ret;

	//dtbl_entry = find_uint_dtbl_entry(sub_dissectors, uint_val);
	//if (dtbl_entry != NULL) {
	//	/*
	//	 * Is there currently a dissector handle for this entry?
	//	 */
	//	handle = dtbl_entry->current;
	//	if (handle == NULL) {
	//		/*
	//		 * No - pretend this dissector didn't exist,
	//		 * so that other dissectors might have a chance
	//		 * to dissect this packet.
	//		 */
	//		return FALSE;
	//	}

	//	/*
	//	 * Save the current value of "pinfo->match_uint",
	//	 * set it to the uint_val that matched, call the
	//	 * dissector, and restore "pinfo->match_uint".
	//	 */
	//	//saved_match_uint  = pinfo->match_uint;
	//	//pinfo->match_uint = uint_val;
	//	ret = call_dissector_work(handle, tvb, pinfo, /**/add_proto_name);
	//	//pinfo->match_uint = saved_match_uint;

	//	/*
	//	 * If a new-style dissector returned 0, it means that
	//	 * it didn't think this tvbuff represented a packet for
	//	 * its protocol, and didn't dissect anything.
	//	 *
	//	 * Old-style dissectors can't reject the packet.
	//	 *
	//	 * 0 is also returned if the protocol wasn't enabled.
	//	 *
	//	 * If the packet was rejected, we return FALSE, so that
	//	 * other dissectors might have a chance to dissect this
	//	 * packet, otherwise we return TRUE.
	//	 */
	//	return ret != 0;
	//}
	return FALSE;
}

static gboolean
dissector_try_uint(dissector_table_t sub_dissectors, const guint32 uint_val,
		   tvbuff_t *tvb, packet_info *pinfo/*, proto_tree *tree*/)
{

	return dissector_try_uint_new(sub_dissectors, uint_val, tvb, pinfo, /**/TRUE);
}
static const value_string q931_congestion_level_vals[] = {
	{ 0x0, "Receiver ready" },
	{ 0xF, "Receiver not ready" },
	{ 0,   NULL }
};
static const value_string q931_repeat_indication_vals[] = {
	{ 0x2, "Prioritized list" },
	{ 0,   NULL }
};
gboolean
tvb_bytes_exist(const tvbuff_t *tvb, const gint offset, const gint length)
{
	guint abs_offset, abs_length;

	//DISSECTOR_ASSERT(tvb && tvb->initialized);

	if (!compute_offset_length(tvb->length, tvb->reported_length, offset, length, &abs_offset, &abs_length, NULL))
		return FALSE;

	if (abs_offset + abs_length <= tvb->length) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}
static const value_string q931_protocol_discriminator_vals[] = {
	{ Q931_PROTOCOL_DISCRIMINATOR_USER, "User-specific protocol" },
	{ 0x01,					"OSI high layer protocols" },
	{ 0x02,					"X.244" },
	{ 0x03,					"Reserved for system management convergence function" },
	{ Q931_PROTOCOL_DISCRIMINATOR_IA5,	"IA5 characters" },
	{ Q931_PROTOCOL_DISCRIMINATOR_ASN1,	"X.208 and X.209 coded user information" },
	{ 0x06,					"Undefined" },
	{ 0x07,					"V.120 rate adaption" },
	{ 0x08,					"Q.931/I.451 user-network call control messages" },
	{ 0,					NULL }
};
value_string_ext q931_protocol_discriminator_vals_ext = VALUE_STRING_EXT_INIT(q931_protocol_discriminator_vals);

static char *
byte_to_hex_(char *out, guint32 dword) {
  /* At least one version of Apple's C compiler/linker is buggy, causing
     a complaint from the linker about the "literal C string section"
     not ending with '\0' if we initialize a 16-element "char" array with
     a 16-character string, the fact that initializing such an array with
     such a string is perfectly legitimate ANSI C nonwithstanding, the 17th
     '\0' byte in the string nonwithstanding. */
  static const gchar hex_digits[16] =
      { '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

  *out++ = hex_digits[(dword >> 4) & 0xF];
  *out++ = hex_digits[dword & 0xF];
  return out;
}
char *
bytes_to_hexstr_(char *out, const guint8 *ad, guint32 len) {
  guint32 i;

  if (!ad)
   // REPORT_DISSECTOR_BUG("Null pointer passed to bytes_to_hexstr_()");

  for (i = 0; i < len; i++)
    out = byte_to_hex_(out, ad[i]);
  return out;
}
gchar *
bytes_to_str(const guint8 *bd, int bd_len) {
  gchar *cur;
  gchar *cur_ptr;
  int truncated = 0;

  if (!bd)
   // REPORT_DISSECTOR_BUG
   printf("Null pointer passed to bytes_to_str_()\n");

  cur=(gchar*)malloc(MAX_BYTE_STR_LEN+3+1);
  if (bd_len <= 0) { cur[0] = '\0'; return cur; }

  if (bd_len > MAX_BYTE_STR_LEN/2) {	/* bd_len > 24 */
    truncated = 1;
    bd_len = MAX_BYTE_STR_LEN/2;
  }

  cur_ptr = bytes_to_hexstr_(cur, bd, bd_len);	/* max MAX_BYTE_STR_LEN bytes */

  if (truncated)
    //cur_ptr = g_stpcpy(cur_ptr, "...");		/* 3 bytes */

  *cur_ptr = '\0';				/* 1 byte */
  return cur;
}
gchar *
tvb_bytes_to_str(tvbuff_t *tvb, const gint offset, const gint len)
{
	return bytes_to_str(ensure_contiguous(tvb, offset, len), len);
}
static const value_string q931_coding_standard_vals[] = {
	{ 0x0, "ITU-T standardized coding" },
	{ 0x1, "ISO/IEC standard" },
	{ 0x2, "National standard" },
	{ 0x3, "Standard defined for this particular network" },
	{ 0,    NULL }
};

static const value_string q931_information_transfer_capability_vals[] = {
	{ 0x00, "Speech" },
	{ 0x08, "Unrestricted digital information" },
	{ 0x09, "Restricted digital information" },
	{ 0x10, "3.1 kHz audio" },
	{ 0x11, "Unrestricted digital information with tones/announcements" },
	{ 0x18, "Video" },
	{ 0,    NULL }
};
static const value_string q931_transfer_mode_vals[] = {
	{ 0x00, "Circuit mode" },
	{ 0x02, "Packet mode" },
	{ 0,    NULL }
};
#define	Q931_IT_RATE_MULTIRATE	0x18
static const value_string q931_bearer_capability_layer_ident_vals[] = {
	{ 0x01, "Layer 1 identifier" },
	{ 0x02, "Layer 2 identifier" },
	{ 0x03, "Layer 3 identifier" },
	{ 0x00, NULL }
};
static const value_string q931_information_transfer_rate_vals[] = {
	{ 0x00,				"Packet mode" },
	{ 0x10,				"64 kbit/s" },
	{ 0x11,				"2 x 64 kbit/s" },
	{ 0x13,				"384 kbit/s" },
	{ 0x15,				"1536 kbit/s" },
	{ 0x17,				"1920 kbit/s" },
	{ Q931_IT_RATE_MULTIRATE,	"Multirate (64 kbit/s base rate)" },
	{ 0,				NULL }
};
static const value_string q931_uil1_vals[] = {
	{ 0x01, "V.110/I.460/X.30 rate adaption" },
	{ 0x02, "Recommendation G.711 u-law" },
	{ 0x03, "Recommendation G.711 A-law" },
	{ 0x04, "Recommendation G.721 32 kbit/s ADPCM and Recommendation I.460" },
	{ 0x05, "Recommendation H.221 and H.242" },
	{ 0x06, "Recommendation H.223 and H.245" },
	{ 0x07, "Non-ITU-T-standardized rate adaption" },
	{ 0x08, "V.120 rate adaption" },
	{ 0x09, "X.31 HDLC flag stuffing" },
	{ 0x0a, "Recommendation G.728 LD-CELP" },
	{ 0x0b, "Recommendation G.729 CS-ACELP" },
	{ 0,    NULL }
};
static const value_string q931_l1_intermediate_rate_vals[] = {
	{ 0x20, "8 kbit/s" },
	{ 0x40, "16 kbit/s" },
	{ 0x60, "32 kbit/s" },
	{ 0,    NULL }
};
static const value_string q931_l1_user_rate_vals[] = {
	{ 0x00, "Rate indicated by E-bits" },
	{ 0x01, "0.6 kbit/s" },
	{ 0x02, "1.2 kbit/s" },
	{ 0x03, "2.4 kbit/s" },
	{ 0x04, "3.6 kbit/s" },
	{ 0x05, "4.8 kbit/s" },
	{ 0x06, "7.2 kbit/s" },
	{ 0x07, "8 kbit/s" },
	{ 0x08, "9.6 kbit/s" },
	{ 0x09, "14.4 kbit/s" },
	{ 0x0A, "16 kbit/s" },
	{ 0x0B, "19.2 kbit/s" },
	{ 0x0C, "32 kbit/s" },
	{ 0x0E, "48 kbit/s" },
	{ 0x0F, "56 kbit/s" },
	{ 0x10, "64 kbit/s "},
	{ 0x15, "0.1345 kbit/s" },
	{ 0x16, "0.100 kbit/s" },
	{ 0x17, "0.075/1.2 kbit/s" },
	{ 0x18, "1.2/0.075 kbit/s" },
	{ 0x19, "0.050 kbit/s" },
	{ 0x1A, "0.075 kbit/s" },
	{ 0x1B, "0.110 kbit/s" },
	{ 0x1C, "0.150 kbit/s" },
	{ 0x1D, "0.200 kbit/s" },
	{ 0x1E, "0.300 kbit/s" },
	{ 0x1F, "12 kbit/s" },
	{ 0,    NULL }
};
static value_string_ext q931_l1_user_rate_vals_ext = VALUE_STRING_EXT_INIT(q931_l1_user_rate_vals);
static const value_string q931_l1_stop_bits_vals[] = {
	{ 0x20, "1" },
	{ 0x40, "1.5" },
	{ 0x60, "2" },
	{ 0,    NULL }
};
static const value_string q931_l1_data_bits_vals[] = {
	{ 0x08, "5" },
	{ 0x10, "7" },
	{ 0x18, "8" },
	{ 0,    NULL }
};

static const value_string q931_l1_parity_vals[] = {
	{ 0x00, "Odd" },
	{ 0x02, "Even" },
	{ 0x03, "None" },
	{ 0x04, "Forced to 0" },
	{ 0x05, "Forced to 1" },
	{ 0,    NULL }
};
static const value_string q931_l1_modem_type_vals[] = {
	{ 0x11, "V.21" },
	{ 0x12, "V.22" },
	{ 0x13, "V.22 bis" },
	{ 0x14, "V.23" },
	{ 0x15, "V.26" },
	{ 0x16, "V.26 bis" },
	{ 0x17, "V.26 ter" },
	{ 0x18, "V.27" },
	{ 0x19, "V.27 bis" },
	{ 0x1A, "V.27 ter" },
	{ 0x1B, "V.29" },
	{ 0x1C, "V.32" },
	{ 0x1E, "V.34" },
	{ 0,    NULL }
};

static value_string_ext q931_l1_modem_type_vals_ext = VALUE_STRING_EXT_INIT(q931_l1_modem_type_vals);
static const value_string q931_uil2_vals[] = {
	{ 0x01,			"Basic mode ISO 1745" },
	{ 0x02,			"Q.921/I.441" },	/* LAPD */
	{ 0x06,			"X.25, link layer" },	/* LAPB */
	{ 0x07,			"X.25 multilink" },	/* or 0x0F? */
	{ 0x08,			"T.71 Extended LAPB" },
	{ 0x09,			"HDLC ARM" },
	{ 0x0A,			"HDLC NRM" },
	{ 0x0B,			"HDLC ABM" },
	{ 0x0C,			"ISO 8802/2 LLC" },
	{ 0x0D,			"X.75 Single Link Procedure" },
	{ 0x0E,			"Q.922" },
	{ 0x0F,			"Core aspects of Q.922" },
	{ Q931_UIL2_USER_SPEC,	"User-specified" },
	{ 0x11,			"ISO 7776 DTE-DTE operation" },
	{ 0,			NULL }
};
static value_string_ext q931_uil2_vals_ext = VALUE_STRING_EXT_INIT(q931_uil2_vals);
static const value_string q931_mode_vals[] = {
	{ 0x20, "Normal mode" },
	{ 0x40, "Extended mode" },
	{ 0,    NULL }
};
#define	Q931_UIL3_X25_PL	0x06
#define	Q931_UIL3_ISO_8208	0x07	/* X.25-based */
#define	Q931_UIL3_X223		0x08	/* X.25-based */
#define	Q931_UIL3_TR_9577	0x0B
#define	Q931_UIL3_USER_SPEC	0x10

static const value_string q931_uil3_vals[] = {
	{ 0x02,			"Q.931/I.451" },
	{ Q931_UIL3_X25_PL,	"X.25, packet layer" },
	{ Q931_UIL3_ISO_8208,	"ISO/IEC 8208" },
	{ Q931_UIL3_X223,	"X.223/ISO 8878" },
	{ 0x09,			"ISO/IEC 8473" },
	{ 0x0A,			"T.70" },
	{ Q931_UIL3_TR_9577,	"ISO/IEC TR 9577" },
	{ Q931_UIL3_USER_SPEC,	"User-specified" },
	{ 0,			NULL }
};
const value_string nlpid_vals[] = {
  { NLPID_NULL,            "NULL" },
  { NLPID_SPI_X_29,        "X.29" },
  { NLPID_X_633,           "X.633" },
  { NLPID_Q_931,           "Q.931" },
  { NLPID_Q_2931,          "Q.2931" },
  { NLPID_Q_2119,          "Q.2119" },
  { NLPID_SNAP,            "SNAP" },
  { NLPID_ISO8473_CLNP,    "CLNP" },
  { NLPID_ISO9542_ESIS,    "ESIS" },
  { NLPID_ISO10589_ISIS,   "ISIS" },
  { NLPID_ISO10747_IDRP,   "IDRP" },
  { NLPID_ISO9542X25_ESIS, "ESIS (X.25)" },
  { NLPID_ISO10030,        "ISO 10030" },
  { NLPID_ISO11577,        "ISO 11577" },
  { NLPID_COMPRESSED,      "Data compression protocol" },
  { NLPID_IP,              "IP" },
  { NLPID_SNDCF,           "SubNetwork Dependent Convergence Function"},
  { NLPID_IP6,             "IPv6" },
  { NLPID_PPP,             "PPP" },
  { 0,                     NULL },
};

void
dissect_q931_bearer_capability_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet,a;
	guint8 coding_standard,LayerId;
	guint8 it_rate;
	guint8 modem_type;
	guint8 uil2_protocol;
	guint8 uil3_protocol;
	guint8 add_l3_info,info_element;
	/*guint8		octet[15],b;*/
	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
				printf("Extension indicator: "/*,call_ref[0] &= 0x7F*/);
			a=First_bit(octet);
			if(a==0)
			{
				printf("information continues through the next octet\n");
			}
			else
			{
				printf("last octet\n");
			}
	coding_standard = octet & 0x60;
					/*printf("Extension indicator: ");*/
		printf( "coding standared :%s (0x%02d)\n",val_to_str(coding_standard, q931_coding_standard_vals, "Unknown information element (0x%02X)"),coding_standard);	
	
	if (coding_standard != Q931_ITU_STANDARDIZED_CODING) {
		/*
		 * We don't know how the bearer capability is encoded,
		 * so just dump it as data and be done with it.
		 */
		//proto_tree_add_text(tree, tvb, offset,
		    //len, 
		printf("Data: %s\n",
		    tvb_bytes_to_str(tvb, offset, len));
		//proto_tree_add_boolean(tree, hf_q931_extension_ind, tvb, offset, 1, octet);
		//proto_tree_add_uint(tree, hf_q931_coding_standard, tvb, offset, 1, octet);
		return;
	}
	//proto_tree_add_boolean(tree, hf_q931_extension_ind, tvb, offset, 1, octet);
	//proto_tree_add_uint(tree, hf_q931_coding_standard, tvb, offset, 1, octet);
	//proto_tree_add_uint(tree, hf_q931_information_transfer_capability, tvb, offset, 1, octet);
	offset += 1;
	len -= 1;
	
	printf( "information transfer capability:%s (0x%02d)\n",val_to_str(last_five_octet(octet), q931_information_transfer_capability_vals, "Unknown information element (0x%02X)"),last_five_octet(octet));	
	/*
	 * XXX - only in Low-layer compatibility information element.
	 */
	if (!(octet & Q931_IE_VL_EXTENSION)) {
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);

		//proto_tree_add_text(tree, tvb, offset, 1,
		   printf( "Out-band negotiation %spossible\n",
		    (octet & 0x40) ? "" : "not ");
		offset += 1;
		len -= 1;
	}

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
				printf("Extension indicator: "/*,call_ref[0] &= 0x7F*/);
			a=First_bit(octet);
			if(a==0)
			{
				printf("information continues through the next octet\n");
			}
			else
			{
				printf("last octet\n");
			}

	printf( "Transfer mode:%s (0x%02d)\n",val_to_str(coding_standard, q931_transfer_mode_vals, "Unknown information element (0x%02X)"),len);
	printf( "Information transfer rate:%s (0x%02d)\n",val_to_str(last_five_octet(octet), q931_information_transfer_rate_vals, "Unknown information element (0x%02X)"),last_five_octet(octet));
	//proto_tree_add_boolean(tree, hf_q931_extension_ind, tvb, offset, 1, octet);
	//proto_tree_add_uint(tree, hf_q931_transfer_mode, tvb, offset, 1, octet);
	//proto_tree_add_uint(tree, hf_q931_information_transfer_rate, tvb, offset, 1, octet);
	it_rate = octet & 0x1F;
	offset += 1;
	len -= 1;

	if (it_rate == Q931_IT_RATE_MULTIRATE) {
		if (len == 0)
			return;
		//proto_tree_add_text(tree, tvb, offset, 1, 
			 printf( "Rate multiplier: %u\n", tvb_get_guint8(tvb, offset) & 0x7f);
		offset += 1;
		len -= 1;
	}

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	LayerId=(octet & 0x60)>>5;
     
			printf("Extension indicator: "/*,call_ref[0] &= 0x7F*/);
			a=First_bit(octet);
			if(a==0)
			{
				printf("information continues through the next octet\n");
			}
			else
			{
				printf("last octet\n");
			}
			
	printf( "Layer identification:%s (0x%02d)\n",val_to_str(LayerId, q931_bearer_capability_layer_ident_vals, "Unknown information element (0x%02X)"),LayerId);
	printf( "User information layer 1 protocol:%s (0x%02d)\n",val_to_str(last_five_octet(octet), q931_uil1_vals, "Unknown information element (0x%02X)"),last_five_octet(octet));
	if ((octet & 0x60) == 0x20) {
		/*
		 * Layer 1 information.
		 */
		//proto_tree_add_boolean(tree, hf_q931_extension_ind, tvb, offset, 1, octet);
		//proto_tree_add_uint(tree, hf_q931_layer_ident, tvb, offset, 1, octet);
		//proto_tree_add_uint(tree, hf_q931_uil1, tvb, offset, 1, octet);
		offset += 1;
		len -= 1;
		octet = tvb_get_guint8(tvb, offset);
		if (octet & Q931_IE_VL_EXTENSION)
			goto l1_done;
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "Layer 1 is %s",
		    (octet & 0x40) ? "Asynchronous" : "Synchronous");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "Layer 1 in-band negotiation is %spossible\n",
		    (octet & 0x20) ? "" : "not ");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "User rate: %s\n",
		    val_to_str_ext(octet & 0x1F, &q931_l1_user_rate_vals_ext,
		      "Unknown (0x%02X)"));
		offset += 1;
		len -= 1;

		if (octet & Q931_IE_VL_EXTENSION)
			goto l1_done;
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "Intermediate rate: %s\n",
		      val_to_str(octet & 0x60, q931_l1_intermediate_rate_vals,
		       "Unknown (0x%X)"));
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "%s to send data with network independent clock\n",
		    (octet & 0x10) ? "Required" : "Not required");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "%s accept data with network independent clock\n",
		    (octet & 0x08) ? "Can" : "Cannot");
		//proto_tree_add_text(tree, tvb, offset, 1,
		     printf( "%s to send data with flow control mechanism\n",
		    (octet & 0x04) ? "Required" : "Not required");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "%s accept data with flow control mechanism\n",
		    (octet & 0x02) ? "Can" : "Cannot");
		offset += 1;
		len -= 1;

		if (octet & Q931_IE_VL_EXTENSION)
			goto l1_done;
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tree, tvb, offset, 1,
		     printf( "Rate adaption header %sincluded\n",
		    (octet & 0x40) ? "" : "not ");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "Multiple frame establishment %ssupported\n",
		    (octet & 0x20) ? "" : "not ");
		//proto_tree_add_text(tree, tvb, offset, 1,
		     printf( "%s mode of operation\n",
		    (octet & 0x10) ? "Protocol sensitive" : "Bit transparent");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf( (octet & 0x08) ?
		     "Full protocol negotiation" : "LLI = 256 only\n");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "Message originator is %s\n",
		    (octet & 0x04) ? "Assignor only" : "Default assignee");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "Negotiation is done %s\n",
		    (octet & 0x02) ? "in-band" : "out-of-band");
		offset += 1;
		len -= 1;

		if (octet & Q931_IE_VL_EXTENSION)
			goto l1_done;
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tree, tvb, offset, 1,
		     printf( "Stop bits: %s\n",
		      val_to_str(octet & 0x60, q931_l1_stop_bits_vals,
		       "Unknown (0x%X)"));
		//proto_tree_add_text(tree, tvb, offset, 1,
		   printf(   "Data bits: %s\n",
		      val_to_str(octet & 0x18, q931_l1_data_bits_vals,
		       "Unknown (0x%X)"));
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "Parity: %s\n",
		      val_to_str(octet & 0x07, q931_l1_parity_vals,
		       "Unknown (0x%X)"));

		if (octet & Q931_IE_VL_EXTENSION)
			goto l1_done;
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "%s duplex\n",
		    (octet & 0x40) ? "Full" : "Half");
		modem_type = octet & 0x3F;
		if (modem_type <= 0x5 ||
		    (modem_type >= 0x20 && modem_type <= 0x2F)) {
			//proto_tree_add_text(tree, tvb, offset, 1,
			   printf(   "Modem type: National use 0x%02X\n", modem_type);
		} else if (modem_type >= 0x30) {
			//proto_tree_add_text(tree, tvb, offset, 1,
			  printf(  "Modem type: User specified 0x%02X", modem_type);
		} else {
			//proto_tree_add_text(tree, tvb, offset, 1,
			   printf(   "Modem type: %s\n",
			      val_to_str_ext(modem_type, &q931_l1_modem_type_vals_ext,
			      "Unknown (0x%02X)"));
		}
		offset += 1;
		len -= 1;
	}
l1_done:
	;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	if ((octet & 0x60) == 0x40) {
		/*
		 * Layer 2 information.
		 */
		//proto_tree_add_boolean(tree, hf_q931_extension_ind, tvb, offset, 1, octet);
		//proto_tree_add_uint(tree, hf_q931_layer_ident, tvb, offset, 1, octet);
		uil2_protocol = octet & 0x1F;
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf(  "User information layer 2 protocol: %s\n",
		    val_to_str_ext(uil2_protocol, &q931_uil2_vals_ext,
		      "Unknown (0x%02X)"));
		offset += 1;
		len -= 1;

		/*
		 * XXX - only in Low-layer compatibility information element.
		 */
		if (octet & Q931_IE_VL_EXTENSION)
			goto l2_done;
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		if (uil2_protocol == Q931_UIL2_USER_SPEC) {
			//proto_tree_add_text(tree, tvb, offset, 1,
			    printf(  "User-specified layer 2 protocol information: 0x%02X\n",
			    octet & 0x7F);
		} else {
			//proto_tree_add_text(tree, tvb, offset, 1,
			    printf(  "Mode: %s\n",
			    val_to_str(octet & 0x60, q931_mode_vals,
			      "Unknown (0x%02X)"));
		}
		offset += 1;
		len -= 1;

		if (octet & Q931_IE_VL_EXTENSION)
			goto l2_done;
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tree, tvb, offset, 1,
		  printf(    "Window size: %u k\n", octet & 0x7F);
		offset += 1;
		len -= 1;
	}
l2_done:
	;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	if ((octet & 0x60) == 0x60) {
		/*
		 * Layer 3 information.
		 */
		//proto_tree_add_boolean(tree, hf_q931_extension_ind, tvb, offset, 1, octet);
		///proto_tree_add_uint(tree, hf_q931_layer_ident, tvb, offset, 1, octet);
		uil3_protocol = octet & 0x1F;
		//proto_tree_add_text(tree, tvb, offset, 1,
		     printf( "User information layer 3 protocol: %s\n",
		    val_to_str(uil3_protocol, q931_uil3_vals,
		      "Unknown (0x%02X)"));
		offset += 1;
		len -= 1;


		/*
		 * XXX - only in Low-layer compatibility information element.
		 */
		if (octet & Q931_IE_VL_EXTENSION)
			goto l3_done;
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		switch (uil3_protocol) {

		case Q931_UIL3_X25_PL:
		case Q931_UIL3_ISO_8208:
		case Q931_UIL3_X223:
			//proto_tree_add_text(tree, tvb, offset, 1,
			    printf(  "Mode: %s\n",
			    val_to_str(octet & 0x60, q931_mode_vals,
			      "Unknown (0x%02X)"));
			offset += 1;
			len -= 1;

			if (octet & Q931_IE_VL_EXTENSION)
				goto l3_done;
			if (len == 0)
				return;
			octet = tvb_get_guint8(tvb, offset);
			//proto_tree_add_text(tree, tvb, offset, 1,
			     printf( "Default packet size: %u\n", octet & 0x0F);
			offset += 1;
			len -= 1;

			if (octet & Q931_IE_VL_EXTENSION)
				goto l3_done;
			if (len == 0)
				return;
			octet = tvb_get_guint8(tvb, offset);
			//proto_tree_add_text(tree, tvb, offset, 1,
			    printf(  "Packet window size: %u\n", octet & 0x7F);
			offset += 1;
			len -= 1;
			break;

		case Q931_UIL3_USER_SPEC:
			//proto_tree_add_text(tree, tvb, offset, 1,
			   printf(   "Default packet size: %u octets\n",
			    1 << (octet & 0x0F));
			offset += 1;
			len -= 1;
			break;

		case Q931_UIL3_TR_9577:
			add_l3_info = (octet & 0x0F) << 4;
			if (octet & Q931_IE_VL_EXTENSION)
				goto l3_done;
			if (len == 0)
				return;
			octet = tvb_get_guint8(tvb, offset + 1);
			add_l3_info |= (octet & 0x0F);
			//proto_tree_add_text(tree, tvb, offset, 2,
			    printf(  "Additional layer 3 protocol information: %s\n",
			    val_to_str(add_l3_info, nlpid_vals,
			      "Unknown (0x%02X)"));
			offset += 2;
			len -= 2;
			break;
		}
	}
l3_done:
	;
}
static const value_string q931_cause_recommendation_vals[] = {
	{ 0x00, "Q.931" },
	{ 0x03, "X.21" },
	{ 0x04, "X.25" },
	{ 0x05, "Q.1031/Q.1051" },
	{ 0,    NULL }
};
static const value_string q931_cause_condition_vals[] = {
	{ 0x00, "Unknown" },
	{ 0x01, "Permanent" },
	{ 0x02, "Transient" },
	{ 0x00, NULL }
};
static const value_string q931_rejection_reason_vals[] = {
	{ 0x00, "User specific" },
	{ 0x04, "Information element missing" },
	{ 0x08, "Information element contents are not sufficient" },
	{ 0x00, NULL }
};


guint8 *
tvb_get_ephemeral_string(tvbuff_t *tvb, const gint offset, const gint length)
{
	guint8       *strbuf;

	tvb_ensure_bytes_exist(tvb, offset, length); /* make sure length = -1 fails */
	strbuf =(guint8*) malloc(length + 1);
	tvb_memcpy(tvb, strbuf, offset, length);
	strbuf[length] = '\0';
	return strbuf;
}
static void
dissect_q931_cause_ie_unsafe(tvbuff_t *tvb, int offset, int len,
  int hf_cause_value, guint8 *cause_value, const value_string *ie_vals)
{
	guint8 octet;
	guint8 coding_standard;
	guint8 rejection_reason;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	coding_standard = octet & 0x60;
	if (coding_standard != Q931_ITU_STANDARDIZED_CODING) {
		/*
		 * We don't know how the cause is encoded,
		 * so just dump it as data and be done with it.
		 */
		//proto_tree_add_uint(tree, hf_q931_coding_standard, tvb, offset, 1, octet);
		//proto_tree_add_text(tree, tvb, offset,
		   // len,
		printf("Data: %s\n",
		    tvb_bytes_to_str(tvb, offset, len));
		return;
	}
	//proto_tree_add_uint(tree, hf_q931_cause_location, tvb, offset, 1, octet);
	//proto_tree_add_uint(tree, hf_q931_coding_standard, tvb, offset, 1, octet);
	//proto_tree_add_boolean(tree, hf_q931_extension_ind, tvb, offset, 1, octet);
	offset += 1;
	len -= 1;

	if (!(octet & Q931_IE_VL_EXTENSION)) {
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tree, tvb, offset, 1,
		   printf( "Recommendation: %s\n",
		    val_to_str(octet & 0x7F, q931_cause_recommendation_vals,
		      "Unknown (0x%02X)"));
		//proto_tree_add_boolean(tree, hf_q931_extension_ind, tvb, offset, 1, octet);
		offset += 1;
		len -= 1;
	}

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	*cause_value = octet & 0x7F;

	/* add cause value to packet info for use in tap */
	if(have_valid_q931_pi) {
		q931_pi->cause_value = *cause_value;
	}
	offset += 1;
	len -= 1;

	if (len == 0)
		return;
	switch (*cause_value) {

	case Q931_CAUSE_UNALLOC_NUMBER:
	case Q931_CAUSE_NO_ROUTE_TO_DEST:
	case Q931_CAUSE_QOS_UNAVAILABLE:
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tvb, offset, 1,
		     printf("Network service: %s\n",
		    (octet & 0x80) ? "User" : "Provider");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf( "%s\n",
		    (octet & 0x40) ? "Abnormal" : "Normal");
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf( "Condition: %s\n",
		    val_to_str(octet & 0x03, q931_cause_condition_vals,
		      "Unknown (0x%X)"));
		break;

	case Q931_CAUSE_CALL_REJECTED:
		rejection_reason = octet & 0x7C;
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf( "Rejection reason: %s\n",
		    val_to_str(octet & 0x7C, q931_rejection_reason_vals,
		      "Unknown (0x%X)"));
		//proto_tree_add_text(tree, tvb, offset, 1,
		     printf("Condition: %s\n",
		    val_to_str(octet & 0x03, q931_cause_condition_vals,
		      "Unknown (0x%X)"));
		offset += 1;
		len -= 1;

		if (len == 0)
			return;
		switch (rejection_reason) {

		case Q931_REJ_USER_SPECIFIC:
			//proto_tree_add_text(tree, tvb, offset, len,
			    printf( "User specific diagnostic: %s\n",
			    tvb_bytes_to_str(tvb, offset, len));
			break;

		case Q931_REJ_IE_MISSING:
			//proto_tree_add_text(tree, tvb, offset, 1,
			   printf(  "Missing information element: %s\n",
			    val_to_str(tvb_get_guint8(tvb, offset), ie_vals,
			      "Unknown (0x%02X)"));
			break;

		case Q931_REJ_IE_INSUFFICIENT:
			//proto_tree_add_text(tree, tvb, offset, 1,
			     printf("Insufficient information element: %s\n",
			    val_to_str(tvb_get_guint8(tvb, offset), ie_vals,
			      "Unknown (0x%02X)"));
			break;

		default:
			//proto_tree_add_text(tree, tvb, offset, len,
			   printf(  "Diagnostic: %s\n",
			    tvb_bytes_to_str(tvb, offset, len));
			break;
		}
		break;

	case Q931_CAUSE_ACCESS_INFO_DISC:
	case Q931_CAUSE_INCOMPATIBLE_DEST:
	case Q931_CAUSE_MAND_IE_MISSING:
	case Q931_CAUSE_IE_NONEX_OR_UNIMPL:
	case Q931_CAUSE_INVALID_IE_CONTENTS:
		do {
			//proto_tree_add_text(tree, tvb, offset, 1,
			     printf("Information element: %s\n",
			    val_to_str(tvb_get_guint8(tvb, offset), ie_vals,
			      "Unknown (0x%02X)"));
			offset += 1;
			len -= 1;
		} while (len != 0);
		break;

	case Q931_CAUSE_MT_NONEX_OR_UNIMPL:
	case Q931_CAUSE_MSG_INCOMPAT_W_CS:
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf( "Message type: %s\n",
		    val_to_str_ext(tvb_get_guint8(tvb, offset), &q931_message_type_vals_ext,
		      "Unknown (0x%02X)"));
		break;

	case Q931_CAUSE_REC_TIMER_EXP:
		if (len < 3)
			return;
		//proto_tree_add_text(tree, tvb, offset, 3,
		     printf("Timer: %.3s\n", tvb_get_ephemeral_string(tvb, offset, 3));
		break;

	default:
		//proto_tree_add_text(tree, tvb, offset, len,
		    printf("Diagnostics: %s\n",
		    tvb_bytes_to_str(tvb, offset, len));
	}
}
char *
decode_bitfield_value(char *buf, const guint32 val, const guint32 mask, const int width)
{
  int i;
  guint32 bit=0;
  char *p;

  i = 0;
  p = buf;
  bit = 1 << (width - 1);
  for (;;) {
    if (mask & bit) {
      /* This bit is part of the field.  Show its value. */
      if (val & bit)
        *p++ = '1';
      else
        *p++ = '0';
    } else {
      /* This bit is not part of the field. */
      *p++ = '.';
    }
    bit >>= 1;
    i++;
    if (i >= width)
      break;
    if (i % 4 == 0)
      *p++ = ' ';
  }
  *p = '\0';
  return p;
}
//int g_snprintf(char *str, size_t size, const char *fmt, ...)
//    {
//       va_list ap=0;
//       int count;
//   
//      va_start(ap, fmt);
//       count = vsnprintf(str, size, fmt, ap);
//       va_end(ap);
//    
//       /* Windows' vsnprintf() doesn't always NUL-terminate the buffer */
//       if (count == size)
//           str[--count] = '\0';
//   
//        return count;
//    }
const char *
decode_enumerated_bitfield(const guint32 val, const guint32 mask, const int width,
    const value_string *tab, const char *fmt)
{
  static char buf[1025];
  char *p;

  p = decode_bitfield_value(buf, val, mask, width);
  g_snprintf(p, (gulong) (1024-(p-buf)), fmt, val_to_str(val & mask, tab, "Unknown"));
  return buf;
}
const char *
decode_enumerated_bitfield_shifted(const guint32 val, const guint32 mask, const int width,
    const value_string *tab, const char *fmt)
{
  static char buf[1025];
  char *p;
  int shift = 0;

  /* Compute the number of bits we have to shift the bitfield right
     to extract its value. */
  while ((mask & (1<<shift)) == 0)
    shift++;

  p = decode_bitfield_value(buf, val, mask, width);
  g_snprintf(p, (gulong) (1024-(p-buf)), fmt, val_to_str((val & mask) >> shift, tab, "Unknown"));
  return buf;
}
static const value_string q931_status_preference_vals[] = {
	{ 0x01, "Channel" },
	{ 0,    NULL }
};
static const value_string q931_new_status_vals[] = {
	{ 0x00, "In Service" },
	{ 0x01, "Maintenance" },
	{ 0x02, "Out of Service" },
	{ 0,    NULL }
};
static void
dissect_q931_change_status_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);

	//proto_tree_add_item(tree, hf_q931_extension_ind, tvb, offset, 1, ENC_BIG_ENDIAN);
	//proto_tree_add_text(tree, tvb, offset, 1,
	printf("%s\n",
		decode_enumerated_bitfield_shifted(octet, 0x40, 8, VALS(q931_status_preference_vals), "Preference: %s"));
	//proto_tree_add_text(tree, tvb, offset, 1,
	printf("%s\n",
		decode_enumerated_bitfield(octet, 0x07, 8, VALS(q931_new_status_vals), "New status: %s"));
}
static const value_string q931_call_state_vals[] = {
	{ 0x00, "Null" },
	{ 0x01, "Call initiated" },
	{ 0x02, "Overlap sending" },
	{ 0x03, "Outgoing call proceeding" },
	{ 0x04, "Call delivered" },
	{ 0x06, "Call present" },
	{ 0x07, "Call received" },
	{ 0x08, "Connect request" },
	{ 0x09, "Incoming call proceeding" },
	{ 0x0A, "Active" },
	{ 0x0B, "Disconnect request" },
	{ 0x0C, "Disconnect indication" },
	{ 0x0F, "Suspend request" },
	{ 0x11, "Resume request" },
	{ 0x13, "Release request" },
	{ 0x16, "Call abort"},
	{ 0x19, "Overlap receiving" },
	{ 0x3D, "Restart request" },
	{ 0x3E, "Restart" },
	{ 0,    NULL }
};
value_string_ext q931_call_state_vals_ext = VALUE_STRING_EXT_INIT(q931_call_state_vals);
static void
dissect_q931_call_state_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;
	guint8 coding_standard;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	coding_standard = octet & 0x60;
	//proto_tree_add_uint(tree, hf_q931_coding_standard, tvb, offset, 1, octet);
	if (coding_standard != Q931_ITU_STANDARDIZED_CODING) {
		/*
		 * We don't know how the call state is encoded,
		 * so just dump it as data and be done with it.
		 */
		//proto_tree_add_text(tree, tvb, offset,
		    //len, 
		printf("Data: %s\n",
		    tvb_bytes_to_str(tvb, offset, len));
		return;
	}
	//proto_tree_add_text(tree, tvb, offset, 1,
	   printf( "Call state: %s\n",
	    val_to_str_ext(octet & 0x3F, &q931_call_state_vals_ext,
	      "Unknown (0x%02X)"));
}
static void
dissect_q931_channel_identification_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;
	guint8 coding_standard;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);

	/*if (octet & Q931_NOT_BASIC_CHANNEL) {
		proto_tree_add_item(tree, hf_q931_channel_selection_pri, tvb, offset, 1, ENC_BIG_ENDIAN);
	} else {
		proto_tree_add_item(tree, hf_q931_channel_selection_bri, tvb, offset, 1, ENC_BIG_ENDIAN);
	}*/
	offset += 1;
	len -= 1;

	if (octet & Q931_INTERFACE_IDENTIFIED) {
		guint8 octet2;
		guint32 identifier_val = 0;
		int identifier_offset = offset;
		int identifier_len = 0;
		do {
			if (len == 0)
				break;
			octet2 = tvb_get_guint8(tvb, offset);
			offset += 1;
			len -= 1;
			identifier_len++;
			identifier_val <<= 7;
			identifier_val |= octet2 & 0x7F;
		} while (!(octet2 & Q931_IE_VL_EXTENSION));

		if (identifier_len != 0) {
			//proto_tree_add_text(tree, tvb, identifier_offset,
			   // identifier_len,
			printf("Interface ID: %u\n", identifier_val);
		}
	}

	if (octet & Q931_NOT_BASIC_CHANNEL) {
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		coding_standard = octet & 0x60;
		if (coding_standard != Q931_ITU_STANDARDIZED_CODING) {
			/*
			 * We don't know how the channel identifier is
			 * encoded, so just dump it as data and be done
			 * with it.
			 */
			//proto_tree_add_text(tree, tvb, offset,
			   // len,
			printf("Data: %s\n",
			    tvb_bytes_to_str(tvb, offset, len));
			return;
		}

		offset += 1;
		len -= 1;

		if (octet & Q931_IS_SLOT_MAP) {
			guint8 octet2;
			while (len) {
				octet2 = tvb_get_guint8(tvb, offset);
				//proto_tree_add_text(tree, tvb, offset, 1,
					printf("Slot map: 0x%02x\n", octet2);
				offset += 1;
				len -= 1;
			}
		} else {
			guint8 octet2;
			do {
				if (len == 0)
					break;
				octet2 = tvb_get_guint8(tvb, offset);

				offset += 1;
				len -= 1;
			} while (!(octet2 & Q931_IE_VL_EXTENSION));
		}
	}
}
static const value_string q931_cause_location_vals[] = {
	{ 0x00, "User (U)" },
	{ 0x01, "Private network serving the local user (LPN)" },
	{ 0x02, "Public network serving the local user (LN)" },
	{ 0x03, "Transit network (TN)" },
	{ 0x04, "Public network serving the remote user (RLN)" },
	{ 0x05, "Private network serving the remote user (RPN)" },
	{ 0x06, "Unallocated code" },
	{ 0x07, "International network (INTL)" },
	{ 0x08, "Unallocated code" },
	{ 0x09, "Unallocated code" },
	{ 0x0A, "Network beyond interworking point (BI)" },
	{ 0,    NULL }
};
value_string_ext q931_cause_location_vals_ext = VALUE_STRING_EXT_INIT(q931_cause_location_vals);
static const value_string q931_progress_description_vals[] = {
	{ 0x01, "Call is not end-to-end ISDN - progress information available in-band" },
	{ 0x02, "Destination address is non-ISDN" },
	{ 0x03, "Origination address is non-ISDN" },
	{ 0x04, "Call has returned to the ISDN" },
	{ 0x05, "Interworking has occurred and has resulted in a telecommunications service change" },
	{ 0x08, "In-band information or an appropriate pattern is now available" },
	{ 0,    NULL }
};
value_string_ext q931_progress_description_vals_ext = VALUE_STRING_EXT_INIT(q931_progress_description_vals);
void
dissect_q931_progress_indicator_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;
	guint8 coding_standard;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	coding_standard = octet & 0x60;
	//proto_tree_add_uint(tree, hf_q931_coding_standard, tvb, offset, 1, octet);
	if (coding_standard != Q931_ITU_STANDARDIZED_CODING) {
		/*
		 * We don't know how the progress indicator is encoded,
		 * so just dump it as data and be done with it.
		 */
		//proto_tree_add_text(tree, tvb, offset,
		   // len,
		printf("Data: %s\n",
		    tvb_bytes_to_str(tvb, offset, len));
		return;
	}
	//proto_tree_add_text(tree, tvb, offset, 1,
	    printf("Location: %s\n",
	    val_to_str_ext(octet & 0x0F, &q931_cause_location_vals_ext,
	      "Unknown (0x%X)"));
	offset += 1;
	len -= 1;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	//proto_tree_add_text(tree, tvb, offset, 1,
	    printf("Progress description: %s\n",
	    val_to_str_ext(octet & 0x7F, &q931_progress_description_vals_ext,
	      "Unknown (0x%02X)"));
}
static const value_string q931_netid_type_vals[] = {
	{ 0x00, "User specified" },
	{ 0x20, "National network identification" },
	{ 0x30, "International network identification" },
	{ 0,    NULL }
};
static const value_string q931_netid_plan_vals[] = {
	{ 0x00, "Unknown" },
	{ 0x01, "Carrier Identification Code" },
	{ 0x03, "X.121 data network identification code" },
	{ 0,    NULL }
};
static gpointer
g_realloc (gpointer mem,
	   gsize    n_bytes)
{
  gpointer newmem;

  if (/*G_LIKELY (*/n_bytes/*)*/)
    {
      newmem = realloc (mem, n_bytes);
      //TRACE (GLIB_MEM_REALLOC((void*) newmem, (void*)mem, (unsigned int) n_bytes, 0));
      if (newmem)
	return newmem;

      //g_error ("%s: failed to allocate %"G_GSIZE_FORMAT" bytes",
      //         G_STRLOC, n_bytes);
    }

  if (mem)
    free (mem);

  //TRACE (GLIB_MEM_REALLOC((void*) NULL, (void*)mem, 0, 0));

  return NULL;
}
gchar *
format_text(const guchar *string, size_t len)
{
  static gchar *fmtbuf[3];
  static int fmtbuf_len[3];
  static int idx;
  int column;
  const guchar *stringend = string + len;
  guchar c;
  int i;

  idx = (idx + 1) % 3;

  /*
   * Allocate the buffer if it's not already allocated.
   */
  if (fmtbuf[idx] == NULL) {
    fmtbuf[idx] = (gchar*)malloc(INITIAL_FMTBUF_SIZE);
    fmtbuf_len[idx] = INITIAL_FMTBUF_SIZE;
  }
  column = 0;
  while (string < stringend) {
    /*
     * Is there enough room for this character, if it expands to
     * a backslash plus 3 octal digits (which is the most it can
     * expand to), and also enough room for a terminating '\0'?
     */
    if (column+3+1 >= fmtbuf_len[idx]) 
	{
      /*
       * Double the buffer's size if it's not big enough.
       * The size of the buffer starts at 128, so doubling its size
       * adds at least another 128 bytes, which is more than enough
       * for one more character plus a terminating '\0'.
       */
      fmtbuf_len[idx] = fmtbuf_len[idx] * 2;
      fmtbuf[idx] = (gchar*)g_realloc(fmtbuf[idx], fmtbuf_len[idx]);
    }
    c = *string++;

    if (isprint(c)) {
      fmtbuf[idx][column] = c;
      column++;
    } else {
      fmtbuf[idx][column] =  '\\';
      column++;
      switch (c) {

      case '\a':
	fmtbuf[idx][column] = 'a';
	column++;
	break;

      case '\b':
	fmtbuf[idx][column] = 'b'; /* BS */
	column++;
	break;

      case '\f':
	fmtbuf[idx][column] = 'f'; /* FF */
	column++;
	break;

      case '\n':
	fmtbuf[idx][column] = 'n'; /* NL */
	column++;
	break;

      case '\r':
	fmtbuf[idx][column] = 'r'; /* CR */
	column++;
	break;

      case '\t':
	fmtbuf[idx][column] = 't'; /* tab */
	column++;
	break;

      case '\v':
	fmtbuf[idx][column] = 'v';
	column++;
	break;

      default:
	i = (c>>6)&03;
	fmtbuf[idx][column] = i + '0';
	column++;
	i = (c>>3)&07;
	fmtbuf[idx][column] = i + '0';
	column++;
	i = (c>>0)&07;
	fmtbuf[idx][column] = i + '0';
	column++;
	break;
      }
    }
  }
  fmtbuf[idx][column] = '\0';
  return fmtbuf[idx];
}
gchar *
tvb_format_text(tvbuff_t *tvb, const gint offset, const gint size)
{
	const guint8 *ptr;
	gint          len;

	len = (size > 0) ? size : 0;

	if ((ptr = ensure_contiguous(tvb, offset, size)) == NULL) {
		len = tvb_length_remaining(tvb, offset);
		ptr = ensure_contiguous(tvb, offset, len);
	}

	return format_text(ptr, len);
}
static void
dissect_q931_ns_facilities_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;
	int netid_len;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	netid_len = octet & 0x7F;
	//proto_tree_add_text(tree, tvb, offset, 1,
	   printf( "Network identification length: %u\n",
	    netid_len);
	offset += 1;
	len -= 1;
	if (netid_len != 0) {
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf("Type of network identification: %s\n",
		    val_to_str(octet & 0x70, q931_netid_type_vals,
		      "Unknown (0x%02X)"));
		//proto_tree_add_text(tree, tvb, offset, 1,
		   printf( "Network identification plan: %s\n",
		    val_to_str(octet & 0x0F, q931_netid_plan_vals,
		      "Unknown (0x%02X)"));
		offset += 1;
		len -= 1;
		netid_len--;

		if (len == 0)
			return;
		if (netid_len > len)
			netid_len = len;
		if (netid_len != 0) {
			//proto_tree_add_text(tree, tvb, offset, netid_len,
			   printf( "Network identification: %s\n",
			    tvb_format_text(tvb, offset, netid_len));
			offset += netid_len;
			len -= netid_len;
		}
	}

	/*
	 * Whatever is left is the network-specific facility
	 * specification.
	 */
	 if (len == 0)
	 	return;
	//proto_tree_add_text(tree, tvb, offset,
	   // len,
	 printf("Network-specific facility specification: %s\n",
	    tvb_bytes_to_str(tvb, offset, len));
}
static void
dissect_q931_ia5_ie(tvbuff_t *tvb, int offset, int len,
    const char *label)	
{
	if (len != 0) {
		printf("  '%s'\n", tvb_format_text(tvb, offset, len));
		//proto_tree_add_text(tree, tvb, offset, len,
		printf("%s: %s\n", label,
		    tvb_format_text(tvb, offset, len));
		//proto_item_append_text(proto_tree_get_parent(tree), 
			
	}
}

static const value_string q931_notification_description_vals[] = {
	{ 0x00, "User suspended" },
	{ 0x01, "User resumed" },
	{ 0x02, "Bearer service change" },
	{ 0,    NULL }
};

static void
dissect_q931_notification_indicator_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	//proto_tree_add_text(tree, tvb, offset, 1,
	    printf("Notification description: %s\n",
	    val_to_str(octet & 0x7F, q931_notification_description_vals,
	      "Unknown (0x%02X)"));
}
static void
dissect_q931_date_time_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len == 6) {
		/*
		 * XXX - what is "year" relative to?  Is "month" 0-origin or
		 * 1-origin?  Q.931 doesn't say....
		 */
		//proto_tree_add_text(tree, tvb, offset, 6,
		    printf( "Date/time: %02u-%02u-%02u %02u:%02u:%02u\n",
		    tvb_get_guint8(tvb, offset + 0), tvb_get_guint8(tvb, offset + 1), tvb_get_guint8(tvb, offset + 2),
		    tvb_get_guint8(tvb, offset + 3), tvb_get_guint8(tvb, offset + 4), tvb_get_guint8(tvb, offset + 5));
	} else if (len == 5) {
		//proto_tree_add_text(tree, tvb, offset, 5,
		    printf( "Date/time: %02u-%02u-%02u %02u:%02u:00\n",
		    tvb_get_guint8(tvb, offset + 0), tvb_get_guint8(tvb, offset + 1), tvb_get_guint8(tvb, offset + 2),
		    tvb_get_guint8(tvb, offset + 3), tvb_get_guint8(tvb, offset + 4));
	} else {
		//proto_tree_add_text(tree, tvb, offset, len,
		     printf("Date/time: length is %d, should be 5 or 6\n", len);
	}
}
static const value_string q931_signal_vals[] = {
	{ 0x00, "Dial tone on" },
	{ 0x01, "Ring tone on" },
	{ 0x02, "Intercept tone on" },
	{ 0x03, "Network congestion tone on" },	/* "fast busy" */
	{ 0x04, "Busy tone on" },
	{ 0x05, "Confirm tone on" },
	{ 0x06, "Answer tone on" },
	{ 0x07, "Call waiting tone on" },
	{ 0x08, "Off-hook warning tone on" },
	{ 0x09, "Preemption tone on" },
	{ 0x3F, "Tones off" },
	{ 0x40, "Alerting on - pattern 0" },
	{ 0x41, "Alerting on - pattern 1" },
	{ 0x42, "Alerting on - pattern 2" },
	{ 0x43, "Alerting on - pattern 3" },
	{ 0x44, "Alerting on - pattern 4" },
	{ 0x45, "Alerting on - pattern 5" },
	{ 0x46, "Alerting on - pattern 6" },
	{ 0x47, "Alerting on - pattern 7" },
	{ 0x4F, "Alerting off" },
	{ 0,    NULL }
};
static value_string_ext q931_signal_vals_ext = VALUE_STRING_EXT_INIT(q931_signal_vals);

static void
dissect_q931_signal_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len != 1) {
		//proto_tree_add_text(tree, tvb, offset, len,
		    printf( "Signal: length is %d, should be 1\n", len);
		return;
	}
	//proto_tree_add_text(tree, tvb, offset, 1,
	    printf( "Signal: %s\n",
	    val_to_str_ext(tvb_get_guint8(tvb, offset), &q931_signal_vals_ext,
	        "Unknown (0x%02X)"));
}
static const value_string q931_throughput_class_vals[] = {
	{ 0x03, "75 bit/s" },
	{ 0x04, "150 bit/s" },
	{ 0x05, "300 bit/s" },
	{ 0x06, "600 bit/s" },
	{ 0x07, "1200 bit/s" },
	{ 0x08, "2400 bit/s" },
	{ 0x09, "4800 bit/s" },
	{ 0x0A, "9600 bit/s" },
	{ 0x0B, "19200 bit/s" },
	{ 0x0C, "48000 bit/s" },
	{ 0x0D, "64000 bit/s" },
	{ 0,    NULL }
};
static value_string_ext q931_throughput_class_vals_ext = VALUE_STRING_EXT_INIT(q931_throughput_class_vals);

static void
dissect_q931_information_rate_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len != 4) {
		//proto_tree_add_text(tree, tvb, offset, len,
		    printf( "Information rate: length is %d, should be 4\n", len);
		return;
	}
	//proto_tree_add_text(tree, tvb, offset + 0, 1,
	    printf( "Incoming information rate: %s\n",
	    val_to_str_ext(tvb_get_guint8(tvb, offset + 0) & 0x1F,
	      &q931_throughput_class_vals_ext, "Unknown (0x%02X)"));
	//proto_tree_add_text(tree, tvb, offset + 1, 1,
	    printf( "Outgoing information rate: %s\n",
	    val_to_str_ext(tvb_get_guint8(tvb, offset + 1) & 0x1F,
	      &q931_throughput_class_vals_ext, "Unknown (0x%02X)"));
	//proto_tree_add_text(tree, tvb, offset + 2, 1,
	     printf("Minimum incoming information rate: %s\n",
	    val_to_str_ext(tvb_get_guint8(tvb, offset + 2) & 0x1F,
	      &q931_throughput_class_vals_ext, "Unknown (0x%02X)"));
	//proto_tree_add_text(tree, tvb, offset + 3, 1,
	     printf("Minimum outgoing information rate: %s\n",
	    val_to_str_ext(tvb_get_guint8(tvb, offset + 3) & 0x1F,
	      &q931_throughput_class_vals_ext, "Unknown (0x%02X)"));
}
static int
dissect_q931_guint16_value(tvbuff_t *tvb, int offset, int len, const char *label)
{
	guint8 octet;
	guint16 value;
	int value_len;

	value_len = 0;

	octet = tvb_get_guint8(tvb, offset);
	if (octet & Q931_IE_VL_EXTENSION) {
		/*
		 * Only one octet long - error.
		 */
		goto bad_length;
	}
	value = (octet & 0x3) << 14;
	offset += 1;
	len -= 1;
	value_len++;

	if (len == 0) {
		/*
		 * We've reached the end of the information element - error.
		 */
		goto past_end;
	}
	octet = tvb_get_guint8(tvb, offset);
	if (octet & Q931_IE_VL_EXTENSION) {
		/*
		 * Only two octets long - error.
		 */
		goto bad_length;
	}
	value |= (octet & 0x7F) << 7;
	offset += 1;
	len -= 1;
	value_len++;

	if (len == 0) {
		/*
		 * We've reached the end of the information element - error.
		 */
		goto past_end;
	}
	octet = tvb_get_guint8(tvb, offset);
	if (!(octet & Q931_IE_VL_EXTENSION)) {
		/*
		 * More than three octets long - error.
		 */
		goto bad_length;
	}
	value |= (octet & 0x7F);
	offset += 1;
	len -= 1;
	value_len++;

	//proto_tree_add_text(tree, tvb, offset, value_len,
	printf("%s: %u ms\n", label,
	    value);
	return value_len;

past_end:
	//proto_tree_add_text(tree, tvb, offset, len,
	   printf( "%s goes past end of information element\n", label);
	return -1;

bad_length:
	//proto_tree_add_text(tree, tvb, offset, len, 
		printf("%s isn't 3 octets long\n",
	    label);
	return -1;
}

/*
 * Dissect an End-to-end transit delay information element.
 */
static void
dissect_q931_e2e_transit_delay_ie(tvbuff_t *tvb, int offset, int len)
{
	int value_len;

	if (len == 0)
		return;
	value_len = dissect_q931_guint16_value(tvb, offset, len,
	    "Cumulative transit delay");
	if (value_len < 0)
		return;	/* error */
	offset += value_len;
	len -= value_len;

	if (len == 0)
		return;
	value_len = dissect_q931_guint16_value(tvb, offset, len,
	    "Requested end-to-end transit delay");
	if (value_len < 0)
		return;	/* error */
	offset += value_len;
	len -= value_len;

	if (len == 0)
		return;
	value_len = dissect_q931_guint16_value(tvb, offset, len,
	    "Maximum end-to-end transit delay");
}
static void
dissect_q931_td_selection_and_int_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len == 0)
		return;
	dissect_q931_guint16_value(tvb, offset, len,
	    "Transit delay");
}
static const value_string q931_fast_selected_vals[] = {
	{ 0x00, "Fast select not requested" },
	{ 0x08, "Fast select not requested" },
	{ 0x10, "Fast select requested with no restriction of response" },
	{ 0x18, "Fast select requested with restrictions of response" },
	{ 0x00, NULL }
};

static void
dissect_q931_pl_binary_parameters_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	//proto_tree_add_text(tree, tvb, offset, 1,
	   printf( "Fast select: %s\n",
	    val_to_str(octet & 0x18, q931_fast_selected_vals, "Unknown (0x%02X)"));
	//proto_tree_add_text(tree, tvb, offset, 1,
	  printf(  "%s\n",
	    (octet & 0x04) ? "No request/request denied" :
	    		     "Request indicated/request accepted");
	//proto_tree_add_text(tree, tvb, offset, 1,
	  printf(  "%s confirmation\n",
	    (octet & 0x02) ? "Link-by-link" : "End-to-end");
	//proto_tree_add_text(tree, tvb, offset, 1,
	   printf( "Modulus %u sequencing\n",
	    (octet & 0x01) ? 8 : 128);
}


static void
dissect_q931_pl_window_size_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len == 0)
		return;
	//proto_tree_add_text(tree, tvb, offset, 1,
	   printf( "Forward value: %u\n", tvb_get_guint8(tvb, offset) & 0x7F);
	offset += 1;
	len -= 1;

	if (len == 0)
		return;
	//proto_tree_add_text(tree, tvb, offset, 1,
	    printf("Backward value: %u\n", tvb_get_guint8(tvb, offset) & 0x7F);
}

/*
 * Dissect a Packet size information element.
 */
static void
dissect_q931_packet_size_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len == 0)
		return;
	//proto_tree_add_text(tree, tvb, offset, 1,
	   printf( "Forward value: %u\n", tvb_get_guint8(tvb, offset) & 0x7F);
	offset += 1;
	len -= 1;

	if (len == 0)
		return;
	//proto_tree_add_text(tree, tvb, offset, 1,
	    printf("Backward value: %u\n", tvb_get_guint8(tvb, offset) & 0x7F);
}

/*
 * Dissect a Closed user group information element.
 */
static const value_string q931_cug_indication_vals[] = {
	{ 0x01, "Closed user group selection" },
	{ 0x02, "Closed user group with outgoing access selection and indication" },
	{ 0,    NULL }
};

static void
dissect_q931_cug_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len == 0)
		return;
	///proto_tree_add_text(tree, tvb, offset, 1,
	   printf( "CUG indication: %s\n",
	    val_to_str(tvb_get_guint8(tvb, offset) & 0x07,
	      q931_cug_indication_vals, "Unknown (0x%02X)"));
	offset += 1;
	len -= 1;

	if (len == 0)
		return;
	//proto_tree_add_text(tree, tvb, offset, len, 
	printf("CUG index code: %s\n",
	    tvb_format_text(tvb, offset, len));
}

/*
 * Dissect a Reverse charging indication information element.
 */
static const value_string q931_reverse_charging_indication_vals[] = {
	{ 0x01, "Reverse charging requested" },
	{ 0,    NULL }
};

static void
dissect_q931_reverse_charge_ind_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len == 0)
		return;
	//proto_tree_add_text(tree, tvb, offset, 1,
	    printf("Reverse charging indication: %s\n",
	    val_to_str(tvb_get_guint8(tvb, offset) & 0x07,
	      q931_reverse_charging_indication_vals, "Unknown (0x%02X)"));
}
void
dissect_e164_number(tvbuff_t *tvb, int offset, int length,e164_info_t e164_info)
{
	switch (e164_info.e164_number_type){
	case CALLING_PARTY_NUMBER :
		//proto_tree_add_string(tree, hf_E164_calling_party_number, tvb, offset,
				//length, e164_info.E164_number_str);
		break;

	case CALLED_PARTY_NUMBER :
		//proto_tree_add_string(tree, hf_E164_called_party_number, tvb, offset,
			//	length, e164_info.E164_number_str);
		break;

	default:
		break;
	}

}


static const value_string q931_redirection_reason_vals[] = {
	{ 0x00, "Unknown" },
	{ 0x01, "Call forwarding busy or called DTE busy" },
	{ 0x02, "Call forwarding no reply" },
	{ 0x04, "Call deflection" },
	{ 0x09, "Called DTE out of order" },
	{ 0x0A, "Call forwarding by the called DTE" },
	{ 0x0F, "Call forwarding unconditional or systematic call redirection" },
	{ 0,    NULL }
};
static void
dissect_q931_number_ie(tvbuff_t *tvb, int offset, int len,int hfindex, e164_info_t e164_info)
{
	guint8 octet;
	gint number_plan;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	number_plan = octet & 0x0f;
	e164_info.nature_of_address = ( octet & 0x70 ) >> 4;


	offset += 1;
	len -= 1;

	if (!(octet & Q931_IE_VL_EXTENSION)) {
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		offset += 1;
		len -= 1;
	}

	/*
	 * XXX - only in a Redirecting number information element.
	 */
	if (!(octet & Q931_IE_VL_EXTENSION)) {
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		//proto_tree_add_text(tree, tvb, offset, 1,
		    printf("Reason for redirection: %s\n",
		    val_to_str(octet & 0x0F, q931_redirection_reason_vals,
		      "Unknown (0x%X)"));
		offset += 1;
		len -= 1;
	}

	if (len == 0)
		return;

	if ( number_plan == 1 ) {
		if ( e164_info.e164_number_type != NONE ){

			e164_info.E164_number_str = (char*)tvb_get_ephemeral_string(tvb, offset, len);
			e164_info.E164_number_length = len;
			dissect_e164_number(tvb,offset, len, e164_info);
		}
	}

    /* Collect q931_packet_info */
    if ( e164_info.e164_number_type == CALLING_PARTY_NUMBER && have_valid_q931_pi)
          q931_pi->calling_number =(gchar*) tvb_get_ephemeral_string(tvb, offset, len);
    if ( e164_info.e164_number_type == CALLED_PARTY_NUMBER && have_valid_q931_pi)
          q931_pi->called_number = (gchar*)tvb_get_ephemeral_string(tvb, offset, len);
}
static const value_string q931_subaddress_type_vals[] = {
	{ 0x00, "X.213/ISO 8348 Add.2 NSAP" },
	{ 0x20, "User-specified" },
	{ 0,    NULL }
};

static const value_string q931_odd_even_indicator_vals[] = {
	{ 0x00, "Even number of address signals" },
	{ 0x08, "Odd number of address signals" },
	{ 0,    NULL }
};
static void
dissect_q931_party_subaddr_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	//proto_tree_add_text(tree, tvb, offset, 1,
	   printf( "Type of subaddress: %s\n",
	    val_to_str(octet & 0x70, q931_subaddress_type_vals,
	      "Unknown (0x%02X)"));
	//proto_tree_add_text(tree, tvb, offset, 1,
	   printf( "Odd/even indicator: %s\n",
	    val_to_str(octet & 0x08, q931_odd_even_indicator_vals,
	      "Unknown (0x%02X)"));
	offset += 1;
	len -= 1;

	if (len == 0)
		return;
	//proto_tree_add_text(tree, tvb, offset, len,
	printf("Subaddress: %s\n",
	    tvb_bytes_to_str(tvb, offset, len));
}
static const value_string q931_restart_indicator_class_vals[] = {
	{ 0x00, "Indicated channels" },
	{ 0x06, "Single interface" },
	{ 0x07, "All interfaces" },
	{ 0,    NULL }
};

static void
dissect_q931_restart_indicator_ie(tvbuff_t *tvb, int offset, int len)
{
	if (len != 1) {
		//proto_tree_add_text(tree, tvb, offset, len,
		   printf( "Restart indicator: length is %d, should be 1\n", len);
		return;
	}
	//proto_tree_add_text(tree, tvb, offset, 1,
	   printf(  "Restart indicator: %s\n",
	    val_to_str(tvb_get_guint8(tvb, offset) & 0x07,
	      q931_restart_indicator_class_vals, "Unknown (0x%02X)"));
}

void
dissect_q931_high_layer_compat_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;
	guint8 coding_standard;
	guint8 pres_method;
	guint8 characteristics;

	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	coding_standard = octet & 0x60;
	pres_method = octet & 0x03;

	offset += 1;
	len -= 1;
	if ((coding_standard != Q931_ITU_STANDARDIZED_CODING) || (pres_method != Q931_HIGH_LAYER_PROTOCOL_PROFILE)) {
		/*
		 * We don't know how the call state is encoded,
		 * so just dump it as data and be done with it.
		 */
	//	proto_tree_add_text(tree, tvb, offset,
		    //len, 
		printf("Data: %s\n",
		    tvb_bytes_to_str(tvb, offset, len));
		return;
	}
	if (len == 0)
		return;

	octet = tvb_get_guint8(tvb, offset);
	characteristics = octet & 0x7F;

	offset += 1;
	len -= 1;

	if (!(octet & Q931_IE_VL_EXTENSION)) {
		if (len == 0)
			return;
		octet = tvb_get_guint8(tvb, offset);
		/*if ((characteristics == Q931_AUDIOVISUAL) || (characteristics == 0x61) || (characteristics == 0x62) ||
			(characteristics == 0x68)) {
			proto_tree_add_item(tree, hf_q931_extension_ind, tvb, offset, 1, ENC_BIG_ENDIAN);
			proto_tree_add_uint(tree, hf_q931_extended_audiovisual_characteristics, tvb, offset, 1, octet);
		}
		else if ((characteristics == Q931_MANAGEMENT) || (characteristics == Q931_MAINTENANCE)) {
			proto_tree_add_item(tree, hf_q931_extension_ind, tvb, offset, 1, ENC_BIG_ENDIAN);
			proto_tree_add_uint(tree, hf_q931_extended_high_layer_characteristics, tvb, offset, 1, octet);
		}*/
	}
}

void
dissect_q931_user_user_ie(tvbuff_t *tvb, packet_info *pinfo, int offset, int len,H323_attr* h323_val)
{
	guint8 octet;
	tvbuff_t *next_tvb = NULL;
	tvbuff_t *h_225_tvb=NULL;
	if (len == 0)
		return;
	octet = tvb_get_guint8(tvb, offset);
	//proto_tree_add_text(tree, tvb, offset, 1,
	    printf("Protocol discriminator: %s 0x%02x\n",
	    val_to_str_ext(octet, &q931_protocol_discriminator_vals_ext,
	    "Unknown (0x%02x)"),octet);
	offset += 1;
	len -= 1;

	if (len == 0)
		return;
	switch (octet) {

	case Q931_PROTOCOL_DISCRIMINATOR_USER:
		next_tvb = tvb_new_subset(tvb, offset, len, len);
		//proto_tree_add_text(tree, tvb, offset, len,
		printf("User information: %d octets\n", len);
		/*if (!dissector_try_heuristic(q931_user_heur_subdissector_list, next_tvb, pinfo, tree)) {
		call_dissector_only(data_handle, next_tvb, pinfo, tree);
		}*/
		break;

	case Q931_PROTOCOL_DISCRIMINATOR_IA5:
		//proto_tree_add_text(tree, tvb, offset, len, 
			printf("User information: %s\n",
		    tvb_format_text(tvb, offset, len));
		break;

	default:
		//proto_tree_add_text(tree, tvb, offset, len, 
		printf("User information: %s\n",
		    tvb_bytes_to_str(tvb, offset, len));
		//H.225 protoc
		/*h_225_tvb=new_octet_aligned_subset(tvb, offset, actx, length);*/
		next_tvb = tvb_new_subset(tvb, offset, len, len);
   dissect_h225_H323UserInformation(next_tvb,pinfo,h323_val);
		break;
	}
}
static const value_string q931_party_category_vals[] = {
	{ 0x00,	"Unknown" },
	{ 0x01,	"Extension" },
	{ 0x02,	"Operator" },
	{ 0x03,	"Emergency extension" },
	{ 0,	NULL }
};

static void
dissect_q931_party_category_ie(tvbuff_t *tvb, int offset, int len)
{
	guint8 octet;

	if (len == 0)
		return;

	octet = tvb_get_guint8(tvb, offset);
	//proto_tree_add_text(tree, tvb, offset, 1,
	    printf("Party category: %s\n",
	    val_to_str(octet&0x07, q931_party_category_vals,
	    "Unknown (0x%02x)"));
	offset += 1;
	len -= 1;

	if (len == 0)
		return;
}
static void
tap_queue_packet(int tap_id, const void *tap_specific_data)
{
	tap_packet_t *tpt;

	if(!tapping_is_active){
		return;
	}
	/*
	 * XXX - should we allocate this with an ep_allocator,
	 * rather than having a fixed maximum number of entries?
	 */
	if(tap_packet_index >= TAP_PACKET_QUEUE_LEN){
		//g_warning(
			fprintf(stderr,"Too many taps queued\n");
		return;
	}

	tpt=&tap_packet_array[tap_packet_index];
	tpt->tap_id=tap_id;
	//tpt->pinfo=pinfo;
	tpt->tap_specific_data=tap_specific_data;
	tap_packet_index++;
}
static void
dissect_q931_IEs(tvbuff_t *tvb, packet_info *pinfo,
    gboolean is_over_ip, int offset, int initial_codeset,H323_attr* h323_val)
{
	proto_item	*ti;
	//proto_tree	*ie_tree = NULL;
	guint8		info_element;
	guint8		dummy;
	guint16		info_element_len;
	int		codeset, locked_codeset;
	gboolean	non_locking_shift, first_segment;
	tvbuff_t	*h225_tvb, *next_tvb;
	e164_info_t e164_info;
	e164_info.e164_number_type = NONE;

	codeset = locked_codeset = initial_codeset;
	non_locking_shift = TRUE;
	first_segment = FALSE;
	while (tvb_reported_length_remaining(tvb, offset) > 0) {
		info_element = tvb_get_guint8(tvb, offset);
		
		/* Check for the codeset shift */
		if ((info_element & Q931_IE_SO_MASK) &&
		    ((info_element & Q931_IE_SO_IDENTIFIER_MASK) == Q931_IE_SHIFT)) {   //  Q931_IE_SO_MASK = 0x80, Q931_IE_SO_IDENTIFIER_MASK = 0xf0, Q931_IE_SHIFT = 0x90
			non_locking_shift = info_element & Q931_IE_SHIFT_NON_LOCKING;       //Q931_IE_SHIFT_NON_LOCKING = 0x08 , Q931_IE_SHIFT_CODESET = 0x07;
			codeset = info_element & Q931_IE_SHIFT_CODESET;
			if (!non_locking_shift)
				locked_codeset = codeset;
		//	if (q931_tree != NULL) {
				//proto_tree_add_text(q931_tree, tvb, offset, 1,
				    printf("%s shift to codeset %u: %s\n",
				    (non_locking_shift ? "Non-locking" : "Locking"),
				    codeset,
				    val_to_str(codeset, q931_codeset_vals,
				      "Unknown (0x%02X)"));
			//}
			offset += 1;
			continue;
		}

		/*
		 * Check for the single-octet IEs.
		 */
		if (info_element & Q931_IE_SO_MASK) {
			/*
			 * Check for subdissectors for this IE or
			 * for all IEs in this codeset.
			 */
			//if (dissector_get_uint_handle(codeset_dissector_table, codeset) ||
			   // dissector_get_uint_handle(ie_dissector_table, (codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK))) {
				next_tvb = tvb_new_subset (tvb, offset, 1, 1);
				if (dissector_try_uint(ie_dissector_table, (codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK), next_tvb, pinfo) ||
				    dissector_try_uint(codeset_dissector_table, codeset, next_tvb, pinfo)) {
					offset += 1;
					codeset = locked_codeset;
					continue;
				}
			//}

			switch ((codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK)) {

			case CS0 | Q931_IE_MORE_DATA_OR_SEND_COMP:
				switch (info_element) {

				case Q931_IE_MORE_DATA:
				/*	if (q931_tree != NULL) {
						proto_tree_add_text(q931_tree, tvb, offset, 1,
						    "More data");
					}*/
					break;

				case Q931_IE_SENDING_COMPLETE:
				/*	if (q931_tree != NULL) {
						proto_tree_add_text(q931_tree, tvb, offset, 1,
						    "Sending complete");
					}*/
					   printf( "Sending complete\n");
					break;

				default:
					//if (q931_tree != NULL) {
						//proto_tree_add_text(q931_tree, tvb, offset, 1,
						   printf( "Unknown information element (0x%02X)\n",
						    info_element);
					//}
					break;
				}
				break;

			case CS0 | Q931_IE_CONGESTION_LEVEL:
				//if (q931_tree != NULL) {
					//proto_tree_add_text(q931_tree, tvb, offset, 1,
					    printf("Congestion level: %s\n",
					    val_to_str(info_element & Q931_IE_SO_IE_MASK,
					      q931_congestion_level_vals,
					      "Unknown (0x%X)"));
				//}
				break;

			case CS0 | Q931_IE_REPEAT_INDICATOR:
				//if (q931_tree != NULL) {
					//proto_tree_add_text(q931_tree, tvb, offset, 1,
					   printf( "Repeat indicator: %s\n",
					    val_to_str(info_element & Q931_IE_SO_IE_MASK,
				    	  q931_repeat_indication_vals,
					      "Unknown (0x%X)"));
				//}
				break;

			default:
				//if (q931_tree != NULL) {
					//proto_tree_add_text(q931_tree, tvb, offset, 1,
					    printf("Unknown information element (0x%02X)\n",
					    info_element);
				//}
				break;
			}
			offset += 1;
			codeset = locked_codeset;
			continue;
		}
		if (is_over_ip && tvb_bytes_exist(tvb, offset, 4) &&
		    codeset == 0 && tvb_get_guint8(tvb, offset) == Q931_IE_USER_USER &&
		    tvb_get_guint8(tvb, offset + 3) == Q931_PROTOCOL_DISCRIMINATOR_ASN1)  {
			info_element_len = tvb_get_ntohs(tvb, offset + 1);
			//if (q931_tree != NULL) {
				//ti = proto_tree_add_text(q931_tree, tvb, offset,
				  //  1+2+info_element_len,
			printf("%s\n",
				    val_to_str(info_element,
				      q931_info_element_vals[codeset],
				      "Unknown information element (0x%02X)"));
				//ie_tree = proto_item_add_subtree(ti,
				    //ett_q931_ie);
				//proto_tree_add_text(ie_tree, tvb, offset, 1,
				    printf("Information element: %s\n",
				    val_to_str(info_element,
				      q931_info_element_vals[codeset], "Unknown (0x%02X)"));
				//proto_tree_add_text(ie_tree, tvb, offset + 1,
				   // 2, 
					printf("Length: %u\n", info_element_len);
				//proto_tree_add_text(ie_tree, tvb, offset + 3,
				   // 1, 
						printf("Protocol discriminator: %s\n",
				    val_to_str_ext(tvb_get_guint8(tvb, offset + 3),
				      &q931_protocol_discriminator_vals_ext,
				      "Unknown (0x%02x)"));
			//}

			if (info_element_len > 1) {
				/*
				 * If we don't desegment limit the length
				 * to the actual size in the frame
				 */
				if (!pinfo->can_desegment) {
					info_element_len = MIN(info_element_len, tvb_length_remaining(tvb, offset + 3));
				}
				/*
				 * Do we have a handle for the H.225
				 * dissector?
				 */
				if (h225_handle != NULL) {
					/*
					 * Yes - call it, regardless of
					 * whether we're building a
					 * protocol tree or not.
					 */
					h225_tvb = tvb_new_subset(tvb,
					    offset + 4, info_element_len - 1,
					    info_element_len - 1);
					//call_dissector(h225_handle, h225_tvb,
					    //pinfo, root_tree);
				} else {
					/*
					 * No - just show it as "User
					 * information" (if "ie_tree" is
					 * null, this won't add anything).
					 */
					//proto_tree_add_text(ie_tree, tvb,
					   // offset + 4, info_element_len - 1,
					   printf( "User information: %s\n",
					    tvb_bytes_to_str(tvb, offset + 4,
					      info_element_len - 1));
				}
			}
			offset += 1 + 2 + info_element_len;
		} else {
			info_element_len = tvb_get_guint8(tvb, offset + 1);
		

			if (first_segment && (tvb_reported_length_remaining(tvb, offset + 2) < info_element_len)) {  /* incomplete IE at the end of the 1st segment */
				//proto_tree_add_text(q931_tree, tvb, offset, tvb_reported_length_remaining(tvb, offset), 
				printf("Incomplete IE in the 1st segment\n");
				break;
			}

			/*
			 * Check for subdissectors for this IE or
			 * for all IEs in this codeset.
			 */
		/*	if (dissector_get_uint_handle(codeset_dissector_table, codeset) ||
			    dissector_get_uint_handle(ie_dissector_table, (codeset << 8) | info_element)) {*/
				next_tvb = tvb_new_subset (tvb, offset, info_element_len + 2, info_element_len + 2);
				if (dissector_try_uint(ie_dissector_table, (codeset << 8) | info_element, next_tvb, pinfo) ||
				    dissector_try_uint(codeset_dissector_table, codeset, next_tvb, pinfo)) {
					offset += 2 + info_element_len;
					codeset = locked_codeset;
					continue;
				}
			//}

			//ti = proto_tree_add_text(q931_tree, tvb, offset, 1+1+info_element_len, 
			printf( "%s\n",
				    val_to_str(info_element, q931_info_element_vals[codeset], "Unknown information element (0x%02X)"));
			//ie_tree = proto_item_add_subtree(ti, ett_q931_ie);
			//proto_tree_add_text(ie_tree, tvb, offset, 1, 
				printf( "Information element: %s\n",
				    val_to_str(info_element, q931_info_element_vals[codeset], "Unknown (0x%02X)"));
			//proto_tree_add_text(ie_tree, tvb, offset + 1, 1, 
				if(info_element==126){
					offset++;
					info_element_len=tvb_get_guint8(tvb, offset + 1);
			/*	printf("%d\n",info_element);*/
				}
				printf( "Length: %u\n", info_element_len);

			if (((codeset << 8) | info_element) == (CS0 | Q931_IE_SEGMENTED_MESSAGE)) {
				dissect_q931_segmented_message_ie(tvb, offset + 2, info_element_len);
				//if (check_col(pinfo->cinfo, COL_INFO)) {
					//col_append_fstr(pinfo->cinfo, COL_INFO,
						printf( " of %s\n",
					    val_to_str_ext(tvb_get_guint8(tvb, offset + 3), &q931_message_type_vals_ext, "Unknown message type (0x%02X)"));
				//}
				if (tvb_get_guint8(tvb, offset + 2) & 0x80) {  /* the 1st segment */
					first_segment = TRUE;
				} else {  /* not the 1st segment */
					//proto_tree_add_text(q931_tree, tvb, offset + 4, tvb_reported_length_remaining(tvb, offset + 4), "Message segment");
					info_element_len += tvb_reported_length_remaining(tvb, offset + 4);
				}
			} else {
				/*
				 * For the calling number, called number,
				 * and release cause IEs, don't check
				 * for the tree being null, as
				 * the dissectors for those IEs also
				 * supply information for the tap used
				 * in VoIP calls.
				 */
				switch ((codeset << 8) | info_element) {

				case CS0 | Q931_IE_BEARER_CAPABILITY:
				case CS0 | Q931_IE_LOW_LAYER_COMPAT:
					//if (q931_tree != NULL) {
						dissect_q931_bearer_capability_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_CAUSE:
					dissect_q931_cause_ie_unsafe(tvb,
						offset + 2, info_element_len,
						hf_q931_cause_value, &dummy, q931_info_element_vals0);
					break;

				case CS0 | Q931_IE_CHANGE_STATUS:
					//if (q931_tree != NULL) {
						dissect_q931_change_status_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_CALL_STATE:
					//if (q931_tree != NULL) {
						dissect_q931_call_state_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_CHANNEL_IDENTIFICATION:
					//if (q931_tree != NULL) {
						dissect_q931_channel_identification_ie(
							tvb, offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_PROGRESS_INDICATOR:
					//if (q931_tree != NULL) {
						dissect_q931_progress_indicator_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_NETWORK_SPECIFIC_FACIL:
				case CS0 | Q931_IE_TRANSIT_NETWORK_SEL:
					//if (q931_tree != NULL) {
						dissect_q931_ns_facilities_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_NOTIFICATION_INDICATOR:
					//if (q931_tree != NULL) {
						dissect_q931_notification_indicator_ie(
							tvb, offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_DISPLAY:
					//if (q931_tree != NULL) {
						dissect_q931_ia5_ie(tvb, offset + 2,
							info_element_len,
							"Display information");
					//}
					break;

				case CS0 | Q931_IE_DATE_TIME:
					//if (q931_tree != NULL) {
						dissect_q931_date_time_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_KEYPAD_FACILITY:
					//if (q931_tree != NULL) {
						dissect_q931_ia5_ie(tvb, offset + 2,
							info_element_len,
							"Keypad facility");
					//}
					break;

				case CS0 | Q931_IE_SIGNAL:
					//if (q931_tree != NULL) {
						dissect_q931_signal_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_INFORMATION_RATE:
					//if (q931_tree != NULL) {
						dissect_q931_information_rate_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_E2E_TRANSIT_DELAY:
					//if (q931_tree != NULL) {
						dissect_q931_e2e_transit_delay_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_TD_SELECTION_AND_INT:
					//if (q931_tree != NULL) {
						dissect_q931_td_selection_and_int_ie(
							tvb, offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_PL_BINARY_PARAMETERS:
					//if (q931_tree != NULL) {
						dissect_q931_pl_binary_parameters_ie(
							tvb, offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_PL_WINDOW_SIZE:
					//if (q931_tree != NULL) {
						dissect_q931_pl_window_size_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_PACKET_SIZE:
					//if (q931_tree != NULL) {
						dissect_q931_packet_size_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_CUG:
					//if (q931_tree != NULL) {
						dissect_q931_cug_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_REVERSE_CHARGE_IND:
					//if (q931_tree != NULL) {
						dissect_q931_reverse_charge_ind_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_CONNECTED_NUMBER_DEFAULT:
					//if (q931_tree != NULL) {
						dissect_q931_number_ie(tvb,
							offset + 2, info_element_len,
							hf_q931_connected_number, e164_info);
					//}
					break;


				case CS0 | Q931_IE_CALLING_PARTY_NUMBER:
					e164_info.e164_number_type = CALLING_PARTY_NUMBER;
					dissect_q931_number_ie(tvb,
						offset + 2, info_element_len,
						hf_q931_calling_party_number, e164_info);
					break;

				case CS0 | Q931_IE_CALLED_PARTY_NUMBER:
					e164_info.e164_number_type = CALLED_PARTY_NUMBER;
					dissect_q931_number_ie(tvb,
						offset + 2, info_element_len,
						
						hf_q931_called_party_number, e164_info);
					break;

				case CS0 | Q931_IE_CALLING_PARTY_SUBADDR:
				case CS0 | Q931_IE_CALLED_PARTY_SUBADDR:
					//if (q931_tree != NULL) {
						dissect_q931_party_subaddr_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_REDIRECTING_NUMBER:
					//if (q931_tree != NULL) {
						dissect_q931_number_ie(tvb,
							offset + 2, info_element_len,
							
							hf_q931_redirecting_number, e164_info);
					//}
					break;

				case CS0 | Q931_IE_RESTART_INDICATOR:
					//if (q931_tree != NULL) {
						dissect_q931_restart_indicator_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_HIGH_LAYER_COMPAT:
					//if (q931_tree != NULL) {
						dissect_q931_high_layer_compat_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS0 | Q931_IE_USER_USER:
					//if (q931_tree != NULL) {
						dissect_q931_user_user_ie(tvb, pinfo,
							offset + 2, info_element_len, h323_val);
					//}
					break;

				case CS5 | Q931_IE_PARTY_CATEGORY:
					//if (q931_tree != NULL) {
						dissect_q931_party_category_ie(tvb,
							offset + 2, info_element_len);
					//}
					break;

				case CS6 | Q931_IE_DISPLAY:
					//if (q931_tree != NULL) {
						dissect_q931_ia5_ie(tvb, offset + 2,
							info_element_len,
							"Avaya Display");
					//}
					break;

				default:
					//if (q931_tree != NULL) {
						//proto_tree_add_text( tvb,
							//offset + 2, info_element_len,
							printf("Data: %s\n",
							tvb_bytes_to_str(tvb, offset + 2,
							  info_element_len));
					//}
					break;
				}
			}
			offset += 1 + 1 + info_element_len;
		}
		codeset = locked_codeset;
	}

	if(have_valid_q931_pi) {
		tap_queue_packet(q931_tap,/* pinfo,*/ q931_pi);
	}
	have_valid_q931_pi=FALSE;
}

static void
dissect_q931_pdu(tvbuff_t *tvb, packet_info *pinfo,
    gboolean is_over_ip,H323_attr* h323_val)
{
	int		offset = 0;
	//proto_tree	*q931_tree = NULL;
	//proto_tree	*ie_tree = NULL;
	proto_item	*ti, *ti_ie;
	guint8		prot_discr;
	guint8		call_ref_len;
	guint8		call_ref[15],a;
	guint32		call_ref_val;
	char *flag_buff;
	guint8		message_type, segmented_message_type;
	guint8		info_element;
	guint16		info_element_len;
	gboolean	first_frag, more_frags;
	guint32		frag_len;
	fragment_data *fd_head;
	tvbuff_t *next_tvb = NULL;
	const gchar *msg_type;
	q931_pi=(q931_packet_info *)malloc(sizeof(q931_packet_info));

	/* Init struct for collecting q931_packet_info */
	//reset_q931_packet_info(q931_pi);
	have_valid_q931_pi=TRUE;

	//col_set_str(pinfo->cinfo, COL_PROTOCOL, 
		printf("Q.931\n");

	prot_discr = tvb_get_guint8(tvb, offset);
	//if (tree) {
		//ti = proto_tree_add_item(tree, proto_q931, tvb, offset, -1,
		 //   ENC_NA);
		//q931_tree = proto_item_add_subtree(ti, ett_q931);

		dissect_q931_protocol_discriminator(tvb, offset);
	//}
	offset += 1;
	call_ref_len = tvb_get_guint8(tvb, offset) & 0xF;	/* XXX - do as a bit field? */
	call_ref_val=tvb_get_guint8(tvb, offset) & 0xF;
	flag_buff=(char*)malloc(sizeof(char)*30);
	printf("call reference length: %d\n",call_ref_len);
	sprintf(flag_buff,"call reference value: %x%x",tvb_get_guint8(tvb, offset+1) ,tvb_get_guint8(tvb, offset+2) );
	
	//if (q931_tree != NULL)
		//proto_tree_add_uint(q931_tree, hf_q931_call_ref_len, tvb, offset, 1, call_ref_len);
	offset += 1;
	switch (call_ref_len) {
		case 0: call_ref_val = 0; break;
		case 1:	call_ref_val = tvb_get_guint8(tvb, offset);	break;
		case 2:	call_ref_val = tvb_get_ntohs(tvb, offset); break;
		case 3:	call_ref_val = tvb_get_ntoh24(tvb, offset); break;
		default: call_ref_val = tvb_get_ntohl(tvb, offset);
	}

	if (call_ref_len != 0) {
		tvb_memcpy(tvb, call_ref, offset, call_ref_len);
		//if (q931_tree != NULL) {
		//	proto_tree_add_boolean(q931_tree, hf_q931_call_ref_flag,
		  //  tvb, offset, 1, 
				//printf("flag %s\n",(call_ref[0] & 0x80) != 0);
			printf("Call reference flag: "/*,call_ref[0] &= 0x7F*/);
			a=First_bit(call_ref[0] &= 0x7F);
			if(a==0)
			{
				printf("Message sent from originating side\n");
			}
			else
			{
				printf("Message sent to originating side\n");
			}
			
	        printf("%s\n",flag_buff);
		//	proto_tree_add_bytes(q931_tree, hf_q931_call_ref,
		//	    tvb, offset, call_ref_len, call_ref);
		//} else
		//{       /* info for the tap */
		//	call_ref[0] &= 0x7F;
		//}
		/* XXX - Should crv be something besides a guint32? */
		memcpy(&(q931_pi->crv), call_ref, call_ref_len > sizeof(q931_pi->crv) ? sizeof(q931_pi->crv) : call_ref_len );
		offset += call_ref_len;
	}
	message_type = tvb_get_guint8(tvb, offset);
	if(have_valid_q931_pi) {
		q931_pi->message_type = message_type;
	}
	msg_type = get_message_name(prot_discr, message_type);
	h323_val->msg_type =(char*) msg_type;
	printf("Message Type: %s (0x%0x)\n",msg_type,message_type);
	/*if (check_col(pinfo->cinfo, COL_INFO)) {
		col_add_str(pinfo->cinfo, COL_INFO, 
		get_message_name(prot_discr, message_type));
	}*/
	//if (q931_tree != NULL){
	//	if (prot_discr == NLPID_DMS)
	//		proto_tree_add_item(q931_tree, hf_q931_maintenance_message_type, tvb, offset, 1, ENC_BIG_ENDIAN);
	//	else
	//		proto_tree_add_item(q931_tree, hf_q931_message_type, tvb, offset, 1, ENC_BIG_ENDIAN);
	//}
	offset += 1;

	/*
	 * And now for the information elements....
	 */
	if ((message_type != Q931_SEGMENT) || !q931_reassembly ||
			(tvb_reported_length_remaining(tvb, offset) <= 4)) {
		dissect_q931_IEs(tvb, pinfo, is_over_ip, offset, 0,h323_val);
		return;
	}
	info_element = tvb_get_guint8(tvb, offset);
	info_element_len = tvb_get_guint8(tvb, offset + 1);
	if ((info_element != Q931_IE_SEGMENTED_MESSAGE) || (info_element_len < 2)) {
		dissect_q931_IEs(tvb, pinfo, is_over_ip, offset, 0, h323_val);
		return;
	}
	/* Segmented message IE */
	//ti_ie = proto_tree_add_text(q931_tree, tvb, offset, 1+1+info_element_len, 
		printf("%s\n",
				    val_to_str(info_element, q931_info_element_vals[0], "Unknown information element (0x%02X)"));
	//ie_tree = proto_item_add_subtree(ti_ie, ett_q931_ie);
	//proto_tree_add_text(ie_tree, tvb, offset, 1,
		printf("Information element: %s\n",
				    val_to_str(info_element, q931_info_element_vals[0], "Unknown (0x%02X)"));
	//proto_tree_add_text(ie_tree, tvb, offset + 1, 1, 
		printf("Length: %u\n", info_element_len);
	dissect_q931_segmented_message_ie(tvb, offset + 2, info_element_len);
	first_frag = (tvb_get_guint8(tvb, offset + 2) & 0x80) != 0;
	more_frags = (tvb_get_guint8(tvb, offset + 2) & 0x7F) != 0;
	segmented_message_type = tvb_get_guint8(tvb, offset + 3);
	//if (check_col(pinfo->cinfo, COL_INFO)) {
		//col_append_fstr(pinfo->cinfo, COL_INFO, 
			printf(" of %s\n",
		    val_to_str_ext(segmented_message_type, &q931_message_type_vals_ext, "Unknown message type (0x%02X)"));
	//}
	offset += 1 + 1 + info_element_len;
	/* Reassembly */
	frag_len = tvb_reported_length_remaining(tvb, offset);
	//if (first_frag && fragment_get(pinfo, call_ref_val,	q931_fragment_table)) {
	//	/* there are some unreassembled segments, ignore them */
	//	fragment_end_seq_next(pinfo, call_ref_val, q931_fragment_table, q931_reassembled_table);
	//}
//	fd_head = fragment_add_seq_next(tvb, offset, pinfo, call_ref_val,
								/*	q931_fragment_table, q931_reassembled_table,
									frag_len, more_frags);*/
	//if (fd_head) {
	//	if (pinfo->fd->num == fd_head->reassembled_in) {  /* last fragment */
	//		if (fd_head->next != NULL) //{  /* 2 or more segments */
	//			next_tvb = tvb_new_child_real_data(tvb, fd_head->data, fd_head->len, fd_head->len);
	//			add_new_data_source(pinfo, next_tvb, "Reassembled Q.931 IEs");
	//			/* Show all fragments. */
 //              /* if (tree) {
 //                   proto_item *frag_tree_item;
 //                   show_fragment_seq_tree(fd_head, &q931_frag_items, q931_tree, pinfo, next_tvb, &frag_tree_item);
 //               }*/
	//		} else 
	//{  /* only 1 segment */
				next_tvb = tvb_new_subset_remaining(tvb, offset);
			//}
			//if (check_col(pinfo->cinfo, COL_INFO)) {
				//col_add_fstr(pinfo->cinfo, COL_INFO,
					printf("%s [reassembled]\n",
				    val_to_str_ext(segmented_message_type, &q931_message_type_vals_ext, "Unknown message type (0x%02X)"));
			//}
		//} else 
		//{
			//if (tree) proto_tree_add_uint(q931_tree, hf_q931_reassembled_in, tvb, offset, frag_len, fd_head->reassembled_in);
		//}
	//}
	if (next_tvb)
		dissect_q931_IEs(next_tvb, pinfo,is_over_ip, 0, 0,h323_val);
}
static void
dissect_q931(tvbuff_t *tvb, packet_info *pinfo,H323_attr* h323_val)
{
	dissect_q931_pdu(tvb, pinfo, FALSE, h323_val);
}
void
dissect_tpkt_encap(tvbuff_t *tvb, packet_info *pinfo, 
		   gboolean desegment, dissector_handle_t subdissector_handle,H323_attr* h323_val)
{
	proto_item *ti = NULL;
	//proto_tree *tpkt_tree = NULL;
	volatile int offset = 0;
	int length_remaining;
	int data_len,reserved;
	volatile int length;
	tvbuff_t *volatile next_tvb;
	const char *saved_proto;
	void *pd_save;
	guint8 octet;
	/*
	 * If we're reassembling segmented TPKT PDUs, empty the COL_INFO
	 * column, so subdissectors can append information
	 * without having to worry about emptying the column.
	 *
	 * We use "col_add_str()" because the subdissector
	 * might be appending information to the column, in
	 * which case we'd have to zero the buffer out explicitly
	 * anyway.
	 */
	if (desegment)
		//col_set_str(pinfo->cinfo, COL_INFO, "");

	while (tvb_reported_length_remaining(tvb, offset) != 0) {
		/*
		 * Is the first byte of this putative TPKT header
		 * a valid TPKT version number, i.e. 3?
		 */
		if (tvb_get_guint8(tvb, offset) != 3) {
			/*
			 * No, so don't assume this is a TPKT header;
			 * we might be in the middle of TPKT data,
			 * so don't get the length and don't try to
			 * do reassembly.
			 */
			//col_set_str(pinfo->cinfo, COL_PROTOCOL, 
			printf("TPKT\n");
		/*	col_set_str(pinfo->cinfo, COL_INFO, "Continuation");
			if (tree) {
				ti = proto_tree_add_item(tree, proto_tpkt, tvb,
				    offset, -1, ENC_NA);
				tpkt_tree = proto_item_add_subtree(ti, ett_tpkt);
				proto_item_set_text(ti, "TPKT");

				proto_tree_add_text(tpkt_tree, tvb, offset, -1,
				    "Continuation data");
			}*/
			return;
		}

		length_remaining = tvb_length_remaining(tvb, offset);

		/*
		 * Can we do reassembly?
		 */
		//if (desegment && pinfo->can_desegment) {
		//	/*
		//	 * Yes - is the TPKT header split across segment
		//	 * boundaries?
		//	 */
		//	if (length_remaining < 4) {
		//		/*
		//		 * Yes.  Tell the TCP dissector where the data
		//		 * for this message starts in the data it
		//		 * handed us and that we need "some more data."
		//		 * Don't tell it exactly how many bytes we need
		//		 * because if/when we ask for even more (after
		//		 * the header) that will break reassembly.
		//		 */
		//		pinfo->desegment_offset = offset;
		//		pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;
		//		return;
		//	}
		//}

		/*
		 * Get the length from the TPKT header.
		 */
		reserved = tvb_get_guint8(tvb, offset + 1);
		data_len = tvb_get_ntohs(tvb, offset + 2);
		
		/*
		 * Can we do reassembly?
		 */
		//if (desegment && pinfo->can_desegment) {
		//	/*
		//	 * Yes - is the payload split across segment
		//	 * boundaries?
		//	 */
		//	if (length_remaining < data_len) {
		//		/*
		//		 * Yes.  Tell the TCP dissector where
		//		 * the data for this message starts in
		//		 * the data it handed us, and how many
		//		 * more bytes we need, and return.
		//		 */
		//		pinfo->desegment_offset = offset;
		//		pinfo->desegment_len =
		//		    data_len - length_remaining;
		//		return;
		//	}
		//}

		/*
		 * Dissect the TPKT header.
		 * Save and restore "pinfo->current_proto".
		 */
		//saved_proto = pinfo->current_proto;
		//pinfo->current_proto = "TPKT";

	//	col_set_str(pinfo->cinfo, COL_PROTOCOL, "TPKT");
		/*
		 * Don't add the TPKT header information if we're
		 * reassembling segmented TPKT PDUs or if this
		 * PDU isn't reassembled.
		 *
		 * XXX - the first is so that subdissectors can append
		 * information without getting TPKT stuff in the middle;
		 * why the second?
		 */
		if (!desegment && !pinfo->fragmented) {
			//col_add_fstr(pinfo->cinfo, COL_INFO,
			   printf( "TPKT Data length = %u\n", data_len);
		}

		//if (tree) {
			/*ti = proto_tree_add_item(tree, proto_tpkt, tvb,
			    offset, 4, ENC_NA);
			tpkt_tree = proto_item_add_subtree(ti, ett_tpkt);
			proto_item_set_text(ti, "TPKT");*/

			/* Version */
			/*proto_tree_add_item(tpkt_tree, hf_tpkt_version, tvb,
			    offset, 1, ENC_BIG_ENDIAN);
			proto_item_append_text(ti, */
		printf("Version: 3\n");
       printf(" Reserved: %d\n", reserved);
			/* Reserved octet*/
			/*proto_tree_add_item(tpkt_tree, hf_tpkt_reserved, tvb,
			    offset + 1, 1, 
				printf(ENC_BIG_ENDIAN);*/

			/* Length */
			//proto_tree_add_uint(tpkt_tree, hf_tpkt_length, tvb,
			  //  offset + 2, 2, data_len);
			//proto_item_append_text(ti,
		printf(" Length: %u\n", data_len);
		
	//	}
		//pinfo->current_proto = saved_proto;

		/* Skip the TPKT header. */
		offset += 4;
		data_len -= 4;

		/*
		 * Construct a tvbuff containing the amount of the payload
		 * we have available.  Make its reported length the
		 * amount of data in this TPKT packet.
		 *
		 * XXX - if reassembly isn't enabled. the subdissector
		 * will throw a BoundsError exception, rather than a
		 * ReportedBoundsError exception.  We really want
		 * a tvbuff where the length is "length", the reported
		 * length is "plen + 2", and the "if the snapshot length
		 * were infinite" length were the minimum of the
		 * reported length of the tvbuff handed to us and "plen+2",
		 * with a new type of exception thrown if the offset is
		 * within the reported length but beyond that third length,
		 * with that exception getting the "Unreassembled Packet"
		 * error.
		 */
		length = length_remaining - 4;
		if (length > data_len)
			length = data_len;
		next_tvb = tvb_new_subset(tvb, offset, length, data_len);

		/*
		 * Call the subdissector.
		 *
		 * Catch the ReportedBoundsError exception; if this
		 * particular message happens to get a ReportedBoundsError
		 * exception, that doesn't mean that we should stop
		 * dissecting TPKT messages within this frame or chunk
		 * of reassembled data.
		 *
		 * If it gets a BoundsError, we can stop, as there's nothing
		 * more to see, so we just re-throw it.
		 */
	//	pd_save = pinfo->private_data;
		//TRY {
		//	call_dissector(subdissector_handle, next_tvb, pinfo);
			    /////);
		//}
		//CATCH(BoundsError) {
			//RETHROW;
		//}
		//CATCH(ReportedBoundsError) {
		//	/*  Restore the private_data structure in case one of the
		//	 *  called dissectors modified it (and, due to the exception,
		//	 *  was unable to restore it).
		//	 */
		//	pinfo->private_data = pd_save;

		//	show_reported_bounds_error(tvb, pinfo, tree);
		//}
		//ENDTRY;

		/*
		 * Skip the payload.
		 */
		octet=tvb_get_guint8(next_tvb,0);
		if (octet==8)
		{
		dissect_q931( next_tvb,  pinfo, h323_val);
		}
		else
		{
		dissect_h245_h245( next_tvb,  pinfo);
		}
		offset += length;
	}
}

/*
 * Dissect RFC 1006 TPKT, which wraps a TPKT header around an OSI TP
 * PDU.
 */

/* TPKT fields defining a sub tree */
static gint ett_tpkt           = -1;

/* desegmentation of OSI over TPKT over TCP */
static gboolean tpkt_desegment = TRUE;

#define TCP_PORT_TPKT		102

/* find the dissector for OSI TP (aka COTP) */
static dissector_handle_t osi_tp_handle;

static H323_attr* 
dissect_tpkt(tvbuff_t *tvb, packet_info *pinfo,H323_attr* h323_val)
{
	dissect_tpkt_encap(tvb, pinfo,  tpkt_desegment, osi_tp_handle,h323_val);
	return h323_val;
}
void next_protocol_identifier(tvbuff_t *tvb, packet_info *pinfo,H323_attr* h323_val)
{

	guint8 nextProtocol;
	nextProtocol=tvb_get_guint8(tvb,0);
	switch(nextProtocol)
	{
	case 8:
		dissect_q931(tvb,pinfo, h323_val);
		break;
	case 9:
		printf("Q.2831 protocol");
	default:

		dissect_h245_h245(tvb,pinfo);
		break;
	
	
	}

}
//H323_attr* test_main(guint8* data,H323_attr* h323_val,int length)
//{
//	packet_info * pinfo=0;
//	tvbuff_t *tvb=(tvbuff_t *) malloc(sizeof(tvbuff_t));
//	tvb->real_data=data;
//	tvb->length=length;
//	tvb->reported_length=tvb->length;
//	dissect_tpkt(tvb, pinfo,h323_val);
//	h323_val->src_ip=h323_src_ip;
//	h323_val->dest_ip=h323_dest_ip;
//	return h323_val;
//}

int main()
{
	FILE* storeFile;
    guint8 rr;
	long  lsize;
	packet_info *pinfo =0;
	H323_attr* h323_val;
	int length=0;
	guint8 *ptr;
	guint8 *def_ip = (guint8 *) malloc(sizeof(guint8));
	for(int k = 0;k<4;k++){
		def_ip[k] = 0;
	}   
	 h323_val=(H323_attr *) malloc(sizeof(H323_attr));
	h323_val->msg_type = "Unknown";
	tvbuff_t *tvb=(tvbuff_t *) malloc(sizeof(tvbuff_t));
	storeFile=fopen("tpkt_225"/*"connect2"*//*"tpkt_4"*/ /*"Q.931_a"*/ /*"tpkt_h245"*/, "rb");
	 if(storeFile==NULL)
	{
		printf("Fail to Open file!!");
	}
	 else
	 {
	   printf("file is opened !!!\n");
	 }
	 fseek (storeFile , 0 , SEEK_END);
     lsize = ftell (storeFile);
     rewind (storeFile);
     ptr = (guint8*) malloc (sizeof(char)*lsize);
	length= fread(ptr,sizeof(char),lsize , storeFile);
	tvb->real_data=ptr;
	tvb->length=length;
	tvb->reported_length=tvb->length;
		h323_val = dissect_tpkt(tvb, pinfo,h323_val);
	if(h323_val->msg_type == "SETUP"){
		h323_val->src_ip = ip_val->src_ip;
		h323_val->dest_ip = ip_val->dest_ip;
	}
	else if(h323_val->msg_type == "CONNECT")
	{
   h323_val->h245_ip=ip_val->h245_ip;
   h323_val->h245_port=ip_val->h245_port;
   h323_val->src_ip = def_ip;
   h323_val->dest_ip = def_ip;
	}
	else{
		h323_val->src_ip = def_ip;
		h323_val->dest_ip = def_ip;
	}
	//printf("source port:");
	for(int i=0;i<4;i++)
	{
	 //printf("%d ",h323_val->h245_ip[i]);
	}
	printf("\ndestnation port:");
	for(int i=0;i<4;i++)
	{
	 printf("%d ",h323_val->dest_ip[i]);
	}
	//test_main(ptr,h323_val,length);
	dissect_h245_h245(tvb,pinfo);
	dissect_q931(tvb,pinfo,h323_val);
	next_protocol_identifier(tvb, pinfo,h323_val);
	printf("\nFile Size %u bytes\n",length);
	printf("end of main \n");
	return 0;
}
